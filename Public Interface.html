<div style="margin-top: 20px; margin-left: 25px;">
<p><b><i>This document describes the public interface of the library</b></i></p>

<p>Index:</p>

<a href="#array">array.cpp</a><br />
<a href="#pair">pair.cpp</a><br />
<a href="#tuple">tuple.cpp</a><br />
<a href="#range">range.cpp</a><br />
<a href="#list">list.cpp</a><br />
<a href="#string">string.cpp</a><br />
<a href="#numeric">numeric.cpp</a><br />
<a href="#bit_operations">bit_operations.cpp</a><br />
<a href="#byte_operations">byte_operations.cpp</a><br />
<a href="#unicode">unicode.cpp</a><br />
<a href="#time">time.cpp</a><br />
<a href="#filesystem">filesystem.cpp</a><br />
<a href="#event">event.cpp</a><br />
<a href="#timer">timer.cpp</a><br />
<a href="#chronometer">chronometer.cpp</a><br />

<p>-----------------------------------------------------------------------------------------</p>
<p id="array" style="color:rgb(100, 100, 255);"><b>array.cpp:</b></p>
<p>struct array:<br /> # FIELDS:<br /> T* pointer<br /> int length</p>
<p>struct range:<br /> # FIELDS:<br /> int begin<br /> int end</p>
<p># NON-MUTATING FUNCTIONS:</p>
<p># _length specifies the length of _array<br />template&lt;typename T&gt; bool contains(const T* const _array, int _length, T _value)</p>
<p># _length specifies the length of _array<br /># _length_ specifies the length of _value<br />template&lt;typename T&gt; bool contains(const T* const _array, int _length, const T* const _value, int _length_)</p>
<p># _length specifies the length of _array<br /># except([2, 9, 0, 1, 4, 9, 7, 3], 8, 9) =&gt; [2, 0, 1, 4, 7, 3]<br />template&lt;typename T&gt; array except(const T* const _array, int _length, T _value)</p>
<p># _length1 specifies the length of _array1<br /># _length2 specifies the length of _array2<br /># equality(nullptr, nullptr, x, x) =&gt; TRUE<br /># equality([5, 0, 9], [5, 0, 9, 5], 3, 4) =&gt; FALSE<br /># equality([5, 0, 9], [6, 4, 1], 3, 3) =&gt; FALSE<br /># equality([5, 0, 9], [5, 9, 0], 3, 3) =&gt; FALSE<br /># equality([5, 0, 9], [5, 0, 9], 3, 3) =&gt; TRUE<br />template&lt;typename T&gt; bool equality(const T* const _array1, const T* const _array2, int _length1, int _length2)</p>
<p># _length specifies the length of _array<br /># the specified value does not exist =&gt; -1<br />template&lt;typename T&gt; int indexOf(const T* const _array, int _length, T _value)</p>
<p># _length1 specifies the length of _array1<br /># _length2 specifies the length of _array2<br /># _value2 does not exist in _value1 or _begin is outside the range of list =&gt; -1<br />template&lt;typename T&gt; int indexOf(const T* _array1, const T* _array2, int _length1, int _length2, int _begin)</p>
<p># _length specifies the length of _array<br /># indexOfNot([9, 9, 9, 5, 8, 10, 2, 7], 8, 9) =&gt; 3<br /># indexOfNot([9, 9, 9, 5, 8, 10, 2, 7], 8, 4) =&gt; 0<br />template&lt;typename T&gt; int indexOfNot(const T* const _array, int _length, T _value)</p>
<p># _length specifies the length of _array<br />template&lt;typename T&gt; bool isHeterogenous(const T* const _array, int _length)</p>
<p># _length specifies the length of _array<br />template&lt;typename T&gt; bool isHomogenous(const T* const _array, int _length)</p>
<p># _length specifies the length of _array<br /># the specified value does not exist =&gt; -1<br />template&lt;typename T&gt; int lastIndexOf(const T* const _array, int _length, T _value)</p>
<p># returns the range of a sequence consisting of certain set of values (it is not mandatory for the sequence to contain each value in the set)<br /># _length specifies the length of _array<br /># _length_ specifies the length of _set<br /># [3, 10, 15, 12, 8, 5, 7, 5, 5, 7, 7, 3, 9].RangeOf([2, 5, 7]) =&gt; (5, 10)<br /># [3, 10, 15, 12, 8, 5, 7, 2, 2, 7, 7, 3, 9].RangeOf([2, 5, 7]) =&gt; (5, 10)<br /># [3, 10, 15, 12, 0, 5, 7, 2, 2, 7, 7, 3, 9].RangeOf([4, 0, 1]) =&gt; (4, 4)<br /># [3, 10, 15, 12, 8, 5, 7, 2, 2, 7, 7, 3, 9].RangeOf([4, 0, 1]) =&gt; (-1, -1)<br />template&lt;typename T&gt; range rangeOf(const T* const _array, int _length, const T* const _set, int _length_)</p>
<p># - the first two elements returned by this function are meta-markers<br /> - the elements between (the first two) and (the last four) elements represent (a sequence of pointer pairs where each pair<br /> is representing either (an empty sequence) or (non-empty sequence)); an empty sequence is indicated by (array[1], array[0])<br /> and non-empty sequence is indicated by (&lt;begin-pointer&gt;, &lt;end-pointer&gt;)<br /> - the last four elements indicate the end of the pointer array; the value of the sequence is (array[0], array[1], array[0], array[1]) #<br /># returns only values that are (between the beginning and a separator), (between separator and the end) or (between two separators)<br /># empty sequences are generated (and eventually are appended to the result) only if they are between two separators<br /># _length specifies the length of _array<br /># _ignoreEmptyValues = true -&gt; empty sequences (if there are any) are not appended to the result<br /># split([3, 7, 18, 5, 19, 76, 15], 7, 353) =&gt; []<br /># split([18, 5, 19, 76, 15, 9, 20, 5], 8, 9) =&gt; [[18, 5, 19, 76, 15], [20, 5]]<br /># split([56, 3, 7, 18, 5, 19, 76, 7], 8, 7) =&gt; [[56, 3], [18, 5, 19, 76]]<br /># split([56, 7, 7, 18, 5, 19, 76, 15, 9], 9, 7) =&gt; [[56], [], [18, 5, 19, 76, 15, 9]]<br /># split([56, 7, 7, 18, 5, 19, 76, 15, 9], 9, 7) =&gt; [[56], [18, 5, 19, 76, 15, 9]]<br /># split([7, 41, 56, 7, 18, 76, 15, 9, 7], 9,7 ) =&gt; [[41, 56], [18, 76, 15, 9]]<br /># split([7, 41, 56, 7, 7, 7, 18, 5, 15], 9, 7) =&gt; [[41, 56], [], [], [18, 5, 15]]<br /># split([7, 41, 56, 7, 7, 7, 18, 5, 15], 9, 7, true) =&gt; [[41, 56], [18, 5, 15]]<br />template&lt;typename T&gt; T** split(T* const _array, int _length, T _separator, bool _ignoreEmptyValues = false)</p>
<p># _length specifies the length of _array<br />template&lt;typename T&gt; array where(const T* const _array, int _length, const std::function&lt;bool(T)&gt;&amp; _predicate)</p>
<p># MUTATION FUNCTIONS:</p>
<p># it copies segment (from _source to _destination) (beginning at _sourceBegin) and (with length specified by _length)<br /># copy("variance", "namespace", 8, 9, 2, 4, 5) &gt;&gt; "namerianc"<br /># copy("variance", "namespace", 8, 9, 2, 7, 5) &gt;&gt; "namespari"<br /># copy("variance", "namespace", 8, 9, 6, 2, 5) &gt;&gt; "nacespace"<br />template&lt;typename T&gt; void copy(const T* const _source, T* const _destination, int _sourceLength, int _destinationLength, int _sourceBegin,<br /> int _destinationBegin, int _copyLength)</p>
<p># it copies segment (from _source to _destination) (beginning at_sourceBegin and ending at _sourceEnd)<br /># copyRange("variance", "namespace", 8, 9, 2, 4, 5) &gt;&gt; "namesriae"<br /># copyRange("variance", "namespace", 8, 9, 5, 5, 3) &gt;&gt; "namespace"<br /># copyRange("variance", "namespace", 8, 9, 5, 7, 8) &gt;&gt; "namespacn"<br />template&lt;typename T&gt; void copyRange(const T* const _source, T* const _destination, int _sourceLength, int _destinationLength,<br />int _sourceBegin, int _sourceEnd, int _destinationBegin)</p>
<p># _length specifies the length of _array<br /># extendLeft([1, 2, 3, 4, 5], 5, 2) &gt;&gt; [x, x, 1, 2, 3, 4, 5]<br />template&lt;typename T&gt; void extendLeft(T*&amp; _array, int _extensor)</p>
<p># _length specifies the length of _array<br /># extendRight([1, 2, 3, 4, 5], 5, 2) &gt;&gt; [1, 2, 3, 4, 5, x, x]<br />template&lt;typename T&gt; void extendRight(T*&amp; _array, int _extensor)</p>
<p># _length specifies the length of _array<br /># reduceLeft([1, 2, 3, 4, 5], 5, 2) &gt;&gt; [3, 4, 5]<br />template&lt;typename T&gt; void reduceLeft(T*&amp; _array, int _length, int _reducer)</p>
<p># _length specifies the length of _array<br /># reduceRight([1, 2, 3, 4, 5], 5, 2) &gt;&gt; [1, 2, 3]<br />template&lt;typename T&gt; void reduceRight(T*&amp; _array, int _length, int _reducer)</p>
<p># _length specifies the length of _array<br /># remove([5, 8, 1, 9, 2, 4, 7], 7, 2, 3) &gt;&gt; [5, 8, 4, 7]<br /># remove([5, 8, 1, 9, 2, 4, 7], 7, 5, 3) &gt;&gt; [5, 8, 1, 9, 2]<br />template&lt;typename T&gt; void remove(T*&amp; _array, int _length, int _begin, int _reducer)</p>
<p># _length specifies the length of _array<br />template&lt;typename T&gt; void removeRange(chTar*&amp; _array, int _length, int _begin, int _end)</p>
<p># T = built-in integral type -&gt;<br />template&lt;typename T&gt; void resize(T*&amp; _array, int _currentLength, int _newLength)</p>
<p># _length specifies the length of _array<br />template&lt;typename T&gt; void reverse(T*&amp; _array, int _length)</p>
<p># _length specifies the length of _array<br /># rotateLeft([1, 2, 3, 4, 5], 5, 5) &gt;&gt; [4, 5, 1, 2, 3]<br />void rotateLeft(T*&amp; _array, int _length, int _positions)</p>
<p># _length specifies the length of _array<br /># rotateRight([1, 2, 3, 4, 5], 5, 4) &gt;&gt; [5, 1, 2, 3, 4]<br />template&lt;typename T&gt; void rotateRight(T*&amp; _array, int _length, int _positions)</p>
<p># _length specifies the length of _array<br /># set([1, 2, 3, 4, 5], 5, 2, 4, 19) &gt;&gt; [1, 2, 19, 19, 19]<br />template&lt;typename T&gt; void set(T*&amp; _array, int _length, int _begin, int _end, T _value)</p>
<p># _length specifies the length of _array<br />template&lt;typename T&gt; void swap(T*&amp; _array, int _length, int _i1, int _i2)</p>
<p># _length specifies the length of _array<br />template&lt;typename T&gt; void trimBegin(T*&amp; _array, int _length, T _value)</p>
<p># _length specifies the length of _array<br />template&lt;typename T&gt; void trimEnd(T*&amp; _array, int _length, T _value)</p>
<p>-----------------------------------------------------------------------------------------</p>
<p id="pair" style="color:rgb(100, 100, 255);"><b>pair.cpp:</b></p>
<p>struct&lt;K, V&gt; pair:</p>
<p># CONSTRUCTORS:</p>
<p>pair() = default</p>
<p>pair(const K&amp; _key, const V&amp; _value)</p>
<p>pair(const pair&lt;K, V&gt;&amp;) = default</p>
<p># OPERATORS:</p>
<p>pair &amp;operator=(const pair&lt;K, V&gt;&amp;) = default</p>
<p>bool operator==(const pair&lt;K, V&gt;&amp;) const</p>
<p>bool operator!=(const pair&lt;K, V&gt;&amp;) const</p>
<p># FIELDS:</p>
<p>const K&amp; key() const</p>
<p>const V&amp; value() const</p>
<p>-----------------------------------------------------------------------------------------</p>
<p id="tuple" style="color:rgb(100, 100, 255);"><b>tuple.cpp:</b></p>
<p>struct&lt;T1, T2&gt; t2:</p>
<p># CONSTRUCTORS:</p>
<p>t2() = default</p>
<p>t2(const T1&amp; _e1, const T2&amp; _e2)</p>
<p>t2(const t2&amp;) = default</p>
<p># OPERATORS:</p>
<p>t2&amp; operator=(const t2&amp;) = default</p>
<p>bool operator==(const t2&amp;) const</p>
<p>bool operator!=(const t2&amp;) const</p>
<p># FIELDS:</p>
<p>const T1&amp; e1() const</p>
<p>const T2&amp; e2() const</p>
<p>struct&lt;T1, T2, T3&gt; t3:</p>
<p># CONSTRUCTORS:</p>
<p>t3() = default</p>
<p>t3(const T1&amp; _e1, const T2&amp; _e2, const T3&amp; _e3)</p>
<p>t3(const t3&amp;) = default</p>
<p># OPERATORS:</p>
<p>t3&amp; operator=(const t3&amp;) = default</p>
<p>bool operator==(const t3&amp;) const</p>
<p>bool operator!=(const t3&amp;) const</p>
<p># FIELDS:</p>
<p>const T1&amp; e1() const</p>
<p>const T2&amp; e2() const</p>
<p>const T2&amp; e3() const</p>
<p>struct&lt;T1, T2, T3, T4&gt; t4:</p>
<p># CONSTRUCTORS:</p>
<p>t4() = default</p>
<p>t4(const T1&amp; _e1, const T2&amp; _e2, const T3&amp; _e3, const T4&amp; _e4)</p>
<p>t4(const t4&amp;) = default</p>
<p># OPERATORS:</p>
<p>t4&amp; operator=(const t4&amp;) = default</p>
<p>bool operator==(const t4&amp;) const</p>
<p>bool operator!=(const t4&amp;) const</p>
<p># FIELDS:</p>
<p>const T1&amp; e1() const</p>
<p>const T2&amp; e2() const</p>
<p>const T3&amp; e3() const</p>
<p>const T4&amp; e4() const</p>
<p>struct&lt;T1, T2, T3, T4, T5&gt; t5:</p>
<p># CONSTRUCTORS:</p>
<p>t5() = default</p>
<p>t5(const T1&amp; _e1, const T2&amp; _e2, const T3&amp; _e3, const T4&amp; _e4, const T5&amp; _e5)</p>
<p>t5(const t5&amp;) = default</p>
<p># OPERATORS:</p>
<p>t5&amp; operator=(const t5&amp;) = default</p>
<p>bool operator==(const t5&amp;) const</p>
<p>bool operator!=(const t5&amp;) const</p>
<p># FIELDS:</p>
<p>const T1&amp; e1() const</p>
<p>const T2&amp; e2() const</p>
<p>const T3&amp; e3() const</p>
<p>const T4&amp; e4() const</p>
<p>const T5&amp; e5() const</p>
<p>struct&lt;T1, T2, T3, T4, T5, T6&gt; t6:</p>
<p># CONSTRUCTORS:</p>
<p>t6() = default</p>
<p>t6(const T1&amp; _e1, const T2&amp; _e2, const T3&amp; _e3, const T4&amp; _e4, const T5&amp; _e5, const T6&amp; _e6)</p>
<p>t6(const t6&amp;) = default</p>
<p># OPERATORS:</p>
<p>t6&amp; operator=(const t6&amp;) = default</p>
<p>bool operator==(const t6&amp;) const</p>
<p>bool operator!=(const t6&amp;) const</p>
<p># FIELDS:</p>
<p>const T1&amp; e1() const</p>
<p>const T2&amp; e2() const</p>
<p>const T3&amp; e3() const</p>
<p>const T4&amp; e4() const</p>
<p>const T5&amp; e5() const</p>
<p>const T6&amp; e6() const</p>
<p>struct&lt;T1, T2, T3, T4, T5, T6, T7&gt; t7:</p>
<p># CONSTRUCTORS:</p>
<p>t7() = default</p>
<p>t7(const T1&amp; _e1, const T2&amp; _e2, const T3&amp; _e3, const T4&amp; _e4, const T5&amp; _e5, const T6&amp; _e6, const T7&amp; _e7)</p>
<p>t7(const t7&amp;) = default</p>
<p># OPERATORS:</p>
<p>t7&amp; operator=(const t7&amp;) = default</p>
<p>bool operator==(const t7&amp;) const</p>
<p>bool operator!=(const t7&amp;) const</p>
<p># FIELDS:</p>
<p>const T1&amp; e1() const</p>
<p>const T2&amp; e2() const</p>
<p>const T3&amp; e3() const</p>
<p>const T4&amp; e4() const</p>
<p>const T5&amp; e5() const</p>
<p>const T6&amp; e6() const</p>
<p>const T7&amp; e7() const</p>
<p>struct&lt;T1, T2, T3, T4, T5, T6, T7, T8&gt; t8:</p>
<p># CONSTRUCTORS:</p>
<p>t8() = default</p>
<p>t8(const T1&amp; _e1, const T2&amp; _e2, const T3&amp; _e3, const T4&amp; _e4, const T5&amp; _e5, const T6&amp; _e6, const T7&amp; _e7, const T8&amp; _e8)</p>
<p>t8(const t8&amp;) = default</p>
<p># OPERATORS:</p>
<p>t8&amp; operator=(const t8&amp;) = default</p>
<p>bool operator==(const t8&amp;) const</p>
<p>bool operator!=(const t8&amp;) const</p>
<p># FIELDS:</p>
<p>const T1&amp; e1() const</p>
<p>const T2&amp; e2() const</p>
<p>const T3&amp; e3() const</p>
<p>const T4&amp; e4() const</p>
<p>const T5&amp; e5() const</p>
<p>const T6&amp; e6() const</p>
<p>const T7&amp; e7() const</p>
<p>const T8&amp; e8() const</p>
<p>struct&lt;T1, T2, T3, T4, T5, T6, T7, T8, T9&gt; t9:</p>
<p># CONSTRUCTORS:</p>
<p>t9() = default</p>
<p>t9(const T1&amp; _e1, const T2&amp; _e2, const T3&amp; _e3, const T4&amp; _e4, const T5&amp; _e5, const T6&amp; _e6, const T7&amp; _e7, const T8&amp; _e8, const T9&amp; _e9)</p>
<p>t9(const t9&amp;) = default</p>
<p># OPERATORS:</p>
<p>t9&amp; operator=(const t9&amp;) = default</p>
<p>bool operator==(const t9&amp;) const</p>
<p>bool operator!=(const t9&amp;) const</p>
<p># FIELDS:</p>
<p>const T1&amp; e1() const</p>
<p>const T2&amp; e2() const</p>
<p>const T3&amp; e3() const</p>
<p>const T4&amp; e4() const</p>
<p>const T5&amp; e5() const</p>
<p>const T6&amp; e6() const</p>
<p>const T7&amp; e7() const</p>
<p>const T8&amp; e8() const</p>
<p>const T9&amp; e9() const</p>
<p>struct&lt;T1, T2, T3, T4, T5, T6, T7, T8, T9, T10&gt; t10:</p>
<p># CONSTRUCTORS:</p>
<p>t10() = default</p>
<p>t10(const T1&amp; _e1, const T2&amp; _e2, const T3&amp; _e3, const T4&amp; _e4, const T5&amp; _e5, const T6&amp; _e6, const T7&amp; _e7, const T8&amp; _e8, const T9&amp; _e9, const T10&amp; e_10)</p>
<p>t10(const t10&amp;) = default</p>
<p># OPERATORS:</p>
<p>t10&amp; operator=(const t10&amp;) = default</p>
<p>bool operator==(const t10&amp;) const</p>
<p>bool operator!=(const t10&amp;) const</p>
<p># FIELDS:</p>
<p>const T1&amp; e1() const</p>
<p>const T2&amp; e2() const</p>
<p>const T3&amp; e3() const</p>
<p>const T4&amp; e4() const</p>
<p>const T5&amp; e5() const</p>
<p>const T6&amp; e6() const</p>
<p>const T7&amp; e7() const</p>
<p>const T8&amp; e8() const</p>
<p>const T9&amp; e9() const</p>
<p>const T10&amp; e10() const</p>
<p>struct&lt;T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11&gt; t11:</p>
<p># CONSTRUCTORS:</p>
<p>t11() = default</p>
<p>t11(const T1&amp; _e1, const T2&amp; _e2, const T3&amp; _e3, const T4&amp; _e4, const T5&amp; _e5, const T6&amp; _e6, const T7&amp; _e7, const T8&amp; _e8, const T9&amp; _e9, const T10&amp; e_10,<br /> const T11&amp; _e11)</p>
<p>t11(const t11&amp;) = default</p>
<p># OPERATORS:</p>
<p>t11&amp; operator=(const t11&amp;) = default</p>
<p>bool operator==(const t11&amp;) const</p>
<p>bool operator!=(const t11&amp;) const</p>
<p># FIELDS:</p>
<p>const T1&amp; e1() const</p>
<p>const T2&amp; e2() const</p>
<p>const T3&amp; e3() const</p>
<p>const T4&amp; e4() const</p>
<p>const T5&amp; e5() const</p>
<p>const T6&amp; e6() const</p>
<p>const T7&amp; e7() const</p>
<p>const T8&amp; e8() const</p>
<p>const T9&amp; e9() const</p>
<p>const T10&amp; e10() const</p>
<p>const T11&amp; e11() const</p>
<p>struct&lt;T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12&gt; t12:</p>
<p># CONSTRUCTORS:</p>
<p>t12() = default</p>
<p>t12(const T1&amp; _e1, const T2&amp; _e2, const T3&amp; _e3, const T4&amp; _e4, const T5&amp; _e5, const T6&amp; _e6, const T7&amp; _e7, const T8&amp; _e8, const T9&amp; _e9, const T10&amp; e_10,<br /> const T11&amp; _e11, const T12&amp; _e12)</p>
<p>t12(const t12&amp;) = default</p>
<p># OPERATORS:</p>
<p>t12&amp; operator=(const t12&amp;) = default</p>
<p>bool operator==(const t12&amp;) const</p>
<p>bool operator!=(const t12&amp;) const</p>
<p># FIELDS:</p>
<p>const T1&amp; e1() const</p>
<p>const T2&amp; e2() const</p>
<p>const T3&amp; e3() const</p>
<p>const T4&amp; e4() const</p>
<p>const T5&amp; e5() const</p>
<p>const T6&amp; e6() const</p>
<p>const T7&amp; e7() const</p>
<p>const T8&amp; e8() const</p>
<p>const T9&amp; e9() const</p>
<p>const T10&amp; e10() const</p>
<p>const T11&amp; e11() const</p>
<p>const T12&amp; e12() const</p>
<p>struct&lt;T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13&gt; t13:</p>
<p># CONSTRUCTORS:</p>
<p>t13() = default</p>
<p>t13(const T1&amp; _e1, const T2&amp; _e2, const T3&amp; _e3, const T4&amp; _e4, const T5&amp; _e5, const T6&amp; _e6, const T7&amp; _e7, const T8&amp; _e8, const T9&amp; _e9, const T10&amp; e_10,<br /> const T11&amp; _e11, const T12&amp; _e12, const T13&amp; _e13)</p>
<p>t13(const t13&amp;) = default</p>
<p># OPERATORS:</p>
<p>t13&amp; operator=(const t13&amp;) = default</p>
<p>bool operator==(const t13&amp;) const</p>
<p>bool operator!=(const t13&amp;) const</p>
<p># FIELDS:</p>
<p>const T1&amp; e1() const</p>
<p>const T2&amp; e2() const</p>
<p>const T3&amp; e3() const</p>
<p>const T4&amp; e4() const</p>
<p>const T5&amp; e5() const</p>
<p>const T6&amp; e6() const</p>
<p>const T7&amp; e7() const</p>
<p>const T8&amp; e8() const</p>
<p>const T9&amp; e9() const</p>
<p>const T10&amp; e10() const</p>
<p>const T11&amp; e11() const</p>
<p>const T12&amp; e12() const</p>
<p>const T13&amp; e13() const</p>
<p>struct&lt;T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14&gt; t14:</p>
<p># CONSTRUCTORS:</p>
<p>t14() = default</p>
<p>t14(const T1&amp; _e1, const T2&amp; _e2, const T3&amp; _e3, const T4&amp; _e4, const T5&amp; _e5, const T6&amp; _e6, const T7&amp; _e7, const T8&amp; _e8, const T9&amp; _e9, const T10&amp; e_10,<br /> const T11&amp; _e11, const T12&amp; _e12, const T13&amp; _e13, const T14&amp; _e14)</p>
<p>t14(const t14&amp;) = default</p>
<p># OPERATORS:</p>
<p>t14&amp; operator=(const t14&amp;) = default</p>
<p>bool operator==(const t14&amp;) const</p>
<p>bool operator!=(const t14&amp;) const</p>
<p># FIELDS:</p>
<p>const T1&amp; e1() const</p>
<p>const T2&amp; e2() const</p>
<p>const T3&amp; e3() const</p>
<p>const T4&amp; e4() const</p>
<p>const T5&amp; e5() const</p>
<p>const T6&amp; e6() const</p>
<p>const T7&amp; e7() const</p>
<p>const T8&amp; e8() const</p>
<p>const T9&amp; e9() const</p>
<p>const T10&amp; e10() const</p>
<p>const T11&amp; e11() const</p>
<p>const T12&amp; e12() const</p>
<p>const T13&amp; e13() const</p>
<p>const T14&amp; e14() const</p>
<p>struct&lt;T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15&gt; t15:</p>
<p># CONSTRUCTORS:</p>
<p>t15() = default</p>
<p>t15(const T1&amp; _e1, const T2&amp; _e2, const T3&amp; _e3, const T4&amp; _e4, const T5&amp; _e5, const T6&amp; _e6, const T7&amp; _e7, const T8&amp; _e8, const T9&amp; _e9, const T10&amp; e_10,<br /> const T11&amp; _e11, const T12&amp; _e12, const T13&amp; _e13, const T14&amp; _e14, const T15&amp; _e15)</p>
<p>t15(const t15&amp;) = default</p>
<p># OPERATORS:</p>
<p>t15&amp; operator=(const t15&amp;) = default</p>
<p>bool operator==(const t15&amp;) const</p>
<p>bool operator!=(const t15&amp;) const</p>
<p># FIELDS:</p>
<p>const T1&amp; e1() const</p>
<p>const T2&amp; e2() const</p>
<p>const T3&amp; e3() const</p>
<p>const T4&amp; e4() const</p>
<p>const T5&amp; e5() const</p>
<p>const T6&amp; e6() const</p>
<p>const T7&amp; e7() const</p>
<p>const T8&amp; e8() const</p>
<p>const T9&amp; e9() const</p>
<p>const T10&amp; e10() const</p>
<p>const T11&amp; e11() const</p>
<p>const T12&amp; e12() const</p>
<p>const T13&amp; e13() const</p>
<p>const T14&amp; e14() const</p>
<p>const T15&amp; e15() const</p>
<p>struct&lt;T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16&gt; t16:</p>
<p># CONSTRUCTORS:</p>
<p>t16() = default</p>
<p>t16(const T1&amp; _e1, const T2&amp; _e2, const T3&amp; _e3, const T4&amp; _e4, const T5&amp; _e5, const T6&amp; _e6, const T7&amp; _e7, const T8&amp; _e8, const T9&amp; _e9, const T10&amp; e_10,<br /> const T11&amp; _e11, const T12&amp; _e12, const T13&amp; _e13, const T14&amp; _e14, const T15&amp; _e15, const T16&amp; _e16)</p>
<p>t16(const t16&amp;) = default</p>
<p># OPERATORS:</p>
<p>t16&amp; operator=(const t16&amp;) = default</p>
<p>bool operator==(const t16&amp;) const</p>
<p>bool operator!=(const t16&amp;) const</p>
<p># FIELDS:</p>
<p>const T1&amp; e1() const</p>
<p>const T2&amp; e2() const</p>
<p>const T3&amp; e3() const</p>
<p>const T4&amp; e4() const</p>
<p>const T5&amp; e5() const</p>
<p>const T6&amp; e6() const</p>
<p>const T7&amp; e7() const</p>
<p>const T8&amp; e8() const</p>
<p>const T9&amp; e9() const</p>
<p>const T10&amp; e10() const</p>
<p>const T11&amp; e11() const</p>
<p>const T12&amp; e12() const</p>
<p>const T13&amp; e13() const</p>
<p>const T14&amp; e14() const</p>
<p>const T15&amp; e15() const</p>
<p>const T16&amp; e16() const</p>
<p>struct&lt;T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16&gt; t16:</p>
<p># CONSTRUCTORS:</p>
<p>t16() = default</p>
<p>t16(const T1&amp; _e1, const T2&amp; _e2, const T3&amp; _e3, const T4&amp; _e4, const T5&amp; _e5, const T6&amp; _e6, const T7&amp; _e7, const T8&amp; _e8, const T9&amp; _e9, const T10&amp; e_10,<br /> const T11&amp; _e11, const T12&amp; _e12, const T13&amp; _e13, const T14&amp; _e14, const T15&amp; _e15, const T16&amp; _e16)</p>
<p>t16(const t16&amp;) = default</p>
<p># OPERATORS:</p>
<p>t16&amp; operator=(const t16&amp;) = default</p>
<p>bool operator==(const t16&amp;) const</p>
<p>bool operator!=(const t16&amp;) const</p>
<p># FIELDS:</p>
<p>const T1&amp; e1() const</p>
<p>const T2&amp; e2() const</p>
<p>const T3&amp; e3() const</p>
<p>const T4&amp; e4() const</p>
<p>const T5&amp; e5() const</p>
<p>const T6&amp; e6() const</p>
<p>const T7&amp; e7() const</p>
<p>const T8&amp; e8() const</p>
<p>const T9&amp; e9() const</p>
<p>const T10&amp; e10() const</p>
<p>const T11&amp; e11() const</p>
<p>const T12&amp; e12() const</p>
<p>const T13&amp; e13() const</p>
<p>const T14&amp; e14() const</p>
<p>const T15&amp; e15() const</p>
<p>const T16&amp; e16() const</p>
<p>struct&lt;T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17&gt; t17:</p>
<p># CONSTRUCTORS:</p>
<p>t17() = default</p>
<p>t17(const T1&amp; _e1, const T2&amp; _e2, const T3&amp; _e3, const T4&amp; _e4, const T5&amp; _e5, const T6&amp; _e6, const T7&amp; _e7, const T8&amp; _e8, const T9&amp; _e9, const T10&amp; e_10,<br /> const T11&amp; _e11, const T12&amp; _e12, const T13&amp; _e13, const T14&amp; _e14, const T15&amp; _e15, const T16&amp; _e16, const T17&amp; _e17)</p>
<p>t17(const t17&amp;) = default</p>
<p># OPERATORS:</p>
<p>t17&amp; operator=(const t17&amp;) = default</p>
<p>bool operator==(const t17&amp;) const</p>
<p>bool operator!=(const t17&amp;) const</p>
<p># FIELDS:</p>
<p>const T1&amp; e1() const</p>
<p>const T2&amp; e2() const</p>
<p>const T3&amp; e3() const</p>
<p>const T4&amp; e4() const</p>
<p>const T5&amp; e5() const</p>
<p>const T6&amp; e6() const</p>
<p>const T7&amp; e7() const</p>
<p>const T8&amp; e8() const</p>
<p>const T9&amp; e9() const</p>
<p>const T10&amp; e10() const</p>
<p>const T11&amp; e11() const</p>
<p>const T12&amp; e12() const</p>
<p>const T13&amp; e13() const</p>
<p>const T14&amp; e14() const</p>
<p>const T15&amp; e15() const</p>
<p>const T16&amp; e16() const</p>
<p>const T17&amp; e17() const</p>
<p>struct&lt;T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18&gt; t18:</p>
<p># CONSTRUCTORS:</p>
<p>t18() = default</p>
<p>t18(const T1&amp; _e1, const T2&amp; _e2, const T3&amp; _e3, const T4&amp; _e4, const T5&amp; _e5, const T6&amp; _e6, const T7&amp; _e7, const T8&amp; _e8, const T9&amp; _e9, const T10&amp; e_10,<br /> const T11&amp; _e11, const T12&amp; _e12, const T13&amp; _e13, const T14&amp; _e14, const T15&amp; _e15, const T16&amp; _e16, const T17&amp; _e17, const T18&amp; _e18)</p>
<p>t18(const t18&amp;) = default</p>
<p># OPERATORS:</p>
<p>t18&amp; operator=(const t18&amp;) = default</p>
<p>bool operator==(const t18&amp;) const</p>
<p>bool operator!=(const t18&amp;) const</p>
<p># FIELDS:</p>
<p>const T1&amp; e1() const</p>
<p>const T2&amp; e2() const</p>
<p>const T3&amp; e3() const</p>
<p>const T4&amp; e4() const</p>
<p>const T5&amp; e5() const</p>
<p>const T6&amp; e6() const</p>
<p>const T7&amp; e7() const</p>
<p>const T8&amp; e8() const</p>
<p>const T9&amp; e9() const</p>
<p>const T10&amp; e10() const</p>
<p>const T11&amp; e11() const</p>
<p>const T12&amp; e12() const</p>
<p>const T13&amp; e13() const</p>
<p>const T14&amp; e14() const</p>
<p>const T15&amp; e15() const</p>
<p>const T16&amp; e16() const</p>
<p>const T17&amp; e17() const</p>
<p>const T18&amp; e18() const</p>
<p>struct&lt;T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19&gt; t19:</p>
<p># CONSTRUCTORS:</p>
<p>t19() = default</p>
<p>t19(const T1&amp; _e1, const T2&amp; _e2, const T3&amp; _e3, const T4&amp; _e4, const T5&amp; _e5, const T6&amp; _e6, const T7&amp; _e7, const T8&amp; _e8, const T9&amp; _e9, const T10&amp; e_10,<br /> const T11&amp; _e11, const T12&amp; _e12, const T13&amp; _e13, const T14&amp; _e14, const T15&amp; _e15, const T16&amp; _e16, const T17&amp; _e17, const T18&amp; _e18, const T19&amp; _e19)</p>
<p>t19(const t19&amp;) = default</p>
<p># OPERATORS:</p>
<p>t19&amp; operator=(const t19&amp;) = default</p>
<p>bool operator==(const t19&amp;) const</p>
<p>bool operator!=(const t19&amp;) const</p>
<p># FIELDS:</p>
<p>const T1&amp; e1() const</p>
<p>const T2&amp; e2() const</p>
<p>const T3&amp; e3() const</p>
<p>const T4&amp; e4() const</p>
<p>const T5&amp; e5() const</p>
<p>const T6&amp; e6() const</p>
<p>const T7&amp; e7() const</p>
<p>const T8&amp; e8() const</p>
<p>const T9&amp; e9() const</p>
<p>const T10&amp; e10() const</p>
<p>const T11&amp; e11() const</p>
<p>const T12&amp; e12() const</p>
<p>const T13&amp; e13() const</p>
<p>const T14&amp; e14() const</p>
<p>const T15&amp; e15() const</p>
<p>const T16&amp; e16() const</p>
<p>const T17&amp; e17() const</p>
<p>const T18&amp; e18() const</p>
<p>const T19&amp; e19() const</p>
<p>struct&lt;T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20&gt; t20:</p>
<p># CONSTRUCTORS:</p>
<p>t20() = default</p>
<p>t20(const T1&amp; _e1, const T2&amp; _e2, const T3&amp; _e3, const T4&amp; _e4, const T5&amp; _e5, const T6&amp; _e6, const T7&amp; _e7, const T8&amp; _e8, const T9&amp; _e9, const T10&amp; e_10,<br /> const T11&amp; _e11, const T12&amp; _e12, const T13&amp; _e13, const T14&amp; _e14, const T15&amp; _e15, const T16&amp; _e16, const T17&amp; _e17, const T18&amp; _e18, const T19&amp; _e19, const T20&amp; _e20)</p>
<p>t20(const t20&amp;) = default</p>
<p># OPERATORS:</p>
<p>t20&amp; operator=(const t20&amp;) = default</p>
<p>bool operator==(const t20&amp;) const</p>
<p>bool operator!=(const t20&amp;) const</p>
<p># FIELDS:</p>
<p>const T1&amp; e1() const</p>
<p>const T2&amp; e2() const</p>
<p>const T3&amp; e3() const</p>
<p>const T4&amp; e4() const</p>
<p>const T5&amp; e5() const</p>
<p>const T6&amp; e6() const</p>
<p>const T7&amp; e7() const</p>
<p>const T8&amp; e8() const</p>
<p>const T9&amp; e9() const</p>
<p>const T10&amp; e10() const</p>
<p>const T11&amp; e11() const</p>
<p>const T12&amp; e12() const</p>
<p>const T13&amp; e13() const</p>
<p>const T14&amp; e14() const</p>
<p>const T15&amp; e15() const</p>
<p>const T16&amp; e16() const</p>
<p>const T17&amp; e17() const</p>
<p>const T18&amp; e18() const</p>
<p>const T19&amp; e19() const</p>
<p>const T20&amp; e20() const</p>
<p>-----------------------------------------------------------------------------------------</p>
<p id="range" style="color:rgb(100, 100, 255);"><b>range.cpp:</b></p>
<p># &lt;T&gt; is built-in integral type<br />struct Range&lt;T&gt;:</p>
<p># CONSTRUCTORS:</p>
<p>Range()</p>
<p># _end &gt;= _begin -&gt;<br /> Range(T _begin, T _end)</p>
<p>Range(const Range&amp;)</p>
<p># OPERATORS:</p>
<p>Range&amp; operator=(const Range&amp;)</p>
<p>bool operator==(const Range&amp;)</p>
<p>bool operator!=(const Range&amp;)</p>
<p># determines if the beginning of &amp;this is before the beginning of _range<br /> # Range(29, 38) &lt; Range(27, 35) =&gt; false<br /> # Range(29, 38) &lt; Range(29, 35) =&gt; false<br /> # Range(29, 38) &lt; Range(30, 35) =&gt; true<br /> bool operator&lt;(const Range&amp;)</p>
<p># determines if the beginning of &amp;this is after the beginning of _range<br /> # Range(29, 38) &gt; Range(29, 35) =&gt; false<br /> # Range(29, 38) &gt; Range(30, 35) =&gt; false<br /> # Range(29, 38) &gt; Range(27, 35) =&gt; true<br /> bool operator&gt;(const Range&amp;)</p>
<p># generates new range with beginning (the beginning of &amp;this) and end (the end of _range)<br /> # the two ranges must be neighboring<br /> # if the two ranges are not neighboring the function returns {}<br /> # Range(22, 40) &amp; Range(41, 53) =&gt; (22, 53)<br /> # Range(41, 53) &amp; Range(22, 40) =&gt; (22, 53)<br /> Range operator&amp;(Range&amp;)</p>
<p># FIELDS:</p>
<p>int begin()</p>
<p>int end()</p>
<p>int length()</p>
<p>Functions:</p>
<p>bool IsSet()</p>
<p># Range(21, 30).IsAdjacentTo(Range(32, 37)) =&gt; false<br /> # Range(21, 30).IsAdjacentTo(Range(31, 37)) =&gt; true<br /> # Range(31, 37).IsAdjacentTo(Range(21, 30)) =&gt; true<br /> bool IsAdjacentTo(const Range&amp;)</p>
<p># Range(21, 30).IsBefore(Range(30, 35)) =&gt; false<br /> # Range(21, 30).IsBefore(Range(31, 37)) =&gt; true<br /> # Range(21, 30).IsBefore(Range(35, 37)) =&gt; true<br /> bool IsBefore(const Range&amp;)</p>
<p># Range(30, 35).IsAfter(Range(21, 30)) =&gt; false<br /> # Range(33, 37).IsAfter(Range(21, 30)) =&gt; true<br /> bool IsAfter(const Range)</p>
<p># Range(21, 30).IsRightBefore(Range(32, 35)) =&gt; false<br /> # Range(21, 30).IsRightBefore(Range(31, 35)) =&gt; true<br /> bool IsRightBefore(const Range&amp;)</p>
<p># Range(32, 35).IsRightAfter(Range(21, 30)) =&gt; false<br /> # Range(31, 35).IsRightAfter(Range(21, 30)) =&gt; true<br /> bool IsRightAfter(const Range&amp;)</p>
<p># Range(21, 30).AlignWith(Range(21, 50)) =&gt; true<br /> # Range(21, 30).AlignWith(Range(22, 50)) =&gt; false<br /> bool AlignWith(const Range&amp;)</p>
<p># Range(76, 81).Contains(82) =&gt; false<br /> # Range(76, 81).Contains(81) =&gt; true<br /> bool Contains(const T&amp;)</p>
<p># Range(73, 90).Contains(Range(78, 91)) =&gt; false<br /> # Range(73, 90).Contains(Range(78, 90)) =&gt; true<br /> bool Contains(const Range&amp;)</p>
<p># Range(73, 90).Intersects(Range(78, 90)) =&gt; false<br /> # Range(73, 90).Intersects(Range(78, 92)) =&gt; true<br /> bool Intersects(const Range&amp;)</p>
<p># DisplacementOf(Range(23, 30), Range(35, 40)) =&gt; 12<br /> # DisplacementOf(Range(23, 30), Range(14, 40)) =&gt; 9<br /> # DisplacementOf(Range(-5, 8), Range(20, 23)) =&gt; 25<br /> # DisplacementOf(Range(-119, -108), Range(-105, 92)) =&gt; 14<br /> template&lt;typename T&gt; int DisplacementOf(const Range&lt;T&gt;&amp;, const Range&lt;T&gt;&amp;)</p>
<p># IntervalOf(Range(23, 30), Range(35, 40)) =&gt; 4<br /> # IntervalOf(Range(35, 40), Range(23, 30)) =&gt; 4<br /> # IntervalOf(Range(-5, 8), Range(20, 23)) =&gt; 11<br /> # IntervalOf(Range(-119, -108), Range(-105, 92)) =&gt; 2<br /> template&lt;typename T&gt; int IntervalOf(const Range&lt;T&gt;&amp;, const Range&lt;T&gt;&amp;)</p>
<p>-----------------------------------------------------------------------------------------</p>
<p id="list" style="color:rgb(100, 100, 255);"><b>list.cpp:</b></p>
<p># TYPES:</p>
<p># this type determines what happens (when an instance of a sequence type is traversed) and these four scenarios happen:<br /> - the current traversal position is 0 and either previous() or back() is used; if the traversal mdoe is set to BOUNDED then (previous() returns the first element)<br /> and (back() does nothing)<br /> - the current traversal position is 0 and either previous() or back() is used; if the traversal mode is set to CIRCULAR then (previous() returns the last element) and<br /> (back() sets the current traversal position to a value that points to the last element)<br /> - the current traversal position is the position of the last element and either next() or advance() is used;<br /> if the traversal mode is set to BOUNDED then (next() returns the last element) and (advance() does nothing)<br /> - the current traversal position is the position of the last element and either next() or advance() is used;<br /> if the traversal mode is set to CIRCULAR then (next() returns the first element) and (advance() sets the current traversal position to a value<br /> that points to the first element) #<br />enum class TraversalMode = BOUNDED | CIRCULAR</p>
<p># when an instance of (a sequence type that uses ReleaseMode) is about to be destructed the elements (are freed automatically and immediately<br /> (when IMMEDIATE is used)) or (are stored for future use and are freed manually in a specific future moment (when FUTURE is used)) #<br />enum class ReleaseMode = IMMEDIATE | FUTURE</p>
<p># (!) the size(accessed by size()) of a segment is equal to the size of the list that the segment refers to<br />struct list&lt;T&gt;:</p>
<p># VARIABLES:</p>
<p>TraversalMode TraversalMode = TraversalMode::BOUNDED;</p>
<p># when an instance of this type is about to be destructed the elements (are freed automatically and immediately<br /> (when IMMEDIATE is used)) or (are stored for future use and are freed manually in a specific future moment (when FUTURE is used)) #<br /> ReleaseMode ReleaseMode</p>
<p># CONSTRUCTORS:</p>
<p>list()</p>
<p># _extendCount is needed in cases where the allocated slots must be treated as existing elements (without being added first through another operation);<br /> if that parameter is true then &amp;Count equals &amp;Size #<br /> explicit list(int _size, bool _extendCount)</p>
<p>list(const list&lt;T&gt;&amp;)</p>
<p>list(const std::initializer_list&lt;T&gt;&amp; _list)</p>
<p># it generates a segment<br /> list(const list&lt;T&gt;&amp; _source, int _begin, int _end)</p>
<p># it generates a segment<br /> list(const list&lt;T&gt;&amp; _source, const Range&lt;int&gt;&amp; _range)</p>
<p># it generates a segment<br /> list(const T* _source, int _elementsCount, int _begin, int _end)</p>
<p># it generates a segment<br /> list(const T* _source, int _elementsCount, const Range&lt;int&gt;&amp; _range)</p>
<p># OPERATORS:</p>
<p>bool operator==(const list&lt;T&gt;&amp;) const</p>
<p>bool operator!=(const list&lt;T&gt;&amp;) const</p>
<p># [5, 0, 9] == [[5, 1, 3], [5, 1, 9], [5, 0, 0]] =&gt; false<br /> # [5, 0, 9] == [[5, 1, 0], [5, 0, 9], [4, 3, 1]] =&gt; true<br /> bool operator==(const list&lt;list&lt;T&gt;&gt;&amp; _values) const</p>
<p># [5, 0, 9] == [[5, 1, 0], [5, 0, 9], [4, 3, 1]] =&gt; false<br /> # [5, 0, 9] == [[5, 1, 3], [5, 1, 9], [5, 0, 0]] =&gt; true<br /> bool operator!=(const list&lt;list&lt;T&gt;&gt;&amp; _values) const</p>
<p>list&lt;T&gt;&amp; operator=(const list&lt;T&gt;&amp;)</p>
<p>list&lt;T&gt; operator+(const T&amp;) const</p>
<p>list&lt;T&gt; operator+(const list&lt;T&gt;&amp;) const</p>
<p>list&lt;T&gt;&amp; operator+=(const T&amp;)</p>
<p>list&lt;T&gt;&amp; operator+=(const list&lt;T&gt;&amp;)</p>
<p># _index is in the range of list -&gt;<br /> T&amp; operator[](int)</p>
<p># _index is in the range of list -&gt;<br /> T&amp; operator[](int) const</p>
<p># FIELDS:</p>
<p>int count() const</p>
<p>int size() const</p>
<p>int position() const</p>
<p>T* elements()</p>
<p>const T* elements() const</p>
<p>#</p>
<p>bool IsSegment() const</p>
<p># TRAVERSAL FUNCTIONS</p>
<p>bool can_reverse() const</p>
<p>bool can_advance() const</p>
<p># traversalMode() == BOUNDED &amp;&amp; position() - _value &lt; 0 &gt;&gt; position() = position()<br /> # traversalMode() == BOUNDED &amp;&amp; position() - _value &gt; -1 &gt;&gt; position() = position() - _value<br /> # traversalMode() == CIRCULAR -&gt; circular addition; (EXAMPLE) count() = 19, position() = 4, back(9) &gt;&gt; position() = 14<br /> list&lt;T&gt;&amp; back(int _value)</p>
<p># traversalMode() == BOUNDED &amp;&amp; position() + _value &gt;= count() &gt;&gt; position() = position()<br /> # traversalMode() == BOUNDED &amp;&amp; position() + _value &lt; count() - 1 &gt;&gt; position() = position() + _value<br /> # traversalMode() == CIRCULAR -&gt; circular addition; (EXAMPLE) size() = 21, position() = 16, advance(10) &gt;&gt; position() = 5<br /> list&lt;T&gt;&amp; advance(int _value)</p>
<p># position() &gt; 0 =&gt; [position() - 1]<br /> # traversalMode() == BOUNDED &amp;&amp; position() == 0 =&gt; [0]<br /> # traversalMode() == CIRCULAR &amp;&amp; position() == 0 =&gt; [count() - 1]<br /> T&amp; previous() const</p>
<p># count() &gt; 0 -&gt;<br /> T&amp; current() const</p>
<p># position() &lt; count() - 1 =&gt; [position() + 1]<br /> # traversalMode() == BOUNDED &amp;&amp; position() == count() - 1 =&gt; [position()]<br /> # traversalMode() == CIRCULAR &amp;&amp; position() == count() - 1 =&gt; [0]<br /> T&amp; next() const</p>
<p># _position &lt; -1 || _position &gt; count() - 1 =&gt; -1<br /> int set_position(int _position)</p>
<p># MUTATION FUNCTIONS:</p>
<p># acquire ownership of _list; after the operation is completed _list becomes invalid<br /> void Acquire(list&lt;T&gt;&amp; _list)</p>
<p>list&lt;T&gt;&amp; Append(const T&amp; _value)</p>
<p>list&lt;T&gt;&amp; Append(const T&amp; _value, int _times)</p>
<p>list&lt;T&gt;&amp; Append(const list&lt;T&gt;&amp; _value)</p>
<p># _size &lt; 0 -&gt; state of the list doesn't change<br /> list&lt;T&gt;&amp; Clear(int _size = 0)</p>
<p># [1, 2, 10].FillLeft(5, 7) =&gt; [5, 5, 5, 5, 1, 2, 10]<br /> list&lt;T&gt;&amp; FillLeft(const T&amp; _value, int _length)</p>
<p># [1, 2, 10].FillRight(5, 7) =&gt; [1, 2, 10, 5, 5, 5, 5]<br /> list&lt;T&gt;&amp; FillRight(const T&amp; _value, int _length)</p>
<p># (count() &gt; 0 &amp;&amp; _index &gt; 0 &amp;&amp; _index &lt; count()) -&gt;<br /> list&lt;T&gt;&amp; Insert(const T&amp; _value, int _index)</p>
<p># (count() &gt; 0 &amp;&amp; _index &gt; 0 &amp;&amp; _index &lt; count()) -&gt;<br /> list&lt;T&gt;&amp; Insert(const list&lt;T&gt;&amp; _value, int _index)</p>
<p># [1, 2, 3, 4, 5].Move(2, 4) =&gt; [1, 2, 4, 5, 3]<br /> list&lt;T&gt;&amp; Move(int _sourceIndex, int _destinationIndex)</p>
<p># [11, 2, 10, 5, 4, 18, 9, 5, 0, 3].Reduce(2) =&gt; [10, 5, 4, 18, 9, 5]<br /> # [11, 2, 10, 5, 4, 18, 9, 5, 0, 3].Reduce(11) =&gt; [11, 2, 10, 5, 4, 18, 9, 5, 0, 3]<br /> list&lt;T&gt;&amp; Reduce(int _reducer)</p>
<p># [11, 2, 10, 5, 4, 18, 9, 5, 0, 3].ReduceLeft(4) =&gt; [4, 18, 9, 5, 0, 3]<br /> # [11, 2, 10, 5, 4, 18, 9, 5, 0, 3].ReduceLeft(11) =&gt; [11, 2, 10, 5, 4, 18, 9, 5, 0, 3]<br /> list&lt;T&gt;&amp; ReduceLeft(int _reducer)</p>
<p># [11, 2, 10, 5, 4, 18, 9, 5, 0, 3].ReduceRight(4) =&gt; [11, 2, 10, 5, 4, 18]<br /> # [11, 2, 10, 5, 4, 18, 9, 5, 0, 3].ReduceRight(11) =&gt; [11, 2, 10, 5, 4, 18, 9, 5, 0, 3]<br /> list&lt;T&gt;&amp; ReduceRight(int _reducer)</p>
<p>list&lt;T&gt;&amp; Remove(int _begin, int _end)</p>
<p>list&lt;T&gt;&amp; RemoveAt(int _index, int _length = 1)</p>
<p># removes the elements that match _value<br /> # [1, 25, 4, 3, 4, 6, 5, 2, 41, 4, 52, 7, 8, 9].RemoveAll(4) =&gt; [1, 25, 3, 6, 5, 2, 41, 52, 7, 8, 9]<br /> list&lt;T&gt;&amp; RemoveAll(const T&amp; _value)</p>
<p># removes the elements that match an element in _set<br /> # [1, 2, 3, 4, 5, 6, 5, 2, 7, 8, 9].RemoveAll(2, 4, 5, 8) =&gt; [1, 3, 6, 7, 8, 9]<br /> list&lt;T&gt;&amp; RemoveAll(const list&lt;T&gt;&amp; _set)</p>
<p>list&lt;T&gt;&amp; RemoveIf(const std::function&lt;bool(const T&amp;)&gt;&amp; _predicate)</p>
<p># [9, 2, 7].Repeat(2) =&gt; [9, 2, 7, 9, 2, 7, 9, 2, 7]<br /> list&lt;T&gt;&amp; Repeat(int _times)</p>
<p># [5, 9, 0, 3, 7, 18, 4, 2, 6].Replace(4, 7, [2, 6, 1]) =&gt; [5, 9, 0, 3, 2, 6, 1, 6]<br /> list&lt;T&gt;&amp; Replace(int _begin, int _end, const list&lt;T&gt;&amp; _replacement)</p>
<p># replace every occurrence of _replaced with _replacement<br /> list&lt;T&gt;&amp; Replace(const T&amp; _replaced, const T&amp; _replacement)</p>
<p># replace every occurrence of _replaced with _replacement<br /> list&lt;T&gt;&amp; Replace(const list&lt;T&gt;&amp; _replaced, const list&lt;T&gt;&amp; _replacement)</p>
<p># [9, 7, 2, 5, 9, 0, 6, 2, 8, 4].Reverse() =&gt; [4, 8, 2, 6, 0, 9, 5, 2, 7, 9]<br /> list&lt;T&gt;&amp; Reverse()</p>
<p># [1, 2, 3, 4, 5].RotateLeft(3) =&gt; [4, 5, 1, 2, 3]<br /> list&lt;T&gt;&amp; RotateLeft(int _positions = 1)</p>
<p># [1, 2, 3, 4, 5].RotateRight(3) =&gt; [3, 4, 5, 1, 2]<br /> list&lt;T&gt;&amp; RotateRight(int _positions = 1)</p>
<p># &lt;T&gt; implements o:&lt; or it is a primitive numerical type -&gt;<br /> list&lt;T&gt;&amp; SelectionSort(bool _ascending = true)</p>
<p>list&lt;T&gt;&amp; SelectionSort(const std::function&lt;bool(const T&amp;, const T&amp;)&gt;&amp; _predicate, bool _ascending = true)</p>
<p># [9, 1, 5, 3, 0, 4, 7, 0, 6, 5, 1].Set(3, 5, 192) =&gt; [9, 1, 5, 192, 192, 192, 7, 0, 6, 5, 1]<br /> list&lt;T&gt;&amp; Set(int _begin, int _end, const T&amp; _value)</p>
<p># [9, 1, 5, 3, 0, 4, 7, 0, 6, 5, 1].Set(3, [8, 2, 0, 1]) =&gt; [9, 1, 5, 8, 2, 0, 1, 0, 6, 5, 1]<br /> list&lt;T&gt;&amp; Set(int _begin, const list&lt;bool&gt;&amp; _value)</p>
<p>list&lt;T&gt;&amp; Swap(int _index1, int _index2)</p>
<p># _element1 and _element2 are pointers to elements of the list -&gt;<br /> list&lt;T&gt;&amp; Swap(T* _element1, T* _element2)</p>
<p># [2, 2, 2, 5, 9, 0, 6, 2, 2, 2, 2, 2].Trim(2) =&gt; [5, 9, 0, 6]<br /> list&lt;T&gt;&amp; Trim(const T&amp; _value)</p>
<p># [2, 2, 2, 5, 9, 0, 6, 2, 2, 2, 2, 2].TrimBegin(2) =&gt; [5, 9, 0, 6, 2, 2, 2, 2, 2]<br /> list&lt;T&gt;&amp; TrimBegin(const T&amp; _value)</p>
<p># [2, 2, 2, 5, 9, 0, 6, 2, 2, 2, 2, 2].TrimEnd(2) =&gt; [2, 2, 2, 5, 9, 0, 6]<br /> list&lt;T&gt;&amp; TrimEnd(const T&amp; _value)</p>
<p># NON-MUTATING FUNCTIONS:</p>
<p>bool BeginsWith(const list&lt;T&gt;&amp; _value) const</p>
<p># returns 'true' if &amp;this begins with atleast one of the sequences in _value<br /> # [8, 2, 5, 10, 7, 15, 12, 9, 1].BeginsWith([[5, 9, 1], [8, 1, 5], [9, 12, 0]]) =&gt; false<br /> # [8, 2, 5, 10, 7, 15, 12, 9, 1].BeginsWith([[5, 9, 1], [8, 2, 5], [9, 12, 0]]) =&gt; true<br /> bool BeginsWith(const list&lt;list&lt;T&gt;&gt;&amp; _values) const</p>
<p># returns copy of &amp;this<br /> list&lt;T&gt; Clone() const</p>
<p>bool Contains(const T&amp; _value) const</p>
<p># [1, 2, 3, 4, 5, 6, 7, 8, 9].Contains([2, 3, 4]) =&gt; true<br /> bool Contains(const list&lt;T&gt;&amp; _value) const</p>
<p>bool Contains(const std::function&lt;bool(const T&amp;)&gt;&amp; _predicate) const</p>
<p>bool ContainsAll(const list&lt;T&gt;&amp; _set) const</p>
<p># [9, 7, 3, 20, 15, 18, 4, 7].ContainsAny([21, 8, 5, 1]) =&gt; false<br /> # [9, 7, 3, 20, 15, 18, 4, 7].ContainsAny([6, 30, 3, 1]) =&gt; true<br /> bool ContainsAny(const list&lt;T&gt;&amp; _set) const</p>
<p>bool ContainsOnly(const T&amp; _value) const</p>
<p># [9, 1, 0, 3, 1, 5, 9, 1, 15, 3, 7, 5, 9, 1, 1].ContainsOnly([1, 9, 10]) =&gt; false<br /> # [9, 1, 0, 3, 1, 5, 9, 1, 15, 3, 7, 5, 9, 1, 1].ContainsOnly([5, 9, 1, 0, 7, 3, 15]) =&gt; true<br /> bool ContainsOnly(const list&lt;T&gt;&amp; _set) const</p>
<p>bool ContainsOnly(const std::function&lt;bool(const T&amp;)&gt;&amp; _predicate) const</p>
<p>int CountOf(const T&amp; _value) const</p>
<p># [5, 9, 1, 0, 3, 5, 9, 1, 4, 5, 9, 1, 10, 15, 3, 7, 5, 9, 1, 1].CountOf([5, 9, 1]) =&gt; 4<br /> # [5, 9, 1, 0, 3, 5, 9, 1, 4, 5, 9, 1, 10, 15, 3, 7, 5, 9, 1, 1].CountOf([5, 9, 1, 7]) =&gt; 0<br /> int CountOf(const list&lt;T&gt;&amp; _value) const</p>
<p>int CountOf(const std::function&lt;bool(const T&amp;)&gt;&amp; _predicate) const</p>
<p># [7, 8, 3, 19, 20, 71, 15, 71, 3, 31, 108, 3]).Duplicates() =&gt; [3, 71]<br /> list&lt;T&gt; Duplicates() const</p>
<p>bool EndsWith(const list&lt;T&gt;&amp; _value) const</p>
<p>bool EndsWith(const list&lt;list&lt;T&gt;&gt;&amp; _values) const</p>
<p># [2, 9, 0, 1, 4, 9, 7, 3].Except(9) =&gt; [2, 0, 1, 4, 7, 3]<br /> list&lt;T&gt; Except(const T&amp; _value) const</p>
<p># [2, 9, 0, 1, 4, 9, 7, 3].Except([9, 7, 0]) =&gt; [2, 1, 4, 3]<br /> list&lt;T&gt; Except(const list&lt;T&gt;&amp; _set) const</p>
<p>list&lt;T&gt; Except(const std::function&lt;bool(const T&amp;)&gt;&amp; _predicate) const</p>
<p># (if the element specified by the predicate is present in the list) the function returns a pointer to it<br /> # (if the element specified by the predicate is not present in the list) the functions returns a null pointer<br /> T* First(const std::function&lt;bool(const T&amp;)&gt;&amp; _predicate) const</p>
<p># there is an implicit conversion from &lt;T&gt; to &lt;A&gt; -&gt;<br /> template&lt;typename A&gt; list&lt;A&gt; Generate() const</p>
<p># struct Item { int Price; Item() = default; Item(int _price): Price(_price) {} };<br /> Item a(5);<br /> Item b(2);<br /> Item c(35);<br /> list&lt;Item&gt; items { a, b, c };<br /> list&lt;int&gt; l = items.Generate&lt;int&gt;([](const Item&amp; _item) { return _item.Price * 2; }); =&gt; [10, 4, 70] #<br /> template&lt;typename A&gt; list&lt;A&gt; Generate(const std::function&lt;A(const T&amp;)&gt;&amp; _generator) const</p>
<p># it checks whether the list contains an element with the specified index<br /> bool Has(int _index) const</p>
<p>bool HasDuplicates() const</p>
<p># the specified element does not exist or _begin is outside the range of list =&gt; -1<br /> int IndexOf(const T&amp; _value, int _begin = 0) const</p>
<p># the specified element does not exist or _begin is outside the range of list =&gt; -1<br /> int IndexOf(const list&lt;T&gt;&amp; _value, int _begin = 0) const</p>
<p># the specified element does not exist or _begin is outside the range of list =&gt; -1<br /> int IndexOf(const std::function&lt;bool(const T&amp;)&gt;&amp; _predicate, int _begin = 0) const</p>
<p># the specified element does not exist or _begin is outside the range of list =&gt; -1<br /> int IndexOfAny(const list&lt;T&gt;&amp; _set, int _begin = 0) const</p>
<p># _begin is outside the range of list =&gt; -2<br /> # [].IndexOf(4) =&gt; -1<br /> # [9, 9, 9, 5, 8, 10, 2, 7].IndexOfNot(9) =&gt; 3<br /> # [9, 9, 9, 5, 8, 10, 2, 7].IndexOfNot(4) =&gt; 0<br /> int IndexOfNot(const T&amp; _value, int _begin = 0) const</p>
<p># _begin is outside the range of list =&gt; -2<br /> # [].IndexOf(4) =&gt; -1<br /> # [9, 9, 9, 5, 8, 10, 2, 7].IndexOfNot(9) =&gt; 3<br /> # [9, 9, 9, 5, 8, 10, 2, 7].IndexOfNot(4) =&gt; 0<br /> int IndexOfNot(const std::function&lt;bool(const T&amp;)&gt;&amp; _predicate, int _begin = 0) const</p>
<p># A = [5, 0, 3, 6]<br /> B = [3, 2, 4, 5, 9]<br /> IntersectionOf(A, B) =&gt; [3, 5] #<br /> static list&lt;T&gt; IntersectionOf(const list&lt;T&gt;&amp; _left, const list&lt;T&gt;&amp; _right)</p>
<p>bool Intersects(const list&lt;T&gt;&amp; _value) const</p>
<p># count() &gt; 1 -&gt;<br /> bool IsHeterogeneous() const</p>
<p># count() &gt; 1 -&gt;<br /> bool IsHomogeneous() const</p>
<p># the specified value does not exist =&gt; -1<br /> int LastIndexOf(const T&amp; _value) const</p>
<p># the specified value does not exist =&gt; -1<br /> int LastIndexOf(const list&lt;T&gt;&amp; _value) const</p>
<p># the specified value does not exist =&gt; -1<br /> int LastIndexOf(const std::function&lt;bool(const T&amp;)&gt;&amp; _predicate) const</p>
<p># count() == 0 =&gt; nullptr<br /> # _sindex is outside the range of list =&gt; nullptr<br /> # &lt;T&gt; implements operator '&gt;' or it is a primitive numerical type -&gt;<br /> T* Max(int _sindex = 0) const</p>
<p># count() == 0 =&gt; nullptr<br /> # _sindex is outside the range of list =&gt; nullptr<br /> # &lt;T&gt; implements operator '&gt;' or it is a primitive numerical type -&gt;<br /> T* Min(int _sindex = 0) const</p>
<p># returns only values that are (between the beginning and a separator), (between separator and the end) or (between two separators)<br /> # empty sequences are generated (and eventually are appended to the result) only if they are between two separators<br /> # _ignoreEmptyValues = true -&gt; empty sequences (if there are any) are not appended to the result<br /> # [41, 56, 3, 7, 18, 5, 19, 76, 15].Multisplit([353, 12]) =&gt; []<br /> # [41, 56, 3, 7, 18, 5, 19, 76, 15, 9, 20, 5].Multisplit([56, 9]) =&gt; [[41], [3, 7, 18, 5, 19, 76, 15], [20, 5]]<br /> # [9, 41, 56, 3, 7, 18, 5, 19, 76, 15, 9, 9, 20, 7].Multisplit([7, 9]) =&gt; [[41, 56, 3], [18, 5, 19, 76, 15], [], [20]]<br /> # [9, 41, 56, 3, 7, 18, 5, 19, 76, 15, 9, 9, 20, 7].Multisplit([7, 9], true) =&gt; [[41, 56, 3], [18, 5, 19, 76, 15], [20]]<br /> list&lt;list&lt;T&gt;&gt; Multisplit(const list&lt;T&gt;&amp; _set, bool _ignoreEmptyValues = false) const</p>
<p># returns the range of a sequence consisting of certain set of values (it is not mandatory for the sequence to contain each value in the set)<br /> # [3, 10, 15, 12, 8, 5, 7, 5, 5, 7, 7, 3, 9].RangeOf([2, 5, 7]) =&gt; (5, 10)<br /> # [3, 10, 15, 12, 8, 5, 7, 2, 2, 7, 7, 3, 9].RangeOf([2, 5, 7]) =&gt; (5, 10)<br /> # [3, 10, 15, 12, 0, 5, 7, 2, 2, 7, 7, 3, 9].RangeOf([4, 0, 1]) =&gt; (4, 4)<br /> # [3, 10, 15, 12, 8, 5, 7, 2, 2, 7, 7, 3, 9].RangeOf([4, 0, 1]) =&gt; (-1, -1)<br /> Range&lt;int&gt; RangeOf(const list&lt;T&gt;&amp; _set, int _sindex = 0) const</p>
<p># returns the range of a sequence not consisting of certain set of values (it is mandatory for the sequence to not contain any of the values in the set)<br /> # [5, 7, 5, 5, 7, 7, 3, 10, 15, 12, 8, 2, 9].RangeOfNot([2, 5, 7]) =&gt; (6, 10)<br /> # [3, 10, 15, 12, 8, 5, 7, 2, 2, 7, 7, 3, 9].RangeOfNot([2, 5, 7]) =&gt; (0, 4)<br /> # [5, 7, 2, 2, 7, 7, 5, 4, 2, 7, 5].RangeOfNot([2, 5, 7]) =&gt; (7, 7)<br /> # [4, 0, 0, 1, 1, 4, 0, 1, 4, 4, 1].RangeOfNot([4, 0, 1]) =&gt; (-1, -1)<br /> Range&lt;int&gt; RangeOfNot(const list&lt;T&gt;&amp; _set, int _sindex = 0) const</p>
<p># returns only values that are (between the beginning and a separator), (between separator and the end) or (between two separators)<br /> # empty sequences are generated (and eventually are appended to the result) only if they are between two separators<br /> # _ignoreEmptyValues = true -&gt; empty sequences (if there are any) are not appended to the result<br /> # [3, 7, 18, 5, 19, 76, 15].Split(353) =&gt; []<br /> # [18, 5, 19, 76, 15, 9, 20, 5].Split(9) =&gt; [[18, 5, 19, 76, 15], [20, 5]]<br /> # [56, 3, 7, 18, 5, 19, 76, 7].Split(7) =&gt; [[56, 3], [18, 5, 19, 76]]<br /> # [56, 7, 7, 18, 5, 19, 76, 15, 9].Split(7) =&gt; [[56], [], [18, 5, 19, 76, 15, 9]]<br /> # [56, 7, 7, 18, 5, 19, 76, 15, 9].Split(7, true) =&gt; [[56], [18, 5, 19, 76, 15, 9]]<br /> # [7, 41, 56, 7, 18, 76, 15, 9, 7].Split(7) =&gt; [[41, 56], [18, 76, 15, 9]]<br /> # [7, 41, 56, 7, 7, 7, 18, 5, 15].Split(7) =&gt; [[41, 56], [], [], [18, 5, 15]]<br /> # [7, 41, 56, 7, 7, 7, 18, 5, 15].Split(7, true) =&gt; [[41, 56], [18, 5, 15]]<br /> list&lt;list&lt;T&gt;&gt; Split(const T&amp; _separator, bool _ignoreEmptyValues = false) const</p>
<p># returns only values that are (between the beginning and a separator), (between separator and the end) or (between two separators)<br /> # empty sequences are generated (and eventually are appended to the result) only if they are between two separators<br /> # _ignoreEmptyValues = true -&gt; empty sequences (if there are any) are not appended to the result<br /> # [41, 56, 3, 5, 7, 18, 5, 19, 76, 15].Split([3, 8]) =&gt; []<br /> # [41, 56, 3, 5, 7, 18, 5, 19, 9, 7, 76, 15, 9].Split([9, 7]) =&gt; [[41, 56, 3, 5, 7, 18, 5, 19], [76, 15, 9]]<br /> # [41, 56, 3, 9, 7, 18, 5, 19, 76, 15, 9, 20, 9, 7].Split([9, 7]) =&gt; [[41, 56, 3], [18, 5, 19, 76, 15, 9, 20]]<br /> # [41, 56, 9, 7, 9, 7, 18, 5, 19, 76, 15, 9, 20, 3].Split([9, 7]) =&gt; [[41, 56], [], [18, 5, 19, 76, 15, 9, 20, 3]]<br /> # [41, 56, 9, 7, 9, 7, 18, 5, 19, 76, 15, 9, 20, 3].Split([9, 7], true) =&gt; [[41, 56], [18, 5, 19, 76, 15, 9, 20, 3]]<br /> # [9, 7, 41, 56, 9, 9, 7, 18, 76, 15, 9, 20, 3, 9, 7].Split([9, 7]) =&gt; [[41, 56, 9], [18, 76, 15, 9, 20, 3]]<br /> # [9, 7, 41, 56, 9, 7, 9, 7, 9, 7, 18].Split([9, 7]) =&gt; [[41, 56], [], [], [18]]<br /> # [9, 7, 41, 56, 9, 7, 9, 7, 9, 7, 18].Split([9, 7], true) =&gt; [[41, 56], [18]]<br /> list&lt;list&lt;T&gt;&gt; Split(const list&lt;T&gt;&amp; _separator, bool _ignoreEmptyValues = false) const</p>
<p># returns only values that are (between the beginning and a separator), (between separator and the end) or (between two separators)<br /> # empty sequences are generated (and eventually are appended to the result) only if they are between two separators<br /> # _ignoreEmptyValues = true -&gt; empty sequences (if there are any) are not appended to the result<br /> # [3, 7, 18, 5, 19, 76, 15].Split([](int x) { return x == 353; }) =&gt; []<br /> # [18, 5, 19, 76, 15, 9, 20, 5].Split([](int x) { return x == 9; }) =&gt; [[18, 5, 19, 76, 15], [20, 5]]<br /> # [56, 3, 7, 18, 5, 19, 76, 7].Split([](int x) { return x == 7; }) =&gt; [[56, 3], [18, 5, 19, 76]]<br /> # [56, 7, 7, 18, 5, 19, 76, 15, 9].Split([](int x) { return x == 7; }) =&gt; [[56], [], [18, 5, 19, 76, 15, 9]]<br /> # [56, 7, 7, 18, 5, 19, 76, 15, 9].Split([](int x) { return x == 7; }, true) =&gt; [[56], [18, 5, 19, 76, 15, 9]]<br /> # [7, 41, 56, 7, 18, 76, 15, 9, 7].Split([](int x) { return x == 7; }) =&gt; [[41, 56], [18, 76, 15, 9]]<br /> # [7, 41, 56, 7, 7, 7, 18, 5, 15].Split([](int x) { return x == 7; }) =&gt; [[41, 56], [], [], [18, 5, 15]]<br /> # [7, 41, 56, 7, 7, 7, 18, 5, 15].Split([](int x) { return x == 7; }, true) =&gt; [[41, 56], [18, 5, 15]]<br /> list&lt;list&lt;T&gt;&gt; Split(const std::function&lt;bool(const T&amp;)&gt;&amp; _predicate, bool _ignoreEmptyValues = false) const</p>
<p># _length = 0 =&gt; [_begin..]<br /> # (_begin + _length) &gt; count() =&gt; {}<br /> list&lt;T&gt; Sublist(int _begin, int _length = 0) const</p>
<p># [5, 8, 4, 1, 9, 6, 2, 3, 0, 5, 5, 1, 7].Subrange(2, 5) =&gt; [4, 1, 9, 6]<br /> list&lt;T&gt; Subrange(int _begin, int _end) const</p>
<p>list&lt;T&gt; Where(const std::function&lt;bool(const T&amp;)&gt;&amp; _predicate) const</p>
<p>list&lt;T&gt; Until(const T&amp; _value) const</p>
<p>#</p>
<p>void resize(int _size = -1)</p>
<p>-----------------------------------------------------------------------------------------</p>
<p id="string" style="color:rgb(100, 100, 255);"><b>string.cpp:</b></p>
<p># constructor activation atoms<br />enum size = SIZE_A<br />enum ASCII = ascii<br />enum U8 = u8<br />enum U16 = u16<br />enum U32 = u32</p>
<p># activation atoms for string::ToInteger()<br />enum DECIMAL_ = DECIMAL_A<br />enum BINARY_ = BINARY_A<br />enum HEX_ = HEX_A</p>
<p># encoding format for (input and output string data)<br />enum Encoding = ASCII_ | UTF8 | UTF16LE | UTF16BE | UTF32LE | UTF32BE</p>
<p>const int INVALID_INTEGER = INT_MIN</p>
<p># maximum length in (bytes/code units/characters)<br />const int MAX_LENGTH = 1073741823</p>
<p># marker specifying (the length of a string in bytes)<br />const unsigned int b = 0 # [31] = 0, [30] = 0<br />const unsigned int bytes = b # pseudonym of &amp;b</p>
<p># marker specifying (the length of a string in code units)<br />const unsigned int u = 1073741824 # [31] = 0, [30] = 1<br />const unsigned int units = u # pseudonym of &amp;u</p>
<p># marker specifying (the length of a string in characters)<br />const unsigned int c = 2147483648 # [31] = 1, [30] = 0<br />const unsigned int characters = c # pseudonym of &amp;c</p>
<p># the default endianity value of the arguments in constructors of t:string; it is not possible to be a static field of t:string<br />Endianity DefaultEndianity = LE</p>
<p># the default encoding format of (the values passed to the constructors of t:string that are not marked with BOM)<br />Encoding DefaultInputEncoding = ASCII_</p>
<p># the default encoding format of the stored value of a string<br />Encoding DefaultStorageEncoding = UTF8</p>
<p># this type belongs to the 'Sequence' type category; t:string and t:list share many equivalent functions, but t:string do not implement<br /> First(), Generate(), Intersects(), IntersectionOf(), IsHeterogenous(), IsHomogenous(), Max(), Min(), fm:Sort() and Swap(*, *), while at the same time<br /> implements a set of extension functions #<br /># the input string (passed to the constructors) is in ASCII, UTF-8, UTF-16LE, UTF-16BE, UTF-32LE or UTF-32BE format<br /># the input string (may contain a terminating character) or (it's length may be explicitly specified)<br /># the output string (the string value after the construction process has ended) is stored as (byte sequence) representing (a sequence of UTF-8, UTF-16LE or UTF-32LE code units)<br /># (ASCII|UTF-8|UTF-16LE|UTF-16BE|UTF-32LE|UTF-32BE:input-string) -&gt; (UTF-8|UTF-16LE|UTF-32LE:output-string)<br /># &lt;T&gt; is the type of the output string<br /># (!) if certain input string is character-terminated, then the terminating character must be U+0000<br /># (!) the public functions of this type operate on characters(code points), not on bytes or code units<br /># (!) elements() returns a pointer to byte array containing (the characters represented as a sequence of (UTF-8, UTF-16LE, UTF-16BE, UTF-32LE or UTF-32BE) code units)<br /># (!) the constructors accept (byte arrays) or (arrays of UTF-16/UTF-32 code units)<br /># (!) (the constructors accepting byte arrays) may accept the array length (in bytes), (in code units) or (in characters); in order to pass<br /> the length in bytes one have to use &lt;N&gt; or &lt;N&gt;|b, to pass the length in code units &lt;N&gt;|u, and to pass the length in characters &lt;N&gt;|c;<br /> the maximum value of &lt;N&gt; is 1073741823 (constant MAX_LENGTH)<br /> (1) 162 (162 bytes)<br /> (2) 495|b (495 bytes)<br /> (E3) 829|u (829 code units)<br /> (3) 327|c (327 characters)<br /> (5) [utf16]:array -&gt; string(array, 94|c) (construction of a string accepting an array of UTF-16 code units with length 94 characters) #<br /># (!) (MAY-NEED-BETTER-EXPLANATION)<br /> when an incorrect length value is passed to a (constructor accepting UTF-16 or UTF-32 arrays) it is possible for a discrepancy to occur between<br /> the number of the specified number of bytes/code-units/characters and the number of the processed bytes/code-units/characters<br /> (E) string(const utf16*...) receive a length of 4 bytes; the first code unit is BMP character, and the second and third<br /> code units are respectively high and low surrogate of a non-BMP character; in this case 6 bytes (not 4) will be processed, because in<br /> constructors there is an iteration over characters (the first character is represented by the first two bytes, and the second<br /> by the next four bytes) #<br /># (!) the constructors must not receive an empty string or a string without terminating character(for ASCII and UTF-8) or terminating sequence<br /> (for UTF-16 and UTF-32); accessing of (an element outside the range of string) is 'undefined behavior' #<br /># (!) the size(accessed by size()) of a segment is equal to the size of the list that the segment refers to<br />struct String:</p>
<p>VARIABLES:</p>
<p># this variable plays a role for the speed of string generation; the larger the final size of the string is (i.e. the size after<br /> ending of the generation process), the larger the value of this variable must be; it needs to be increased by 1 every 2kb;<br /> if the string is very large and it's final size is known before the construction, then it is better to set the binary size before<br /> the start of the generation process - in such a way there wouldn't be need for (potentialy multiple) resize operations #<br /> int Extensor = 50 # in bytes</p>
<p>TraversalMode TraversalMode = TraversalMode::BOUNDED</p>
<p># when an instance of this type is about to be destructed the elements (are freed automatically and immediately<br /> (when IMMEDIATE is used)) or (are stored for future use and are freed manually in a specific future<br /> moment (when FUTURE is used)) #<br /> ReleaseMode ReleaseMode = ReleaseMode::IMMEDIATE</p>
<p># CONSTRUCTORS:</p>
<p>string() = default</p>
<p>explicit string(int _size, size)</p>
<p># _array is an ASCII string with an available terminating character -&gt;<br /> string(const char* _array)</p>
<p># _array is an ASCII|UTF-8|UTF-16|UTF-32 string with an available terminating character -&gt;<br /> string(const unsigned char* _array)</p>
<p># _array is an ASCII string with an available terminating character -&gt;<br /> string(const char* _array, ASCII, Encoding _storageEncoding)</p>
<p># _array is an ASCII string with an available terminating character -&gt;<br /> string(const char* _array, ASCII) -&gt; string(_array, ascii, DefaultStorageEncoding)</p>
<p># _length specifies the length of _array<br /> # _array is an ASCII string -&gt;<br /> string(const char* _array, ASCII, unsigned int _length, Encoding _storageEncoding)</p>
<p># _length specifies the length of _array<br /> # _array is an ASCII string -&gt;<br /> string(const char* _array, ASCII, unsigned int _length) -&gt; string(_array, ascii, _length, DefaultStorageEncoding)</p>
<p># _array is a UTF-8 string with an available terminating character -&gt;<br /> string(const unsigned char* _array, U8, Encoding _storageEncoding)</p>
<p># _array is a UTF-8 string with an available terminating character -&gt;<br /> string(const unsigned char*_array, U8) -&gt; string(_array, u8, DefaultStorageEncoding)</p>
<p># _length specifies the length of _array<br /> # _array is a UTF-8 string -&gt;<br /> string(const unsigned char* _array, U8, unsigned int _length, Encoding _storageEncoding)</p>
<p># _length specifies the length of _array<br /> # _array is a UTF-8 string -&gt;<br /> string(const unsigned char* _array, U8, unsigned int _length) -&gt; string(_array, u8, _length, DefaultStorageEncoding)</p>
<p># _array is a UTF-16 string with an available terminating character -&gt;<br /> string(const unsigned char* _array, U16, Endianity _endianity, Encoding _storageEncoding)</p>
<p># _array is a UTF-16 string with an available terminating character -&gt;<br /> string(const unsigned char* _array, U16, Endianity _endianity) -&gt; string(_array, u16, _endianity, DefaultStorageEncoding)</p>
<p># _array is a UTF-16 string with an available terminating character -&gt;<br /> string(const unsigned char* _array, U16, Encoding _storageEncoding) -&gt; string(_array, u16, DefaultEndianity, _storageEncoding)</p>
<p># _array is a UTF-16 string with an available terminating character -&gt;<br /> string(const unsigned char*_array, U16) -&gt; string(_array, u16, DefaultEndianity, DefaultStorageEncoding)</p>
<p># _length specifies the length of _array<br /> # _array is a UTF-16 string -&gt;<br /> string(const unsigned char* _array, U16, Endianity _endianity, unsigned int _length, Encoding _storageEncoding)</p>
<p># _length specifies the length of _array<br /> # _array is a UTF-16 string -&gt;<br /> string(const unsigned char* _array, U16, Endianity _endianity, unsigned int _length) -&gt; string(_array, u16, _endianity, _length, DefaultStorageEncoding)</p>
<p># _length specifies the length of _array<br /> # _array is a UTF-16 string -&gt;<br /> string(const unsigned char* _array, U16, unsigned int _length, Encoding _storageEncoding) -&gt; string(_array, u16, DefaultEndianity, _length, _storageEncoding)</p>
<p># _length specifies the length of _array<br /> # _array is a UTF-16 string -&gt;<br /> string(const unsigned char* _array, U16, unsigned int _length) -&gt; string(_array, u16, DefaultEndianity, _length, DefaultStorageEncoding)</p>
<p># _array is a UTF-32 string with an available terminating character -&gt;<br /> string(const unsigned char* _array, U32, Endianity _endianity, Encoding _storageEncoding)</p>
<p># _array is a UTF-32 string with an available terminating character -&gt;<br /> string(const unsigned char*_array, U32, Endianity _endianity) -&gt; string(_array, u32, _endianity, DefaultStorageEncoding)</p>
<p># _array is a UTF-32 string with an available terminating character -&gt;<br /> string(const unsigned char* _array, U32, Encoding _storageEncoding) -&gt; string(_array, u32, DefaultEndianity, _storageEncoding)</p>
<p># _array is a UTF-32 string with an available terminating character -&gt;<br /> string(const unsigned char* _array, U32) -&gt; string(_array, u32, DefaultEndianity, DefaultStorageEncoding)</p>
<p># _length specifies the length of _array<br /> # _array is a UTF-32 string -&gt;<br /> string(const unsigned char* _array, U32, Endianity _endianity, unsigned int _length, Encoding _storageEncoding)</p>
<p># _length specifies the length of _array<br /> # _array is a UTF-32 string -&gt;<br /> string(const unsigned char* _array, U32, Endianity _endianity, unsigned int _length) -&gt; string(_array, u32, _endianity, _length, DefaultStorageEncoding)</p>
<p># _length specifies the length of _array<br /> # _array is a UTF-32 string -&gt;<br /> string(const unsigned char* _array, U32, unsigned int _length, Encoding _storageEncoding) -&gt; string(_array, u32, DefaultEndianity, _length, _storageEncoding)</p>
<p># _length specifies the length of _array<br /> # _array is a UTF-32 string -&gt;<br /> string(const unsigned char* _array, U32, unsigned int _length) -&gt; string(_array, u32, DefaultEndianity, _length, DefaultStorageEncoding)</p>
<p># _array is a UTF-16 string with an available terminating character -&gt;<br /> string(const utf16* _array, Endianity _endianity, Encoding _storageEncoding)</p>
<p># _array is a UTF-16 string with an available terminating character -&gt;<br /> string(const utf16* _array, Endianity _endianity) -&gt; string(_array, _endianity, DefaultStorageEncoding)</p>
<p># _array is a UTF-16 string -&gt;<br /> string(const utf16* _array, Encoding _storageEncoding) -&gt; string(_array, DefaultEndianity, _storageEncoding)</p>
<p># _array is a UTF-16 string -&gt;<br /> string(const utf16* _array) -&gt; string(_array, DefaultEndianity, DefaultStorageEncoding)</p>
<p># _length specifies the length of _array<br /> # _array is a UTF-16 string -&gt;<br /> string(const utf16* _array, Endianity _endianity, unsigned int _length, Encoding _storageEncoding)</p>
<p># _length specifies the length of _array<br /> # _array is a UTF-16 string -&gt;<br /> string(const utf16*_array, Endianity _endianity, unsigned int _length) -&gt; string(_array, _length, DefaultStorageEncoding)</p>
<p># _length specifies the length of _array<br /> # _array is a UTF-16 string -&gt;<br /> string(const utf16*_array, unsigned int _length, Encoding _storageEncoding) -&gt; string(_array, DefaultEndianity, _length, _storageEncoding)</p>
<p># _length specifies the length of _array<br /> # _array is a UTF-16 string -&gt;<br /> string(const utf16*_array, unsigned int _length) -&gt; string(_array, DefaultEndianity, _length, DefaultStorageEncoding)</p>
<p># _array is a UTF-32 string with an available terminating character -&gt;<br /> string(const utf32*_array, Endianity _endianity, Encoding _storageEncoding)</p>
<p># _array is a UTF-32 string with an available terminating character -&gt;<br /> string(const utf32* _array, Endianity _endianity) -&gt; string(_array, _endianity, DefaultStorageEncoding)</p>
<p># _array is a UTF-32 string -&gt;<br /> string(const utf32*_array, Encoding _storageEncoding) -&gt; string(_array, DefaultEndianity, _storageEncoding)</p>
<p># _array is a UTF-32 string -&gt;<br /> string(const utf32*_array) -&gt; string(_array, DefaultEndianity, DefaultStorageEncoding)</p>
<p># _length specifies the length of _array<br /> # _array is a UTF-32 string -&gt;<br /> string(const utf32*_array, Endianity _endianity, unsigned int _length, Encoding _storageEncoding)</p>
<p># _length specifies the length of _array<br /> # _array is a UTF-32 string -&gt;<br /> string(const utf32*_array, Endianity _endianity, unsigned int _length) -&gt; string(_array, _endianity, _length, DefaultStorageEncoding)</p>
<p># _length specifies the length of _array<br /> # _array is a UTF-32 string -&gt;<br /> string(const utf32*_array, unsigned int _length, Encoding _storageEncoding) -&gt; string(_array, DefaultEndianity, _length, _storageEncoding)</p>
<p># _length specifies the length of _array<br /> # _array is a UTF-32 string -&gt;<br /> string(const utf32*_array, unsigned int _length) -&gt; string(_array, DefaultEndianity, _length, DefaultStorageEncoding)</p>
<p>string(const wchar_t* _string, Encoding _storageEncoding) -&gt; string(reinterpret_cast&lt;const utf16*&gt;(_string), LE, _storageEncoding)</p>
<p>string(const wchar_t* _string) -&gt; string(reinterpret_cast&lt;const utf16*&gt;(_string), LE, DefaultStorageEncoding) {}</p>
<p>string(const string&amp; _string)</p>
<p># it generates a segment<br /> string(const string&amp; _source, int _begin, int _end)</p>
<p># it generates a segment<br /> string(const string&amp; _source, const Range&lt;int&gt;&amp; _range)</p>
<p>string(char _character)</p>
<p>string(wchar_t _character)</p>
<p>string(CodePoint _codePoint)</p>
<p># OPERATORS:</p>
<p># this operator does not compare the fields of the two objects; it compares only the character content<br /> bool operator==(const string&amp;) const</p>
<p># this operator does not compare the fields of the two objects; it compares only the character content<br /> bool operator!=(const string&amp;) const</p>
<p># "East" == ["North", "South", "Left", "Right"] =&gt; false<br /> # "East" == ["North", "South", "East", "West"] =&gt; true<br /> bool operator==(const list&lt;string&gt;&amp; _values) const</p>
<p># "East" == ["North", "South", "East", "West"] =&gt; false<br /> # "East" == ["North", "South", "Left", "Right"] =&gt; true<br /> bool operator!=(const list&lt;string&gt;&amp; _values) const</p>
<p>string&amp; operator=(const string&amp;)</p>
<p>string operator+(CodePoint) const</p>
<p>string operator+(const string&amp;) const</p>
<p>string&amp; operator+=(CodePoint)</p>
<p>string&amp; operator+=(const string&amp;)</p>
<p># _index is in the range of list -&gt;<br /> CodePoint operator[](int _index)</p>
<p># _index is in the range of list -&gt;<br /> CodePoint operator[](int _index) const</p>
<p># FIELDS:</p>
<p>int byteCount() const</p>
<p>int count() const</p>
<p>int size() const</p>
<p>int position() const</p>
<p>Encoding storageEncoding() const</p>
<p>const unsigned char* elements() const</p>
<p>#</p>
<p>bool IsSegment() const</p>
<p># "205" =&gt; false<br /> # "205." =&gt; false<br /> # "205.0" =&gt; true<br /> # "205.12" =&gt; true<br /> bool IsFractional() const</p>
<p># _index is outside the range of list =&gt; -1<br /> # &lt;T&gt; is utf8, utf16 or utf32 -&gt;<br /> template&lt;typename T&gt; T codeUnitAt(int _index) const</p>
<p>TRAVERSAL FUNCTIONS:</p>
<p>bool can_reverse() const</p>
<p>bool can_advance() const</p>
<p># traversalMode() == BOUNDED &amp;&amp; position() - _value &lt; 0 &gt;&gt; position() = position()<br /> # traversalMode() == BOUNDED &amp;&amp; position() - _value &gt; -1 &gt;&gt; position() = position() - _value<br /> # traversalMode() == CIRCULAR -&gt; circular addition; (EXAMPLE) characterCount() = 19, position() = 4, back(9) &gt;&gt; position() = 14<br /> string&amp; back(int _value)</p>
<p># traversalMode() == BOUNDED &amp;&amp; position() + _value &gt;= characterCount() &gt;&gt; position() = position()<br /> # traversalMode() == BOUNDED &amp;&amp; position() + _value &lt; characterCount() - 1 &gt;&gt; position() = position() + _value<br /> # traversalMode() == CIRCULAR -&gt; circular addition; (EXAMPLE) characterCount() = 21, position() = 16, advance(10) &gt;&gt; position() = 5<br /> string&amp; advance(int _value)</p>
<p>CodePoint&amp; previous() const</p>
<p># characterCount() &gt; 0 -&gt;<br /> CodePoint current() const</p>
<p>CodePoint&amp; next() const</p>
<p>int set_position(int _position)</p>
<p># MUTATION FUNCTIONS:</p>
<p># acquire ownership of _string; after the operation is completed _string becomes invalid<br /> void Acquire(string&amp; _string)</p>
<p># the bytes in _value represent a single character (in a specific encoding) and (are appended to &amp;elements() in the same order as they are in _value)<br /> string&amp; Append(const list&lt;unsigned char&gt;&amp; _value)</p>
<p>string&amp; Append(CodePoint _value)</p>
<p>string&amp; Append(CodePoint _value, int _times)</p>
<p>string&amp; Append(const list&lt;CodePoint&gt;&amp; _value)</p>
<p>string&amp; Append(const string&amp; _value)</p>
<p># _size &lt; 0 -&gt; state of the list doesn't change<br /> string&amp; Clear(int _size = 0)</p>
<p># [1, 2, 10].FillLeft(5, 7) =&gt; [5, 5, 5, 5, 1, 2, 10]<br /> string&amp; FillLeft(CodePoint _value, int _length)</p>
<p># [1, 2, 10].FillRight(5, 7) =&gt; [1, 2, 10, 5, 5, 5, 5]<br /> string&amp; FillRight(CodePoint _value, int _length)</p>
<p># (count() &gt; 0 &amp;&amp; _index &gt; 0 &amp;&amp; _index &lt; characterCount()) -&gt;<br /> string&amp; Insert(CodePoint _value, int _index)</p>
<p># (count() &gt; 0 &amp;&amp; _index &gt; 0 &amp;&amp; (_index &lt;= characterCount())) -&gt;<br /> string&amp; Insert(const string&amp; _value, int _index)</p>
<p># [1, 2, 3, 4, 5].Move(2, 4) =&gt; [1, 2, 4, 5, 3]<br /> string&amp; Move(int _sourceIndex, int _destinationIndex)</p>
<p># [11, 2, 10, 5, 4, 18, 9, 5, 0, 3].Reduce(2) =&gt; [10, 5, 4, 18, 9, 5]<br /> # [11, 2, 10, 5, 4, 18, 9, 5, 0, 3].Reduce(11) =&gt; [11, 2, 10, 5, 4, 18, 9, 5, 0, 3]<br /> string Reduce(int _reducer)</p>
<p># [11, 2, 10, 5, 4, 18, 9, 5, 0, 3].ReduceLeft(4) =&gt; [4, 18, 9, 5, 0, 3]<br /> # [11, 2, 10, 5, 4, 18, 9, 5, 0, 3].ReduceLeft(11) =&gt; [11, 2, 10, 5, 4, 18, 9, 5, 0, 3]<br /> string ReduceLeft(int _reducer)</p>
<p># [11, 2, 10, 5, 4, 18, 9, 5, 0, 3].ReduceRight(4) =&gt; [11, 2, 10, 5, 4, 18]<br /> # [11, 2, 10, 5, 4, 18, 9, 5, 0, 3].ReduceRight(11) =&gt; [11, 2, 10, 5, 4, 18, 9, 5, 0, 3]<br /> string ReduceRight(int _reducer)</p>
<p>string&amp; Remove(int _begin, int _end)</p>
<p>string&amp; RemoveAt(int _index, int _length = 1)</p>
<p># removes the elements that match _value<br /> # [1, 25, 4, 3, 4, 6, 5, 2, 41, 4, 52, 7, 8, 9].RemoveAll(4) =&gt; [1, 25, 3, 6, 5, 2, 41, 52, 7, 8, 9]<br /> string RemoveAll(CodePoint _value)</p>
<p># removes the elements that match an element elements of _set<br /> # [1, 2, 3, 4, 5, 6, 5, 2, 7, 8, 9].RemoveAll(2, 4, 5, 8) =&gt; [1, 3, 6, 7, 8, 9]<br /> string RemoveAll(const string&amp; _set)</p>
<p>string RemoveIf(const std::function&lt;bool(CodePoint)&gt;&amp; _predicate)</p>
<p># [9, 2, 7].Repeat(2) =&gt; [9, 2, 7, 9, 2, 7, 9, 2, 7]<br /> string Repeat(int _times)</p>
<p># [5, 9, 0, 3, 7, 18, 4, 2, 6].Replace(4, 7, [2, 6, 1]) =&gt; [5, 9, 0, 3, 2, 6, 1, 6]<br /> string Replace(int _begin, int _end, const string&amp; _replacement)</p>
<p># replace every occurrence of _replaced with _replacement<br /> string&amp; Replace(CodePoint _replaced, CodePoint _replacement)</p>
<p># replace every occurrence of _replaced with _replacement<br /> string&amp; Replace(const string&amp; _replaced, const string&amp; _replacement)</p>
<p># [9, 7, 2, 5, 9, 0, 6, 2, 8, 4].Reverse() =&gt; [4, 8, 2, 6, 0, 9, 5, 2, 7, 9]<br /> string&amp; Reverse()</p>
<p># [1, 2, 3, 4, 5].RotateLeft(3) =&gt; [4, 5, 1, 2, 3]<br /> string&amp; RotateLeft(int _positions = 1)</p>
<p># [1, 2, 3, 4, 5].RotateRight(3) =&gt; [3, 4, 5, 1, 2]<br /> string&amp; RotateRight(int _positions = 1)</p>
<p>string&amp; Set(int _index, CodePoint _value)</p>
<p># [9, 1, 5, 3, 0, 4, 7, 0, 6, 5, 1].Set(3, 5, 192) =&gt; [9, 1, 5, 192, 192, 192, 7, 0, 6, 5, 1]<br /> string&amp; Set(int _begin, int _end, CodePoint _value)</p>
<p># [9, 1, 5, 3, 0, 4, 7, 0, 6, 5, 1].Set(3, [8, 2, 0, 1]) =&gt; [9, 1, 5, 8, 2, 0, 1, 0, 6, 5, 1]<br /> string&amp; Set(int _begin, const list&lt;bool&gt;&amp; _value)</p>
<p>string&amp; Swap(int _index1, int _index2)</p>
<p># [2, 2, 2, 5, 9, 0, 6, 2, 2, 2, 2, 2].Trim(2) =&gt; [5, 9, 0, 6]<br /> string&amp; Trim(CodePoint _value)</p>
<p># [2, 2, 2, 5, 9, 0, 6, 2, 2, 2, 2, 2].TrimBegin(2) =&gt; [5, 9, 0, 6, 2, 2, 2, 2, 2]<br /> string&amp; TrimBegin(CodePoint _value)</p>
<p># [2, 2, 2, 5, 9, 0, 6, 2, 2, 2, 2, 2].TrimEnd(2) =&gt; [2, 2, 2, 5, 9, 0, 6]<br /> string&amp; TrimEnd(CodePoint _value)</p>
<p># NON-MUTATING FUNCTIONS:</p>
<p># T is a pointer type -&gt;<br /> template&lt;typename T&gt; list&lt;T*&gt; As() const</p>
<p>bool BeginsWith(const string&amp; _value) const</p>
<p># returns 'true' if &amp;this begins with atleast one of the sequences in _value<br /> # [8, 2, 5, 10, 7, 15, 12, 9, 1].BeginsWith([[5, 9, 1], [8, 1, 5], [9, 12, 0]]) =&gt; false<br /> # [8, 2, 5, 10, 7, 15, 12, 9, 1].BeginsWith([[5, 9, 1], [8, 2, 5], [9, 12, 0]]) =&gt; true<br /> bool BeginsWith(const list&lt;string&gt;&amp; _values) const</p>
<p># returns copy of &amp;this<br /> string Clone() const</p>
<p>bool Contains(CodePoint _value) const</p>
<p># [1, 2, 3, 4, 5, 6, 7, 8, 9].Contains([2, 3, 4]) =&gt; true<br /> bool Contains(const string&amp; _value) const</p>
<p>bool Contains(const std::function&lt;bool(CodePoint)&gt;&amp; _predicate) const</p>
<p>bool ContainsAll(const string&amp; _set) const</p>
<p># [9, 7, 3, 20, 15, 18, 4, 7].ContainsAny([21, 8, 5, 1]) =&gt; false<br /> # [9, 7, 3, 20, 15, 18, 4, 7].ContainsAny([6, 30, 3, 1]) =&gt; true<br /> bool ContainsAny(const list&lt;CodePoint&gt;&amp; _set) const</p>
<p>bool ContainsOnly(CodePoint _value) const</p>
<p># [9, 1, 0, 3, 1, 5, 9, 1, 15, 3, 7, 5, 9, 1, 1].ContainsOnly([1, 9, 10]) =&gt; false<br /> # [9, 1, 0, 3, 1, 5, 9, 1, 15, 3, 7, 5, 9, 1, 1].ContainsOnly([5, 9, 1, 0, 7, 3, 15]) =&gt; true<br /> bool ContainsOnly(const list&lt;CodePoint&gt;&amp; _set) const</p>
<p>bool ContainsOnly(const std::function&lt;bool(CodePoint)&gt;&amp; _predicate) const</p>
<p>int CountOf(CodePoint _value) const</p>
<p># [5, 9, 1, 0, 3, 5, 9, 1, 4, 5, 9, 1, 10, 15, 3, 7, 5, 9, 1, 1].CountOf([5, 9, 1]) =&gt; 4<br /> # [5, 9, 1, 0, 3, 5, 9, 1, 4, 5, 9, 1, 10, 15, 3, 7, 5, 9, 1, 1].CountOf([5, 9, 1, 7]) =&gt; 0<br /> int CountOf(const string&amp; _value) const</p>
<p>int CountOf(const std::function&lt;bool(CodePoint)&gt;&amp; _predicate) const</p>
<p># [7, 8, 3, 19, 20, 71, 15, 71, 3, 31, 108, 3]).Duplicates() =&gt; [3, 71]<br /> string Duplicates() const</p>
<p>bool EndsWith(const string&amp; _value) const</p>
<p>bool EndsWithWith(const list&lt;string&gt;&amp; _values) const</p>
<p># [2, 9, 0, 1, 4, 9, 7, 3].Except(9) =&gt; [2, 0, 1, 4, 7, 3]<br /> string Except(CodePoint _value) const</p>
<p># [2, 9, 0, 1, 4, 9, 7, 3].Except([9, 7, 0]) =&gt; [2, 1, 4, 3]<br /> string Except(const list&lt;CodePoint&gt;&amp; _set) const</p>
<p>string Except(const std::function&lt;bool(CodePoint)&gt;&amp; _predicate) const</p>
<p>bool HasDuplicates() const</p>
<p># the specified element does not exist or _begin is outside the range of string =&gt; -1<br /> int IndexOf(CodePoint _value, int _begin = 0) const</p>
<p># the specified element does not exist or _begin is outside the range of string =&gt; -1<br /> int IndexOf(const string&amp; _value, int _begin = 0) const</p>
<p># the specified element does not exist or _begin is outside the range of string =&gt; -1<br /> int IndexOf(const std::function&lt;bool(CodePoint)&gt;&amp; _predicate, int _begin = 0) const</p>
<p># the specified value does not exist or _begin is outside the range of string =&gt; -1<br /> int IndexOfAny(const list&lt;CodePoint&gt;&amp; _set, int _begin = 0) const</p>
<p># _begin is outside the range of list =&gt; -2<br /> # [].IndexOf(4) =&gt; -1<br /> # [9, 9, 9, 5, 8, 10, 2, 7].IndexOfNot(9) =&gt; 3<br /> # [9, 9, 9, 5, 8, 10, 2, 7].IndexOfNot(4) =&gt; 0<br /> int IndexOfNot(const std::function&lt;bool(CodePoint)&gt;&amp; _predicate, int _begin = 0) const</p>
<p># _begin is outside the range of list =&gt; -2<br /> # [].IndexOf(4) =&gt; -1<br /> # [9, 9, 9, 5, 8, 10, 2, 7].IndexOfNot(9) =&gt; 3<br /> # [9, 9, 9, 5, 8, 10, 2, 7].IndexOfNot(4) =&gt; 0<br /> int IndexOfNot(CodePoint _value, int _begin = 0) const</p>
<p># the specified value does not exist =&gt; -1<br /> int LastIndexOf(CodePoint _value) const</p>
<p># the specified value does not exist =&gt; -1<br /> int LastIndexOf(const string&amp; _value) const</p>
<p># the specified value does not exist =&gt; -1<br /> int LastIndexOf(const std::function&lt;bool(CodePoint)&gt;&amp; _predicate) const</p>
<p># returns only values that are (between the beginning and a separator), (between separator and the end) or (between two separators)<br /> # empty sequences are generated (and eventually are appended to the result) only if they are between two separators<br /> # _ignoreEmptyValues = true -&gt; empty sequences (if there are any) are not appended to the result<br /> # [41, 56, 3, 7, 18, 5, 19, 76, 15].Multisplit([353, 12]) =&gt; []<br /> # [41, 56, 3, 7, 18, 5, 19, 76, 15, 9, 20, 5].Multisplit([56, 9]) =&gt; [[41], [3, 7, 18, 5, 19, 76, 15], [20, 5]]<br /> # [9, 41, 56, 3, 7, 18, 5, 19, 76, 15, 9, 9, 20, 7].Multisplit([7, 9]) =&gt; [[41, 56, 3], [18, 5, 19, 76, 15], [], [20]]<br /> # [9, 41, 56, 3, 7, 18, 5, 19, 76, 15, 9, 9, 20, 7].Multisplit([7, 9], true) =&gt; [[41, 56, 3], [18, 5, 19, 76, 15], [20]]<br /> list&lt;string&gt; Multisplit(const list&lt;CodePoint&gt;&amp; _set, bool _ignoreEmptyValues = false) const</p>
<p># returns the range of a sequence consisting of certain set of values (it is not mandatory for the sequence to contain each value in the set)<br /> # [3, 10, 15, 12, 8, 5, 7, 5, 5, 7, 7, 3, 9].RangeOf([2, 5, 7]) =&gt; (5, 10)<br /> # [3, 10, 15, 12, 8, 5, 7, 2, 2, 7, 7, 3, 9].RangeOf([2, 5, 7]) =&gt; (5, 10)<br /> # [3, 10, 15, 12, 0, 5, 7, 2, 2, 7, 7, 3, 9].RangeOf([4, 0, 1]) =&gt; (4, 4)<br /> # [3, 10, 15, 12, 8, 5, 7, 2, 2, 7, 7, 3, 9].RangeOf([4, 0, 1]) =&gt; (-1, -1)<br /> Range&lt;int&gt; RangeOf(const list&lt;CodePoint&gt;&amp; _set, int _sindex = 0) const</p>
<p># returns the range of a sequence not consisting of certain set of values (it is mandatory for the sequence to not contain any of the values in the set)<br /> # [5, 7, 5, 5, 7, 7, 3, 10, 15, 12, 8, 2, 9].RangeOfNot([2, 5, 7]) =&gt; (6, 10)<br /> # [3, 10, 15, 12, 8, 5, 7, 2, 2, 7, 7, 3, 9].RangeOfNot([2, 5, 7]) =&gt; (0, 4)<br /> # [5, 7, 2, 2, 7, 7, 5, 4, 2, 7, 5].RangeOfNot([2, 5, 7]) =&gt; (7, 7)<br /> # [4, 0, 0, 1, 1, 4, 0, 1, 4, 4, 1].RangeOfNot([4, 0, 1]) =&gt; (-1, -1)<br /> Range&lt;int&gt; RangeOfNot(const list&lt;CodePoint&gt;&amp; _set, int _sindex = 0) const</p>
<p># returns only values that are (between the beginning and a separator), (between separator and the end) or (between two separators)<br /> # empty sequences are generated (and eventually are appended to the result) only if they are between two separators<br /> # _ignoreEmptyValues = true -&gt; empty sequences (if there are any) are not appended to the result<br /> # [3, 7, 18, 5, 19, 76, 15].Split(353) =&gt; []<br /> # [18, 5, 19, 76, 15, 9, 20, 5].Split(9) =&gt; [[18, 5, 19, 76, 15], [20, 5]]<br /> # [56, 3, 7, 18, 5, 19, 76, 7].Split(7) =&gt; [[56, 3], [18, 5, 19, 76]]<br /> # [56, 7, 7, 18, 5, 19, 76, 15, 9].Split(7) =&gt; [[56], [], [18, 5, 19, 76, 15, 9]]<br /> # [56, 7, 7, 18, 5, 19, 76, 15, 9].Split(7, true) =&gt; [[56], [18, 5, 19, 76, 15, 9]]<br /> # [7, 41, 56, 7, 18, 76, 15, 9, 7].Split(7) =&gt; [[41, 56], [18, 76, 15, 9]]<br /> # [7, 41, 56, 7, 7, 7, 18, 5, 15].Split(7) =&gt; [[41, 56], [], [], [18, 5, 15]]<br /> # [7, 41, 56, 7, 7, 7, 18, 5, 15].Split(7, true) =&gt; [[41, 56], [18, 5, 15]]<br /> list&lt;string&gt; Split(CodePoint _separator, bool _ignoreEmptyValues = false) const</p>
<p># returns only values that are (between the beginning and a separator), (between separator and the end) or (between two separators)<br /> # empty sequences are generated (and eventually are appended to the result) only if they are between two separators<br /> # _ignoreEmptyValues = true -&gt; empty sequences (if there are any) are not appended to the result<br /> # [41, 56, 3, 5, 7, 18, 5, 19, 76, 15].Split([3, 8]) =&gt; []<br /> # [41, 56, 3, 5, 7, 18, 5, 19, 9, 7, 76, 15, 9].Split([9, 7]) =&gt; [[41, 56, 3, 5, 7, 18, 5, 19], [76, 15, 9]]<br /> # [41, 56, 3, 9, 7, 18, 5, 19, 76, 15, 9, 20, 9, 7].Split([9, 7]) =&gt; [[41, 56, 3], [18, 5, 19, 76, 15, 9, 20]]<br /> # [41, 56, 9, 7, 9, 7, 18, 5, 19, 76, 15, 9, 20, 3].Split([9, 7]) =&gt; [[41, 56], [], [18, 5, 19, 76, 15, 9, 20, 3]]<br /> # [41, 56, 9, 7, 9, 7, 18, 5, 19, 76, 15, 9, 20, 3].Split([9, 7], true) =&gt; [[41, 56], [18, 5, 19, 76, 15, 9, 20, 3]]<br /> # [9, 7, 41, 56, 9, 9, 7, 18, 76, 15, 9, 20, 3, 9, 7].Split([9, 7]) =&gt; [[41, 56, 9], [18, 76, 15, 9, 20, 3]]<br /> # [9, 7, 41, 56, 9, 7, 9, 7, 9, 7, 18].Split([9, 7]) =&gt; [[41, 56], [], [], [18]]<br /> # [9, 7, 41, 56, 9, 7, 9, 7, 9, 7, 18].Split([9, 7], true) =&gt; [[41, 56], [18]]<br /> list&lt;string&gt; Split(const string&amp; _separator, bool _ignoreEmptyValues = false) const</p>
<p># returns only values that are (between the beginning and a separator), (between separator and the end) or (between two separators)<br /> # empty sequences are generated (and eventually are appended to the result) only if they are between two separators<br /> # _ignoreEmptyValues = true -&gt; empty sequences (if there are any) are not appended to the result<br /> # [3, 7, 18, 5, 19, 76, 15].Split([](int x) { return x == 353; }) =&gt; []<br /> # [18, 5, 19, 76, 15, 9, 20, 5].Split([](int x) { return x == 9; }) =&gt; [[18, 5, 19, 76, 15], [20, 5]]<br /> # [56, 3, 7, 18, 5, 19, 76, 7].Split([](int x) { return x == 7; }) =&gt; [[56, 3], [18, 5, 19, 76]]<br /> # [56, 7, 7, 18, 5, 19, 76, 15, 9].Split([](int x) { return x == 7; }) =&gt; [[56], [], [18, 5, 19, 76, 15, 9]]<br /> # [56, 7, 7, 18, 5, 19, 76, 15, 9].Split([](int x) { return x == 7; }, true) =&gt; [[56], [18, 5, 19, 76, 15, 9]]<br /> # [7, 41, 56, 7, 18, 76, 15, 9, 7].Split([](int x) { return x == 7; }) =&gt; [[41, 56], [18, 76, 15, 9]]<br /> # [7, 41, 56, 7, 7, 7, 18, 5, 15].Split([](int x) { return x == 7; }) =&gt; [[41, 56], [], [], [18, 5, 15]]<br /> # [7, 41, 56, 7, 7, 7, 18, 5, 15].Split([](int x) { return x == 7; }, true) =&gt; [[41, 56], [18, 5, 15]]<br /> list&lt;string&gt; Split(const std::function&lt;bool(CodePoint)&gt;&amp; _predicate, bool _ignoreEmptyValues = false) const</p>
<p># _length = 0 =&gt; [_begin..]<br /> # (_begin + _length) &gt; characterCount() =&gt; {}<br /> string Sublist(int _begin, int _length = 0) const</p>
<p># [5, 8, 4, 1, 9, 6, 2, 3, 0, 5, 5, 1, 7].Subrange(2, 5) =&gt; [4, 1, 9, 6]<br /> string Subrange(int _begin, int _end) const</p>
<p>string Where(const std::function&lt;bool(CodePoint)&gt;&amp; _predicate) const</p>
<p>string Until(CodePoint _value) const</p>
<p># OTHER FUNCTIONS:</p>
<p># *this == "true" | "false" -&gt;<br /> bool ToBool() const</p>
<p>static string FromBool(bool _value)</p>
<p># the value of the number is outside the valid range for (long long) =&gt; incorrect value<br /> # the string is valid decimal value in the valid range for (long long) -&gt;<br /> long long ToInteger(BINARY_, BitOrder _bitOrder) const</p>
<p># the value of the number is outside the valid range for (long long) =&gt; incorrect value<br /> # the string is valid decimal value in the valid range for (long long) -&gt;<br /> long long ToInteger(DECIMAL_) const</p>
<p># the value of the number is outside the valid range for (unsigned long long) =&gt; incorrect value<br /> # the string is valid decimal value in the valid range for (unsigned long long) -&gt;<br /> unsigned long long ToIntegerU(DECIMAL_) const</p>
<p># the value of the number is outside the valid range for (unsigned long long) =&gt; incorrect value<br /> # the string is valid hexadecimal value in the valid range for (unsigned long long) -&gt;<br /> long long ToInteger(HEX_) const</p>
<p># _number &lt; 1 quadrillion -&gt;<br /> static string FromInteger(long long _number)</p>
<p>float ToFloat() const</p>
<p>double ToDouble() const</p>
<p># the current value of the string contains only ASCII characters -&gt;<br /> const char* ToASCII() const</p>
<p># returns a list of UTF-32 characters<br /> # the string does not contain composite characters -&gt;<br /> const char32_t* ToChar32() const</p>
<p># the string does not contain composite characters -&gt;<br /> const wchar_t* ToWide() const</p>
<p>list&lt;char&gt; ToBytes() const</p>
<p>#</p>
<p>void resize(int _size = -1)</p>
<p># the value of _string contains only ASCII characters -&gt;<br />void print(const string&amp; _string)</p>
<p>-----------------------------------------------------------------------------------------</p>
<p id="numeric" style="color:rgb(100, 100, 255);"><b>numeric.cpp:</b></p>
<p>(!) the functionality in this file is located in namespace 'numeric'</p>
<p># TYPES:</p>
<p>enum class TraversalDirection = LEFT | RIGHT</p>
<p>enum class MagnitudeDirection = SMALLER | LARGER</p>
<p># CONSTANTS:</p>
<p>[char] HEX_DIGITS = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F']</p>
<p># FUNCTIONS:</p>
<p>template&lt;typename T&gt; T Abs(T _number)</p>
<p># (8) =&gt; -8<br /># (-6) =&gt; 6<br />template&lt;typename T&gt; T Inverse(T _number)</p>
<p>bool IsEven(int N)</p>
<p>bool IsOdd(int N)</p>
<p># (6.02645) =&gt; 0.02645<br /># (-18.823569) =&gt; 0.823569<br /># (0) =&gt; 0.0<br />double FractionOf(double N)</p>
<p># (52, 5) =&gt; 2<br /># (7, 20) =&gt; 7<br /># (20, 7) =&gt; 6<br /># (0, 3) =&gt; 0<br /># N1 &gt; 0, N2 &gt; 0 -&gt;<br />int Mod(int N1, int N2)</p>
<p># (52.6, 5.0) =&gt; 2.6<br /># (5.0, 52.6) =&gt; 5.0<br /># (218.0749, 39.4) =&gt; 21.0749<br /># (0.0, 3.0) =&gt; 0.0<br /># N1 &gt; 0.0, N2 &gt; 0.0 -&gt;<br />double Mod(double N1, double N2)</p>
<p># _exponent &lt; 0 =&gt; 0<br /># _exponent == 0 =&gt; 1<br /># _exponent &gt; 0 -&gt;<br />long long Pow(int _base, int _exponent)</p>
<p># N1 == N2 =&gt; N2<br />int LargerOf(int N1, int N2)</p>
<p># N1 == N2 =&gt; N2<br />double LargerOf(double N1, double N2)</p>
<p># N1 == N2 =&gt; N2<br />int SmallerOf(int N1, int N2)</p>
<p># N1 == N2 =&gt; N2<br />double SmallerOf(double N1, double N2)</p>
<p># (89.4, 9106.7) =&gt; 4598.05<br />double AverageOf(double N1, double N2)</p>
<p># (54, 182) =&gt; 98<br /># (182, 28) =&gt; 50<br /># _percent &gt;= 0.0, _value &gt;= 0.0 -&gt;<br />double FromPercent(double _percent, double _value)</p>
<p># (15, 782) =&gt; 1.9181585677749362<br /># (782, 15) =&gt; 5213.3333333333330<br /># N1 &gt;= 0.0, N2 &gt;= 0.0 -&gt;<br />double ToPercent(double N1, double N2)</p>
<p># (385.91) =&gt; 385.0<br /># _value &gt;= 0.0 -&gt;<br />int RoundDown(float _value)</p>
<p># (385.91) =&gt; 385.0<br /># _value &gt;= 0.0 -&gt;<br />int RoundDown(double _value)</p>
<p># (385.91) =&gt; 386.0<br /># _value &gt;= 0.0 -&gt;<br />int RoundUp(float _value)</p>
<p># (385.91) =&gt; 386.0<br /># _value &gt;= 0.0 -&gt;<br />int RoundUp(double _value)</p>
<p># (385.91) =&gt; 386.0<br /># (385.50) =&gt; 385.0<br /># _value &gt;= 0.0 -&gt;<br />float RoundToNearest(float _value)</p>
<p># (385.91) =&gt; 386.0<br /># (385.50) =&gt; 385.0<br /># _value &gt;= 0.0 -&gt;<br />double RoundToNearest(double _value)</p>
<p># (3, 5) =&gt; 2<br /># (5, 3) =&gt; 2<br /># (511, 96) =&gt; 415<br /># (96, 511) =&gt; 415<br /># (-4, 5) =&gt; 9<br /># (5, -4) =&gt; 9<br /># N == N =&gt; 0<br />int DistanceOf(int N1, int N2)</p>
<p># _rangeBegin &gt;= _rangeEnd =&gt; -1<br /># _currentValue &lt; _rangeBegin || _value &gt; _rangeEnd =&gt; -2<br /># _addition &lt; 1 =&gt; -3<br /># (20, 35, 28, 9) =&gt; 21<br /># (20, 35, 28, 61) =&gt; 25<br /># (-8, 5, -3, 19) =&gt; 2<br />int CircularAddition(int _rangeBegin, int _rangeEnd, int _currentValue, int _addition)</p>
<p># _rangeBegin &gt;= _rangeEnd =&gt; -1<br /># _currentValue &lt; _rangeBegin || _value &gt; _rangeEnd =&gt; -2<br /># _subtraction &lt; 1 =&gt; -3<br /># (20, 35, 28, 9) =&gt; 35<br /># (20, 35, 28, 61) =&gt; 31<br /># (-8, 5, -3, 19) =&gt; -8<br />int CircularSubtraction(int _rangeBegin, int _rangeEnd, int _currentValue, int _subtraction)</p>
<p># _size is the size of _hex<br />unsigned long long ToDecimal(const char* _hex, int _size)</p>
<p>-----------------------------------------------------------------------------------------</p>
<p id="bit_operations" style="color:rgb(100, 100, 255);"><b>bit_operations.cpp:</b></p>
<p>(!) the functionality in this file is located in namespace 'bit_operations'</p>
<p># (!) bit index '0' specifies the least significant bit</p>
<p># LSB :: Least Significant Bit, MSB :: Most Significant Bit</p>
<p>struct BitSet:</p>
<p>BitSet() = default</p>
<p>BitSet(unsigned short _bitCount) -&gt; the value of each bit is 0</p>
<p>BitSet(unsigned long long _value)</p>
<p>BitSet(const BitSet&amp;)</p>
<p>BitSet&amp; operator=(const BitSet&amp;)</p>
<p>int bitCount() const</p>
<p>int byteCount() const</p>
<p>unsigned char* byteSequence() const</p>
<p>void SetBit(int _index, bool _value)</p>
<p>bool GetBit(int _index) const</p>
<p># (0000000000).SetBits((11001), 3) =&gt; 0010011000<br /> void SetBits(const list&lt;bool&gt;&amp; _bits, int _begin)</p>
<p># (0000000000).SetBits((11001), 3) =&gt; 0010011000<br /> void SetBitsR(const list&lt;bool&gt;&amp; _bits, int _begin)</p>
<p># reverse&lt;unsigned char&gt;(01001010) =&gt; 01010010<br /># reverse&lt;unsigned short&gt;(0000000001001010) =&gt; 0101001000000000<br /># reverse&lt;unsigned int&gt;(00000100111001011110000000101010) =&gt; 01010100000001111010011100100000<br /># &lt;T&gt; = uchar | ushort | uint -&gt;<br />template&lt;typename T&gt; T Reverse(T _sequence)</p>
<p># _index &gt;= 0 || _index &lt;= 7 -&gt;<br />bool GetBit(unsigned char _number, int _index)</p>
<p># _index &gt;= 0 || _index &lt;= 15 -&gt;<br />bool GetBit(unsigned short _number, int _index)</p>
<p># _index &gt;= 0 || _index &lt;= 31 -&gt;<br />bool GetBit(unsigned int _number, int _index)</p>
<p># _index &gt;= 0 || _index &lt;= 63 -&gt;<br />bool GetBit(unsigned long long _number, int _index)</p>
<p># GetBits(53, 1, 3) =&gt; [0, 1, 0] = Dx2<br /># _begin &gt;= 0 || _end &lt;= 7, _begin &lt; _end -&gt;<br />unsigned char GetBits(unsigned char _number, int _begin, int _end)</p>
<p># _begin &gt;= 0 || _end &lt;= 15, _begin &lt; _end -&gt;<br />unsigned short GetBits(unsigned short _number, int _begin, int _end)</p>
<p># _begin &gt;= 0 || _end &lt;= 31, _begin &lt; _end -&gt;<br />unsigned int GetBits(unsigned int _number, int _begin, int _end)</p>
<p># _index &gt;= 0 || _index &lt;= 7 -&gt;<br />void SetBit(unsigned char&amp; _number, int _index, bool _value)</p>
<p># _index &gt;= 0 || _index &lt;= 15 -&gt;<br />void SetBit(unsigned short&amp; _number, int _index, bool _value)</p>
<p># _index &gt;= 0 || _index &lt;= 31 -&gt;<br />void SetBit(unsigned int&amp; _number, int _index, bool _value)</p>
<p># _index &gt;= 0 || _index &lt;= 63 -&gt;<br />void SetBit(unsigned long long&amp; _number, int _index, bool _value)</p>
<p># _begin &gt;= 0 || _end &lt;= 7, _begin &lt; _end -&gt;<br />void SetBits(unsigned char&amp; _number, int _begin, int _end, bool _value)</p>
<p># _begin &gt;= 0 || _end &lt;= 15, _begin &lt; _end -&gt;<br />void SetBits(unsigned short&amp; _number, int _begin, int _end, bool _value)</p>
<p># _begin &gt;= 0 || _end &lt;= 31, _begin &lt; _end -&gt;<br />void SetBits(unsigned int&amp; _number, int _begin, int _end, bool _value)</p>
<p># _begin &gt;= 0 || _end &lt;= 63, _begin &lt; _end -&gt;<br />void SetBits(unsigned long long&amp; _number, int _begin, int _end, bool _value)</p>
<p># returns all bits of _value; the first bit in the list is LSB<br /># (194) =&gt; [01000011]<br />list&lt;bool&gt; BitsOf(unsigned char _value)</p>
<p># returns all bits of _value; the first bit in the list is LSB<br /># (41092) =&gt; [0010000100000101]<br />list&lt;bool&gt; BitsOf(unsigned short _value)</p>
<p># returns all bits of _value; the first bit in the list is LSB<br /># (41092) =&gt; [00100001000001010000000000000000]<br />list&lt;bool&gt; BitsOf(unsigned int _value)</p>
<p># returns all bits of _value; the first bit in the list is LSB<br /># (41092) =&gt; [0010000100000101000000000000000000000000000000000000000000000000]<br />list&lt;bool&gt; BitsOf(unsigned long long _value)</p>
<p># returns all bits of _value; the first bit in the list is LSB<br /># (194) =&gt; [11000010]<br />list&lt;bool&gt; BitsOfR(unsigned char _value)</p>
<p># return all bits of _value; the first bit in the list is MSB<br /># (41092) =&gt; [1010000010000100]<br />list&lt;bool&gt; BitsOfR(unsigned short _value)</p>
<p># return all bits of _value; the first bit in the list is SB<br /># (41092) =&gt; [00000000000000001010000010000100]<br />list&lt;bool&gt; BitsOfR(unsigned int _value)</p>
<p># return all bits of _value; the first bit in the list is MSB<br /># (41092) =&gt; [0000000000000000000000000000000000000000000000001010000010000100]<br />list&lt;bool&gt; BitsOfR(unsigned long long _value)</p>
<p># returns the number of bits needed for the binary representation of (the absolute value of _number)<br />int BitLengthOf(unsigned int _number)</p>
<p># the first bit in the list is LSB<br />list&lt;bool&gt; SignificantBitsOf(unsigned char _value)</p>
<p># the first bit in the list is LSB<br />list&lt;bool&gt; SignificantBitsOf(unsigned short _value)</p>
<p># the first bit in the list is LSB<br />list&lt;bool&gt; SignificantBitsOf(unsigned int _value)</p>
<p># the first bit in the list is LSB<br />list&lt;bool&gt; SignificantBitsOf(unsigned long long _value)</p>
<p># the first bit in the list is MSB<br />list&lt;bool&gt; SignificantBitsOfR(unsigned char _value)</p>
<p># the first bit in the list is MSB<br />list&lt;bool&gt; SignificantBitsOfR(unsigned short _value)</p>
<p># the first bit in the list is MSB<br />list&lt;bool&gt; SignificantBitsOfR(unsigned int _value)</p>
<p># the first bit in the list is MSB<br />list&lt;bool&gt; SignificantBitsOfR(unsigned long long _value)</p>
<p>-----------------------------------------------------------------------------------------</p>
<p id="byte_operations" style="color:rgb(100, 100, 255);"><b>byte_operations.cpp:</b></p>
<p>(!) the functionality in this file is located in namespace 'byte_operations'</p>
<p># (!) byte index '0' specifies the least significant byte</p>
<p>enum Endianity = LE | BE</p>
<p># _index = 0..1 -&gt;<br />unsigned char ByteOf(unsigned short _value, int _index)</p>
<p># _index = 0..3 -&gt;<br />unsigned char ByteOf(unsigned int _value, int _index)</p>
<p># _index = 0..7 -&gt;<br />unsigned char ByteOf(unsigned long long _value, int _index)</p>
<p># (!) always returns 2 bytes (not just the significant bytes)<br /># (!) the first byte in the list is LSB<br />list&lt;unsigned char&gt; BytesOf(unsigned short _value)</p>
<p># (!) always returns 4 bytes (not just the significant bytes)<br /># (!) the first byte in the list is LSB<br />list&lt;unsigned char&gt; BytesOf(unsigned int _value)</p>
<p># (!) always returns 8 bytes (not just the significant bytes)<br /># (!) the first byte in the list is LSB<br />list&lt;unsigned char&gt; BytesOf(unsigned long long _value)</p>
<p># if _endianity has value 'LE' then 'a' is the least significant byte,<br /> respectively if _endianity has value 'BE' then 'a' is the most significant byte #<br />unsigned short _16(unsigned char a, unsigned char b, Endianity _endianity)</p>
<p># if _endianity has value 'LE' then 'a' is the least significant byte and 'd' is the most significant byte,<br /> respectively if _endianity has value 'BE' then 'a' is the most significant byte and 'd' is the least significant byte #<br />unsigned int _32(unsigned char a, unsigned char b, unsigned char c, unsigned char d, Endianity _endianity)</p>
<p># _low (low1, high1) + _high (low2, high2) =&gt; unsigned int { high2, low2, high1, low1 }, where 'high1' is the high byte of the result<br />unsigned int _32(unsigned short _low, unsigned short _high)</p>
<p># if _endianity has value 'LE' then 'a' is the least significant byte and 'h' is the most significant byte,<br /> respectively if _endianity has value 'BE' then 'a' is the most significant byte and 'h' is the least significant byte #<br />unsigned long long _64(unsigned char a, unsigned char b, unsigned char c, unsigned char d, unsigned char e, unsigned char f, unsigned char g, unsigned char h, Endianity _endianity)</p>
<p># _low (low1...high2) + _high (low2...high2) =&gt; unsigned long long { high2...low2, high1...low1 }, where 'high2' is the high byte of the result<br />unsigned long long _64(unsigned int _low, unsigned int _high)</p>
<p>-----------------------------------------------------------------------------------------</p>
<p id="unicode" style="color:rgb(100, 100, 255);"><b>unicode.cpp:</b></p>
<p>(!) the functionality in this file is located in namespace 'unicode'</p>
<p>PSEUDONYMS:</p>
<p># code unit of UTF-8<br />utf8 = unsigned char</p>
<p># code unit of UTF-16<br />utf16 = unsigned short</p>
<p># code unit of UTF-32<br />utf32 = unsigned int</p>
<p># Unicode code point<br />CodePoint = unsigned int</p>
<p># CONSTANTS:</p>
<p>list&lt;unsigned char&gt; UTF8_BOM = [0b11101111, 0b10111011, 0b10111111]</p>
<p>list&lt;unsigned char&gt; UTF16LE_BOM = [0b11111111, 0b11111110]</p>
<p>list&lt;unsigned char&gt; UTF16BE_BOM = [0b11111110, 0b11111111]</p>
<p>list&lt;unsigned char&gt; UTF32LE_BOM = [0b11111111, 0b11111110, 0b00000000, 0b00000000]</p>
<p>list&lt;unsigned char&gt; UTF32BE_BOM = [0b00000000, 0b00000000, 0b11111110, 0b11111111]</p>
<p>int UTF8_CODE_UNIT_LENGTH = 1 # in bytes</p>
<p>int UTF16_CODE_UNIT_LENGTH = 2 # in bytes</p>
<p>int UTF32_CODE_UNIT_LENGTH = 4 # in bytes</p>
<p>Range&lt;unsigned short&gt; HIGH_SURROGATES = (55296, 56319)</p>
<p>Range&lt;unsigned short&gt; LOW_SURROGATES = (56320, 57343)</p>
<p>const int BMP_BEGIN = 0</p>
<p>const int BMP_END = 65535</p>
<p>const int SMP_BEGIN = 65536</p>
<p>const int SMP_END = 131071</p>
<p>const int SIP_BEGIN = 131072</p>
<p>const int SIP_END = 196607</p>
<p>const int SSP_BEGIN = 917504</p>
<p>const int SSP_END = 983039</p>
<p># (Private Use Area) begin<br />const int PUA1_BEGIN = 57344;</p>
<p># (Private Use Area) end<br />const int PUA1_END = 63743;</p>
<p># (Supplementary Private Use Area-A) begin<br />const int PUA2_BEGIN = 983040;</p>
<p># (Supplementary Private Use Area-A) end<br />const int PUA2_END = 1048573;</p>
<p># (Supplementary Private Use Area-B) begin<br />const int PUA3_BEGIN = 1048576;</p>
<p># (Supplementary Private Use Area-B) end<br />const int PUA3_END = 1114109;</p>
<p>const Range ARABIC_DIGITS = (48, 57)</p>
<p># determines if the code point is an arabic digit<br />bool IsDigit(CodePoint _character)</p>
<p># determines if the code point is whitespace character (characters with property WS/WSpace/White_Space = Yes)<br />bool IsWhitespace(CodePoint _character)</p>
<p>bool IsHighSurrogate(utf16 _codeUnit)</p>
<p>bool IsLowSurrogate(utf16 _codeUnit)</p>
<p># determines if the code point is part of Basic Multilingual Plane (it doesn't include the surrogate range)<br />bool IsBMP(CodePoint _codePoint)</p>
<p># determines if the code point is part of Supplementary Multilingual Plane<br />bool IsSMP(CodePoint _codePoint)</p>
<p># determines if the code point is part of Supplementary Ideographic Plane<br />bool IsSIP(CodePoint _codePoint)</p>
<p># determines if the code point is part of Supplementary Special-purpose Plane<br />bool IsSSP(CodePoint _codePoint)</p>
<p># determines if the code point is part of Private Use Area<br />bool IsPUA(CodePoint _codePoint)</p>
<p># determines if the code point is part of (Supplementary Private Use Area-A)<br />bool IsPUA2(CodePoint _codePoint)</p>
<p># determines if the code point is part of (Supplementary Private Use Area-B)<br />bool IsPUA3(CodePoint _codePoint)</p>
<p># returns (high surrogate, low surrogate)<br /># _codePoint is not a code point from BMP -&gt;<br />t2&lt;utf16, utf16&gt; GetSurrogatePair(CodePoint _codePoint)</p>
<p># the parameters rerpesents UTF-8 character that is part of BMP -&gt;<br />utf16 ToUTF16(unsigned char _high, unsigned char _low)</p>
<p># the parameters represent UTF-8 character that is part of BMP -&gt;<br />utf16 ToUTF16(unsigned char _high, unsigned char _lowa, unsigned char _lowb)</p>
<p># returns a single UTF-8 character<br /># _codeUnit represent a BMP code point -&gt;<br />list&lt;utf8&gt; ToUTF8(utf16 _codeUnit)</p>
<p># returns a single UTF-8 character<br /># the parameters represent a valid surrogate pair -&gt;<br />list&lt;utf8&gt; ToUTF8(utf16 _highSurrogate, utf16 _lowSurrogate)</p>
<p># returns a single UTF-8 character<br /># _codePoint represent a valid Unicode code point -&gt;<br />list&lt;utf8&gt; ToUTF8(CodePoint _codePoint)</p>
<p># the parameters represent UTF-8 character that is part of BMP -&gt;<br />utf32 ToUTF32(unsigned char _high, unsigned char _lowa)</p>
<p># the parameters represent UTF-8 character that is part of BMP -&gt;<br />utf32 ToUTF32(unsigned char _high, unsigned char _lowa, unsigned char _lowb)</p>
<p># the parameters represent UTF-8 character that is not part of BMP -&gt;<br />utf32 ToUTF32(unsigned char _high, unsigned char _lowa, unsigned char _lowb, unsigned char _lowc)</p>
<p># the parameters represent a valid surrogate pair -&gt;<br />utf32 ToUTF32(utf16 _highSurrogate, utf16 _lowSurrogate)</p>
<p># (SYNONYM:ToUTF32)<br /># the parameters represent UTF-8 character that is part of BMP -&gt;<br />CodePoint ToCodePoint(unsigned char _high, unsigned char _lowa)</p>
<p># (SYNONYM:ToUTF32)<br /># the parameters represent UTF-8 character that is not part of BMP -&gt;<br />CodePoint ToCodePoint(unsigned char _high, unsigned char _lowa, unsigned char _lowb)</p>
<p># (SYNONYM:ToUTF32)<br /># the parameters represent UTF-8 character that is not part of BMP -&gt;<br />utf32 ToCodePoint(unsigned char _high, unsigned char _lowa, unsigned char _lowb, unsigned char _lowc)</p>
<p># (SYNONYM:ToUTF32)<br /># the parameters represent a valid UTF-8 sequence -&gt;<br />utf32 ToCodePoint(utf16 _highSurrogate, utf16 _lowSurrogate)</p>
<p>-----------------------------------------------------------------------------------------</p>
<p id="time" style="color:rgb(100, 100, 255);"><b>time.cpp:</b></p>
<p>(!) the functionality in this file is located in namespace 'time_'</p>
<p># TYPES:</p>
<p>TimeUnit = MILLISECONDS | SECOND</p>
<p>struct DateTime:</p>
<p># CONSTRUCTORS:</p>
<p>DateTime() = default</p>
<p>DateTime(int _day, int _month, int _year, int _hour, int _minute, int _second, int _timezone_ = 0)</p>
<p>DateTime(const DateTime&amp;) = default</p>
<p># OPERATORS:</p>
<p>DateTime&amp; operator=(const DateTime&amp;) = default</p>
<p>bool operator==(const DateTime&amp; _datetime) const</p>
<p>bool operator!=(const DateTime&amp; _datetime) const</p>
<p># FIELDS:</p>
<p>int year() const</p>
<p>int month() const</p>
<p>int day() const</p>
<p>int hour() const</p>
<p>int minute() const</p>
<p>int second() const</p>
<p>int timezone() const</p>
<p># FUNCTIONS:</p>
<p># 23-5-2009 09:51:07 +3 -&gt; ToTimezone(7) =&gt; 23-5-2009 13:51:07 7<br /> # 23-5-2009 09:51:07 +3 -&gt; ToTimezone(-8) =&gt; 22-5-2009 22:51:07 -8<br /> # _timezone_ &gt;= -11 &amp; _timezone_ &lt;= 14 -&gt;<br /> void ToTimezone(int _timezone_)</p>
<p>bool IsAfter(const DateTime&amp; _datetime) const</p>
<p>bool IsBefore(const DateTime&amp; _datetime) const</p>
<p># CONSTANTS:</p>
<p>long SECONDS_IN_AN_HOUR = 3600</p>
<p>long SECONDS_IN_A_DAY = 86400</p>
<p>long MINUTES_IN_A_DAY = 1440</p>
<p># FUNCTIONS:</p>
<p>int DayOfYear(const DateTime&amp; _datetime)</p>
<p># number of seconds since 01.01.1970 00:00:00 UTC<br />long long Elapsed()</p>
<p># returns the number of seconds between _datetime and _datetime_<br /># _datetime and/or _datetime_ is not valid =&gt; -1<br />unsigned long long IntervalOf(const DateTime&amp; _datetime, const DateTime&amp; _datetime_)</p>
<p># _year &gt;= 1 -&gt;<br />bool IsLeap(int _year)</p>
<p>bool IsValidDateTime(const DateTime&amp; _datetime)</p>
<p># =&gt; UTC<br />DateTime Now()</p>
<p>-----------------------------------------------------------------------------------------</p>
<p id="filesystem" style="color:rgb(100, 100, 255);"><b>filesystem.cpp:</b></p>
<p>(!) the functionality in this file is located in namespace 'filesystem'</p>
<p># Errors:<br />const char E_UNSUCCESSFUL_OPERATION = -1<br />const char E_UNKNOWN_ERROR = -2<br />const char E_FILE_DOES_NOT_EXIST = -3<br />const char E_DIRECTORY_DOES_NOT_EXIST = -4<br />const char E_SOURCE_DIRECTORY_DOES_NOT_EXIST = -5<br />const char E_DESTINATION_DIRECTORY_DOES_NOT_EXIST = -6<br />const char E_FILE_ALREADY_EXISTS = -7<br />const char E_DIRECTORY_ALREADY_EXISTS = -8<br />const char E_INVALID_PATH = -9<br />const char E_INVALID_SOURCE_PATH = -10<br />const char E_INVALID_DESTINATION_PATH = -11<br />const char E_NAME_CONTAINS_INVALID_CHARACTERS = -12<br />const char E_NAME_HAS_INVALID_VALUE = -13<br />const char E_NAME_ENDS_WITH_EMPTY_SPACE = -14<br />const char E_EMPTY_NAME = -15<br />const char E_FILENAME_CONTAINS_INVALID_CHARACTERS = -16<br />const char E_FILENAME_ENDS_WITH_EMPTY_SPACE = -17<br />const char E_EMPTY_FILENAME = -18<br />const char E_FILE_EXTENSION_CONTAINS_INVALID_CHARACTERS = -19<br />const char E_FILE_NOT_BOUND = -20<br />const char E_READONLY_FILE = -21<br />const char E_ACCESS_DENIED = -22<br />const char E_SYSTEM_FILE_MANIPULATION_ATTEMPT = -23<br />const char E_SYSTEM_DIRECTORY_MANIPULATION_ATTEMPT = -24<br />const char E_INDEX_OUT_OF_RANGE = -25<br />const char E_FIRST_INDEX_LARGER_THAN_SECOND_INDEX = -26</p>
<p>const list&lt;CodePoint&gt; INVALID_NAME_CHARACTERS = [0, '.', ':', '/', '\\', '*', '?', '"', '&lt;', '&gt;', '|']</p>
<p>const list&lt;string&gt; INVALID_NAME_VALUES = ["CON", "PRN", "AUX", "NUL", "COM1", "COM2", "COM3", "COM4", "COM5",<br /> "COM6", "COM7", "COM8", "COM9", "LPT1", "LPT2", "LPT3", "LPT4", "LPT5", "LPT6", "LPT7", "LPT8", "LPT9"]</p>
<p># "" =&gt; E_EMPTY_NAME<br /># "ocea:n" =&gt; E_NAME_CONTAINS_INVALID_CHARACTERS<br /># "LPT3" =&gt; E_NAME_HAS_FORBIDDEN_VALUE<br /># " " =&gt; E_NAME_ENDS_WITH_EMPTY_SPACE;<br /># "ocean " =&gt; E_NAME_ENDS_WITH_EMPTY_SPACE;<br /># _name is a valid name =&gt; 0<br />int IsValidName(const string&amp; _name)</p>
<p># ".jpeg" =&gt; E_EMPTY_NAME<br /># " .jpeg" =&gt; E_NAME_ENDS_WITH_EMPTY_SPACE<br /># "ocean" =&gt; E_MISSING_EXTENSION<br /># "ocea:n.jpeg" =&gt; E_FILENAME_CONTAINS_INVALID_CHARACTERS<br /># "ocean.jpeg " =&gt; E_FILENAME_ENDS_WITH_EMPTY_SPACE<br /># "ocean.jpeg" =&gt; 0<br /># "ocean." =&gt; 0<br /># _filename is a valid filename =&gt; 0<br />int IsValidFilename(const string&amp; _filename)</p>
<p># "" =&gt; E_EMPTY_PATH<br /># "Es\pictures\travels" =&gt; E_INVALID_ROOT_ELEMENT<br /># "E:\pictures\travels \" =&gt; E_MISSING_FINAL_ELEMENT<br /># "E:\pictures\travels \desert" =&gt; E_PATH_ELEMENT_ENDS_WITH_EMPTY_SPACE<br /># "E:\pictures\fo:rest" =&gt; E_PATH_CONTAINS_INVALID_CHARACTERS<br /># "E:\pictures\travels\desert" =&gt; 0<br /># _path is a valid directory path =&gt; 0<br />int IsValidDirectoryPath(const string&amp; _path)</p>
<p># "" =&gt; E_EMPTY_PATH<br /># "Es\pictures\travels \291.jpg" =&gt; E_INVALID_ROOT_ELEMENT<br /># "E:\pictures\travels \" =&gt; E_MISSING_FINAL_ELEMENT<br /># "E:\pictures\travels \291.jpg" =&gt; E_PATH_ELEMENT_ENDS_WITH_EMPTY_SPACE<br /># "E:\pictures\travels\291.jpg" =&gt; 0<br /># _path is a valid file path =&gt; 0<br />int IsValidFilePath(const string&amp; _path)</p>
<p># _path is syntactically valid path -&gt;<br />bool IsFilePath(const string&amp; _path)</p>
<p># _path is syntactically valid path -&gt;<br />bool IsDirectoryPath(const string&amp; _path)</p>
<p># "D:\images\forest.bmp" =&gt; "forest.bmp"<br /># _path is syntactically valid path -&gt;<br />string FilenameOf(const string&amp; _path)</p>
<p># "D:\images\forest.bmp" =&gt; "forest"<br /># _path is syntactically valid path -&gt;<br />string NameOf(const string&amp; _path)</p>
<p># "a.jpg" =&gt; "jpg"<br /># _filepath is syntactically valid file path -&gt;<br />string ExtensionOf(const string&amp; _filepath)</p>
<p># "C:\contents\images" =&gt; "C:\contents"<br /># _path is syntactically valid path -&gt;<br />string ParentDirectoryOf(const string&amp; _path)</p>
<p># (!) this type is used to (conveniently read or mutate) files without making a copy of the file in RAM, ofcourse at the expense of<br /> performance (due to writing/reading to/from the permanent storage)<br /> (!) an instance of this type is always associated with the same physical file, i.e. with the same 'path'<br /> (!) member function Close() dissociate the object from the physical file; it is automatically invoked on destruction of the object (i.e.<br /> when the t:File object goes out of scope); if we want to release the physical file before the destruction of the object we need to<br /> call Close() explicitly; when calling Close() explicitly no other operations should be performed on the object afterwards #<br />struct File:</p>
<p># VARIABLES:</p>
<p>TraversalMode TraversalMode = TraversalMode::BOUNDED</p>
<p># CONSTRUCTORS:</p>
<p>File() = default</p>
<p># if the file is successfully opened then &amp;Path and &amp;Name will have a set value<br /> # _path is ASCII value -&gt;<br /> explicit File(const string&amp; _path)</p>
<p>File(const File&amp;) = delete</p>
<p># OPERATORS:</p>
<p># if the function returns UNSUCCESSFUL_OPERATION then it is recommended to check field &amp;os_<br /> # _index is in the range of file -&gt;<br /> unsigned char operator[](int _index)</p>
<p># if the function returns UNSUCCESSFUL_OPERATION then it is recommended to check field &amp;os_<br /> # _index is in the range of file -&gt;<br /> unsigned char operator[](int _index) const</p>
<p># assignment is performed only on uncostructed object, i.e. if *this is not associated with a physical file<br /> # after the operation is completed the old object becomes invalid<br /> # field &amp;os is not copied<br /> File&amp; operator=(const File&amp; _file)</p>
<p># FIELDS:</p>
<p>int size() const</p>
<p>int position() const</p>
<p>const string&amp; path() const</p>
<p>const string&amp; name() const</p>
<p>const string&amp; extension() const</p>
<p>char os_() const</p>
<p># OTHER FUNCTIONS:</p>
<p>bool IsBound() const</p>
<p>void Close()</p>
<p># TRAVERSAL FUNCTIONS:</p>
<p>bool can_reverse() const</p>
<p>bool can_advance() const</p>
<p># traversalMode() == BOUNDED &amp;&amp; position() - _value &lt; 0 &gt;&gt; position() = position()<br /> # traversalMode() == BOUNDED &amp;&amp; position() - _value &gt; -1 &gt;&gt; position() = position() - _value<br /> # traversalMode() == CIRCULAR -&gt; circular addition; (EXAMPLE) size() = 19, position() = 4, back(9) &gt;&gt; position() = 14<br /> File&amp; back()</p>
<p># traversalMode() == BOUNDED &amp;&amp; position() + _value &gt;= size() &gt;&gt; position() = position()<br /> # traversalMode() == BOUNDED &amp;&amp; position() + _value &lt; size() - 1 &gt;&gt; position() = position() + _value<br /> # traversalMode() == CIRCULAR -&gt; circular addition; (EXAMPLE) size() = 21, position() = 16, advance(10) &gt;&gt; position() = 5<br /> File&amp; advance()</p>
<p># position() &gt; 0 =&gt; [position() - 1]<br /> # traversalMode() == BOUNDED &amp;&amp; position() == 0 =&gt; [0]<br /> # traversalMode() == CIRCULAR &amp;&amp; position() == 0 =&gt; [size() - 1]<br /> unsigned char previous() const</p>
<p># size() &gt; 0 -&gt;<br /> unsigned char current() const</p>
<p># position() &lt; size() - 1 =&gt; [position() + 1]<br /> # traversalMode() == BOUNDED &amp;&amp; position() == size() - 1 =&gt; [position()]<br /> # traversalMode() == CIRCULAR &amp;&amp; position() == size() - 1 =&gt; [0]<br /> unsigned char next() const</p>
<p># _position &lt; -1 || _possition &gt; size() - 1 =&gt; -1<br /> int set_position(int _position)</p>
<p># NON-MUTATING FUNCTIONS:</p>
<p>bool BeginsWith(const list&lt;unsigned char&gt;&amp; _value) const</p>
<p>bool Contains(unsigned char _value) const</p>
<p># [1, 2, 3, 4, 5, 6, 7, 8, 9].Contains([2, 3, 4]) =&gt; true<br /> bool Contains(const list&lt;unsigned char&gt;&amp; _value) const</p>
<p>bool Contains(std::function&lt;bool(unsigned char)&gt; _predicate) const</p>
<p>bool EndsWith(const list&lt;unsigned char&gt;&amp; _value) const</p>
<p># the specified value does not exist =&gt; -1<br /> int IndexOf(unsigned char _value, int _begin = 0) const</p>
<p># the specified value does not exist =&gt; -1<br /> int IndexOf(const list&lt;unsigned char&gt;&amp; _value, int _begin = 0) const</p>
<p># the specified value does not exist or _begin is outside the range of list =&gt; -1<br /> int IndexOf(std::function&lt;bool(unsigned char)&gt; _predicate, int _begin = 0) const</p>
<p># the specified value does not exist =&gt; -1<br /> int LastIndexOf(unsigned char _value) const</p>
<p># the specified value does not exist =&gt; -1<br /> int LastIndexOf(const list&lt;unsigned char&gt;&amp; _value) const</p>
<p># the specified value does not exist =&gt; -1<br /> int LastIndexOf(std::function&lt;bool(unsigned char)&gt; _predicate) const</p>
<p># buffered read-operation; reads a block at the current position<br /> # _size + position() &lt; (size() + 1) -&gt;<br /> void ReadBlock(unsigned char* _array, int _size, bool _advancePosition) const</p>
<p># position() + 1 &lt; (size() + 1) -&gt;<br /> unsigned char ReadI8(bool _advancePosition) const</p>
<p># (!) _endianity is the endianity of the source-integral<br /> # reads a 16-bit unsigned integral value at the current position<br /> # position() + 2 &lt; (size() + 1) -&gt;<br /> unsigned short ReadI16(Endianity _endianity, bool _advancePosition) const</p>
<p># (!) _endianity is the endianity of the source-integral<br /> # reads a 32-bit unsigned integral value at the current position<br /> # position() + 4 &lt; (size() + 1) -&gt;<br /> unsigned int ReadI32(Endianity _endianity, bool _advancePosition) const</p>
<p># _length = 0 =&gt; [_begin..]<br /> # (_begin + _length) &gt;= size() =&gt; []<br /> list&lt;unsigned char&gt; Sublist(int _begin, int _length = 0) const</p>
<p># [5, 8, 4, 1, 9, 6, 2, 3, 0, 5, 5, 1, 7].Subrange(2, 5) =&gt; [4, 1, 9, 6]<br /> list&lt;unsigned char&gt; Subrange(int _begin, int _end) const</p>
<p># MUTATION FUNCTIONS:</p>
<p>File&amp; Append(unsigned char _value)</p>
<p>File&amp; Append(const list&lt;unsigned char&gt;&amp; _value)</p>
<p>File&amp; Append(const unsigned char* _value, int _length)</p>
<p>File&amp; Clear()</p>
<p># (size() &gt; 0 &amp;&amp; _index &gt; 0 &amp;&amp; (_index &lt;= size())) =&gt;<br /> File&amp; Insert(unsigned char _value, int _index)</p>
<p># (size() &gt; 0 &amp;&amp; _index &gt; 0 &amp;&amp; (_index &lt;= size())) =&gt;<br /> File&amp; Insert(const list&lt;unsigned char&gt;&amp; _list, int _index)</p>
<p>File&amp; RemoveAt(int _index, int _length = 1)</p>
<p>File&amp; Remove(int _begin, int _end)</p>
<p>File&amp; SetAt(int _index, unsigned char _value)</p>
<p># _index1 &lt;= _index2 -&gt;<br /> File&amp; Swap(int _index1, int _index2)</p>
<p># buffered write-operation; overwrites the block at the current position; if the current position is at the end of the file then it appends data<br /> # (!) it cannot insert data<br /> # _size + position() &lt; (size() + 1) -&gt;<br /> File&amp; WriteBlock(const unsigned char* _array, int _size, bool _advancePosition)</p>
<p># (!) _endianity is the endianity of the source-integral<br /> # writes a 16-bit unsigned integral value ath the current position<br /> # position() + 2 &lt; (size() + 1) -&gt;<br /> File&amp; WriteI16(unsigned short _value, Endianity _endianity, bool _advancePosition)</p>
<p># (!) _endianity is the endianity of the source-integral<br /> # writes a 32-bit unsigned integral value at the current position<br /> # position() + 4 &lt; (size() + 1) -&gt;<br /> File&amp; WriteI32(unsigned int _value, Endianity _endianity, bool _advancePosition)</p>
<p># if the directory exists then &amp;Path and &amp;Name will have a set value<br />struct Directory:</p>
<p># CONSTRUCTORS:</p>
<p>Directory() = default</p>
<p>explicit Directory(const string&amp; _path)</p>
<p>Directory(const Directory&amp;) = delete</p>
<p>Directory&amp; operator=(const Directory&amp;) = default</p>
<p># OPERATORS:</p>
<p>bool operator==(const Directory&amp; _directory) const</p>
<p>bool operator!=(const Directory&amp; _directory) const</p>
<p>const string &amp;path() const</p>
<p>const string &amp;name() const</p>
<p># returns the paths of all subdirectories in the specified directory<br /># (!) shows the hidden directories as well<br /># the specified directory exists and can be accessed -&gt;<br />list&lt;string&gt; DirectoriesOf(const string&amp; _directoryPath)</p>
<p># returns the filepaths of all files in the specified directory<br /># (!) shows the hidden files as well<br /># the specified directory exists and can be accessed -&gt;<br />list&lt;string&gt; FilesOf(const string&amp; _directoryPath)</p>
<p># (!) returns false if _path specifies a system file<br />bool FileExists(const string&amp; _path)</p>
<p>bool DirectoryExists(const string&amp; _path)</p>
<p># the specified file exists -&gt;<br />int SizeOf(const string&amp; _path)</p>
<p># the specified file/directory exists -&gt;<br />bool IsEncrypted(const string&amp; _path)</p>
<p># the specified file/directory exists -&gt;<br />bool IsHidden(const string&amp; _path)</p>
<p># the specified file/directory exists -&gt;<br />bool IsReadOnly(const string&amp; _path)</p>
<p># the specified file/directory exists -&gt;<br />bool IsSystem(const string&amp; _path)</p>
<p># the specified file/directory exists -&gt;<br />time_::DateTime GetCreationTime(const string&amp; _path)</p>
<p># the specified file/directory exists -&gt;<br />time_::DateTime GetLastAccessTime(const string&amp; _path)</p>
<p># the specified file/directory exists -&gt;<br />time_::DateTime GetLastMutationTime(const string&amp; _path)</p>
<p># returns 0 on successful execution<br />int CreateFile(const string&amp; _path)</p>
<p># returns 0 on successful execution<br />int CreateDirectory(const string&amp; _path)</p>
<p># returns 0 on successful execution<br />int RenameFile(const string&amp; _filepath, const string&amp; _newFilename)</p>
<p># returns 0 on successful execution<br />int RenameDirectory(const string&amp; _path, const string&amp; _newName)</p>
<p># returns 0 on successful execution<br /># _sourcePath specifies the copied file<br /># _destinationPath specifies the directory in which the file should be copied<br />int CopyFile(const string&amp; _sourcePath, const string&amp; _destinationPath)</p>
<p># returns 0 on successful execution<br /># _sourcePath specifies the copied directory<br /># _destinationPath specifies the directory in which the directory should be copied<br />int CopyDirectory(const string&amp; _sourcePath, const string&amp; _destinationPath)</p>
<p># returns 0 on successful execution<br />int DeleteFile(const string&amp; _path)</p>
<p># returns 0 on successful execution<br />int DeleteDirectory(const string&amp; _path)</p>
<p># error =&gt; ""<br />string GetApplicationDirectory()</p>
<p>-----------------------------------------------------------------------------------------</p>
<p id="event" style="color:rgb(100, 100, 255);"><b>event.cpp:</b></p>
<p>template&lt;typename... args&gt; struct event:</p>
<p># CONSTRUCTORS:</p>
<p>event() = default</p>
<p># OPERATORS:</p>
<p>event&amp; operator=(const event&amp;) = default</p>
<p># adds a subscriber to the list of subscribers<br /> void operator+= (void(*_subscriber)(args...))</p>
<p># notifies each subscriber when the event occurs<br /> void operator()(args... _parameters) const</p>
<p># FIELDS:</p>
<p>const list&lt;void(*)(args...)&gt;&amp; subscribers() const</p>
<p>-----------------------------------------------------------------------------------------</p>
<p id="timer" style="color:rgb(100, 100, 255);"><b>timer.cpp:</b></p>
<p>struct Timer:</p>
<p># CONSTRUCTORS:</p>
<p>Timer() = default</p>
<p># the interval is set in microseconds<br /> # _repeat specifies whether the period is repeated after the previous one ends<br /> # _data is an optional data<br /> Timer(int _interval, bool _repeat, void* _data = nullptr)</p>
<p>Timer(const Timer&amp;) = delete</p>
<p># OPERATORS:</p>
<p>Timer&amp; operator=(const Timer&amp;) = delete</p>
<p># FIELDS:</p>
<p>bool Repeat = false</p>
<p>event&lt;Timer*, void*&gt; OnTick</p>
<p>int interval()</p>
<p># FUNCTIONS:</p>
<p>bool IsRunning()</p>
<p>void Restart()</p>
<p>void Start()</p>
<p>void Stop()</p>
<p>-----------------------------------------------------------------------------------------</p>
<p id="chronometer" style="color:rgb(100, 100, 255);"><b>chronometer.cpp:</b></p>
<p># Chronometer c -&gt; [computations -&gt; c.Elapsed() | c.Reset()]<br /># c.Running -&gt; Elapsed() =&gt; &gt; -1<br /># !c.Running -&gt; Elapsed() =&gt; -1<br />struct Chronometer</p>
<p># CONSTRUCTORS:</p>
<p>Chronometer() = default</p>
<p>Chronometer(const Chronometer&amp;) = delete</p>
<p># OPERATORS:</p>
<p>Chronometer&amp; operator=(const Chronometer&amp;) = delete</p>
<p># FIELDS:</p>
<p># FUNCTIONS:</p>
<p># in microseconds<br /> int Elapsed() const</p>
<p>bool IsRunning() const</p>
<p>void Start()</p>
<p>void Reset()</p>
</div>