!!! this document describes the public interface of the library

Index:

array.cpp - line 26
pair.cpp - line 207
tuple.cpp - line 235
range.cpp - line 1100
stack.cpp - line 1205
queue.cpp - line 1253
list.cpp - line 1303
string.cpp - line 1817
numeric.cpp - line 2526
bit_operations.cpp - line 2679
byte_operations.cpp - line 2848
unicode.cpp - line 2900
time.cpp - line 3990
filesystem.cpp - line 4093
event.cpp - line 4488
timer.cpp - line 4512
chronometer.cpp - line 4551
geometry.cpp - line 4582

-----------------------------------------------------------------------------------------

array.cpp:

struct array:
    # FIELDS:
    T* pointer
    int length

struct range:
    # FIELDS:
    int begin
    int end

# NON-MUTATING FUNCTIONS:

# _length specifies the length of _array
# _length_ specifies the length of _value
template<typename T> bool beginsWith(const T* _array, int _length, const T* _value, int _length_)

# _length specifies the length of _array
# _length_ specifies the length of _value
template<typename T> bool endsWith(const T* _array, int _length, const T* _value, int _length_)

# _length specifies the length of _array
template<typename T> bool contains(const T* const _array, int _length, T _value)

# _length specifies the length of _array
# _length_ specifies the length of _value
template<typename T> bool contains(const T* const _array, int _length, const T* const _value, int _length_)

# _length specifies the length of _array
# except([2, 9, 0, 1, 4, 9, 7, 3], 8, 9) => [2, 0, 1, 4, 7, 3]
template<typename T> array except(const T* const _array, int _length, T _value)

# _length is the length of _array
# _length_ is the length of _set
# except([2, 9, 0, 1, 4, 9, 7, 3], [9, 7, 0], 8, 3) => array([2, 1, 4, 3], 4)
template<typename T> array<T> except(const T* _array, const T* _set, int _length, int _length_)

# _length1 specifies the length of _array1
# _length2 specifies the length of _array2
# equality(nullptr, nullptr, x, x) => true
# equality([5, 0, 9], [5, 0, 9, 5], 3, 4) => false
# equality([5, 0, 9], [6, 4, 1], 3, 3) => false
# equality([5, 0, 9], [5, 9, 0], 3, 3) => false
# equality([5, 0, 9], [5, 0, 9], 3, 3) => true
template<typename T> bool equality(const T* const _array1, const T* const _array2, int _length1, int _length2)

# _length specifies the length of _array
# the specified value does not exist => -1
template<typename T> int indexOf(const T* const _array, int _length, T _value)

# _length1 specifies the length of _array1
# _length2 specifies the length of _array2
# _value2 does not exist in _value1 or _begin is outside the range of list => -1
template<typename T> int indexOf(const T* _array1, const T* _array2, int _length1, int _length2, int _begin)

# _length specifies the length of _array
# indexOfNot([9, 9, 9, 5, 8, 10, 2, 7], 8, 9) => 3
# indexOfNot([9, 9, 9, 5, 8, 10, 2, 7], 8, 4) => 0
template<typename T> int indexOfNot(const T* const _array, int _length, T _value)

# _length specifies the length of _array
template<typename T> bool isHeterogenous(const T* const _array, int _length)

# _length specifies the length of _array
template<typename T> bool isHomogenous(const T* const _array, int _length)

# _length specifies the length of _array
# the specified value does not exist => -1
template<typename T> int lastIndexOf(const T* const _array, int _length, T _value)

# return the maximum element in the range (begin, end)
# _length == 0 => nullptr
# <T> implements operator '>' or it is a primitive numerical type ->
template<typename T> const T* max_(const T* _array, int _length, int _begin, int _end)

# return the minimum element in the range (begin, end)
# _length == 0 => nullptr
# <T> implements operator '>' or it is a primitive numerical type ->
template<typename T> const T* min_(const T* _array, int _length, int _begin, int _end)

# returns the range of a sequence consisting of certain set of values (it is not mandatory for the sequence to contain each value in the set)
# _length specifies the length of _array
# _length_ specifies the length of _set
# [3, 10, 15, 12, 8, 5, 7, 5, 5, 7, 7, 3, 9].RangeOf([2, 5, 7]) => (5, 10)
# [3, 10, 15, 12, 8, 5, 7, 2, 2, 7, 7, 3, 9].RangeOf([2, 5, 7]) => (5, 10)
# [3, 10, 15, 12, 0, 5, 7, 2, 2, 7, 7, 3, 9].RangeOf([4, 0, 1]) => (4, 4)
# [3, 10, 15, 12, 8, 5, 7, 2, 2, 7, 7, 3, 9].RangeOf([4, 0, 1]) => (-1, -1)
template<typename T> range rangeOf(const T* const _array, int _length, const T* const _set, int _length_)

# - the first two elements returned by this function are meta-markers
  - the elements between (the first two) and (the last four) elements represent (a sequence of pointer pairs where each pair
    is representing either (an empty sequence) or (non-empty sequence)); an empty sequence is indicated by (array[1], array[0])
    and non-empty sequence is indicated by (<begin-pointer>, <end-pointer>)
  - the last four elements indicate the end of the pointer array; the value of the sequence is (array[0], array[1], array[0], array[1]) #
# returns only values that are (between the beginning and a separator), (between separator and the end) or (between two separators)
# empty sequences are generated (and eventually are appended to the result) only if they are between two separators
# _length specifies the length of _array
# _ignoreEmptyValues = true -> empty sequences (if there are any) are not appended to the result
# split([3, 7, 18, 5, 19, 76, 15], 7, 353) => []
# split([18, 5, 19, 76, 15, 9, 20, 5], 8, 9) => [[18, 5, 19, 76, 15], [20, 5]]
# split([56, 3, 7, 18, 5, 19, 76, 7], 8, 7) => [[56, 3], [18, 5, 19, 76]]
# split([56, 7, 7, 18, 5, 19, 76, 15, 9], 9, 7) => [[56], [], [18, 5, 19, 76, 15, 9]]
# split([56, 7, 7, 18, 5, 19, 76, 15, 9], 9, 7) => [[56], [18, 5, 19, 76, 15, 9]]
# split([7, 41, 56, 7, 18, 76, 15, 9, 7], 9,7 ) => [[41, 56], [18, 76, 15, 9]]
# split([7, 41, 56, 7, 7, 7, 18, 5, 15], 9, 7) => [[41, 56], [], [], [18, 5, 15]]
# split([7, 41, 56, 7, 7, 7, 18, 5, 15], 9, 7, true) => [[41, 56], [18, 5, 15]]
template<typename T> T** split(T* const _array, int _length, T _separator, bool _ignoreEmptyValues = false)

# _length specifies the length of _array
template<typename T> array where(const T* const _array, int _length, const std::function<bool(T)>& _predicate)

# MUTATION FUNCTIONS:

# it copies segment (from _source to _destination) (beginning at _sourceBegin) and (with length specified by _length)
# copy("variance", "namespace", 8, 9, 2, 4, 5) >> "namerianc"
# copy("variance", "namespace", 8, 9, 2, 7, 5) >> "namespari"
# copy("variance", "namespace", 8, 9, 6, 2, 5) >> "nacespace"
template<typename T> void copy(const T* const _source, T* const _destination, int _sourceLength, int _destinationLength, int _sourceBegin,
         int _destinationBegin, int _copyLength)

# it copies segment (from _source to _destination) (beginning at_sourceBegin and ending at _sourceEnd)
# copyRange("variance", "namespace", 8, 9, 2, 4, 5) >> "namesriae"
# copyRange("variance", "namespace", 8, 9, 5, 5, 3) >> "namespace"
# copyRange("variance", "namespace", 8, 9, 5, 7, 8) >> "namespacn"
template<typename T> void copyRange(const T* const _source, T* const _destination, int _sourceLength, int _destinationLength,
int _sourceBegin, int _sourceEnd, int _destinationBegin)

# _length specifies the length of _array
# extendLeft([1, 2, 3, 4, 5], 5, 2) >> [x, x, 1, 2, 3, 4, 5]
template<typename T> void extendLeft(T*& _array, int _extensor)

# _length specifies the length of _array
# extendRight([1, 2, 3, 4, 5], 5, 2) >> [1, 2, 3, 4, 5, x, x]
template<typename T> void extendRight(T*& _array, int _extensor)

# _length specifies the length of _array
# reduceLeft([1, 2, 3, 4, 5], 5, 2) >> [3, 4, 5]
template<typename T> void reduceLeft(T*& _array, int _length, int _reducer)

# _length specifies the length of _array
# reduceRight([1, 2, 3, 4, 5], 5, 2) >> [1, 2, 3]
template<typename T> void reduceRight(T*& _array, int _length, int _reducer)

# _length specifies the length of _array
# remove([5, 8, 1, 9, 2, 4, 7], 7, 2, 3) >> [5, 8, 4, 7]
# remove([5, 8, 1, 9, 2, 4, 7], 7, 5, 3) >> [5, 8, 1, 9, 2]
template<typename T> void remove(T*& _array, int _length, int _begin, int _reducer)

# _length specifies the length of _array
template<typename T> void removeRange(chTar*& _array, int _length, int _begin, int _end)

# T = built-in integral type ->
template<typename T> void resize(T*& _array, int _currentLength, int _newLength)

# _length specifies the length of _array
template<typename T> void reverse(T*& _array, int _length)

# _length specifies the length of _array
# rotateLeft([1, 2, 3, 4, 5], 5, 5) >> [4, 5, 1, 2, 3]
void rotateLeft(T*& _array, int _length, int _positions)

# _length specifies the length of _array
# rotateRight([1, 2, 3, 4, 5], 5, 4) >> [5, 1, 2, 3, 4]
template<typename T> void rotateRight(T*& _array, int _length, int _positions)

# _length specifies the length of _array
# set([1, 2, 3, 4, 5], 5, 2, 4, 19) >> [1, 2, 19, 19, 19]
template<typename T> void set(T*& _array, int _length, int _begin, int _end, T _value)

# _length specifies the length of _array
template<typename T> void swap(T*& _array, int _length, int _i1, int _i2)

# _length specifies the length of _array
template<typename T> void trimBegin(T*& _array, int _length, T _value)

# _length specifies the length of _array
template<typename T> void trimEnd(T*& _array, int _length, T _value)

-----------------------------------------------------------------------------------------

pair.cpp:

struct<K, V> pair:

  # CONSTRUCTORS:

  pair() = default

  pair(const K& _key, const V& _value)

  pair(const pair<K, V>&) = default

  # OPERATORS:

  pair &operator=(const pair<K, V>&) = default

  bool operator==(const pair<K, V>&) const

  bool operator!=(const pair<K, V>&) const

  # FIELDS:

  const K& key() const

  const V& value() const

-----------------------------------------------------------------------------------------

tuple.cpp:

struct<T1, T2> t2:

  # CONSTRUCTORS:

  t2() = default

  t2(const T1& _e1, const T2& _e2)

  t2(const t2&) = default

  # OPERATORS:

  t2& operator=(const t2&) = default

  bool operator==(const t2&) const

  bool operator!=(const t2&) const

  # FIELDS:

  const T1& e1() const

  const T2& e2() const

struct<T1, T2, T3> t3:

  # CONSTRUCTORS:

  t3() = default

  t3(const T1& _e1, const T2& _e2, const T3& _e3)

  t3(const t3&) = default

  # OPERATORS:

  t3& operator=(const t3&) = default

  bool operator==(const t3&) const

  bool operator!=(const t3&) const

  # FIELDS:

  const T1& e1() const

  const T2& e2() const

  const T2& e3() const

struct<T1, T2, T3, T4> t4:

  # CONSTRUCTORS:

  t4() = default

  t4(const T1& _e1, const T2& _e2, const T3& _e3, const T4& _e4)

  t4(const t4&) = default

  # OPERATORS:

  t4& operator=(const t4&) = default

  bool operator==(const t4&) const

  bool operator!=(const t4&) const

  # FIELDS:

  const T1& e1() const

  const T2& e2() const

  const T3& e3() const

  const T4& e4() const

struct<T1, T2, T3, T4, T5> t5:

  # CONSTRUCTORS:

  t5() = default

  t5(const T1& _e1, const T2& _e2, const T3& _e3, const T4& _e4, const T5& _e5)

  t5(const t5&) = default

  # OPERATORS:

  t5& operator=(const t5&) = default

  bool operator==(const t5&) const

  bool operator!=(const t5&) const

  # FIELDS:

  const T1& e1() const

  const T2& e2() const

  const T3& e3() const

  const T4& e4() const

  const T5& e5() const

struct<T1, T2, T3, T4, T5, T6> t6:

  # CONSTRUCTORS:

  t6() = default

  t6(const T1& _e1, const T2& _e2, const T3& _e3, const T4& _e4, const T5& _e5, const T6& _e6)

  t6(const t6&) = default

  # OPERATORS:

  t6& operator=(const t6&) = default

  bool operator==(const t6&) const

  bool operator!=(const t6&) const

  # FIELDS:

  const T1& e1() const

  const T2& e2() const

  const T3& e3() const

  const T4& e4() const

  const T5& e5() const

  const T6& e6() const

struct<T1, T2, T3, T4, T5, T6, T7> t7:

  # CONSTRUCTORS:

  t7() = default

  t7(const T1& _e1, const T2& _e2, const T3& _e3, const T4& _e4, const T5& _e5, const T6& _e6, const T7& _e7)

  t7(const t7&) = default

  # OPERATORS:

  t7& operator=(const t7&) = default

  bool operator==(const t7&) const

  bool operator!=(const t7&) const

  # FIELDS:

  const T1& e1() const

  const T2& e2() const

  const T3& e3() const

  const T4& e4() const

  const T5& e5() const

  const T6& e6() const

  const T7& e7() const

struct<T1, T2, T3, T4, T5, T6, T7, T8> t8:

  # CONSTRUCTORS:

  t8() = default

  t8(const T1& _e1, const T2& _e2, const T3& _e3, const T4& _e4, const T5& _e5, const T6& _e6, const T7& _e7, const T8& _e8)

  t8(const t8&) = default

  # OPERATORS:

  t8& operator=(const t8&) = default

  bool operator==(const t8&) const

  bool operator!=(const t8&) const

  # FIELDS:

  const T1& e1() const

  const T2& e2() const

  const T3& e3() const

  const T4& e4() const

  const T5& e5() const

  const T6& e6() const

  const T7& e7() const

  const T8& e8() const

struct<T1, T2, T3, T4, T5, T6, T7, T8, T9> t9:

  # CONSTRUCTORS:

  t9() = default

  t9(const T1& _e1, const T2& _e2, const T3& _e3, const T4& _e4, const T5& _e5, const T6& _e6, const T7& _e7, const T8& _e8, const T9& _e9)

  t9(const t9&) = default

  # OPERATORS:

  t9& operator=(const t9&) = default

  bool operator==(const t9&) const

  bool operator!=(const t9&) const

  # FIELDS:

  const T1& e1() const

  const T2& e2() const

  const T3& e3() const

  const T4& e4() const

  const T5& e5() const

  const T6& e6() const

  const T7& e7() const

  const T8& e8() const

  const T9& e9() const

struct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> t10:

  # CONSTRUCTORS:

  t10() = default

  t10(const T1& _e1, const T2& _e2, const T3& _e3, const T4& _e4, const T5& _e5, const T6& _e6, const T7& _e7, const T8& _e8, const T9& _e9, const T10& e_10)

  t10(const t10&) = default

  # OPERATORS:

  t10& operator=(const t10&) = default

  bool operator==(const t10&) const

  bool operator!=(const t10&) const

  # FIELDS:

  const T1& e1() const

  const T2& e2() const

  const T3& e3() const

  const T4& e4() const

  const T5& e5() const

  const T6& e6() const

  const T7& e7() const

  const T8& e8() const

  const T9& e9() const

  const T10& e10() const

struct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> t11:

  # CONSTRUCTORS:

  t11() = default

  t11(const T1& _e1, const T2& _e2, const T3& _e3, const T4& _e4, const T5& _e5, const T6& _e6, const T7& _e7, const T8& _e8, const T9& _e9, const T10& e_10,
      const T11& _e11)

  t11(const t11&) = default

  # OPERATORS:

  t11& operator=(const t11&) = default

  bool operator==(const t11&) const

  bool operator!=(const t11&) const

  # FIELDS:

  const T1& e1() const

  const T2& e2() const

  const T3& e3() const

  const T4& e4() const

  const T5& e5() const

  const T6& e6() const

  const T7& e7() const

  const T8& e8() const

  const T9& e9() const

  const T10& e10() const

  const T11& e11() const

struct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> t12:

  # CONSTRUCTORS:

  t12() = default

  t12(const T1& _e1, const T2& _e2, const T3& _e3, const T4& _e4, const T5& _e5, const T6& _e6, const T7& _e7, const T8& _e8, const T9& _e9, const T10& e_10,
      const T11& _e11, const T12& _e12)

  t12(const t12&) = default

  # OPERATORS:

  t12& operator=(const t12&) = default

  bool operator==(const t12&) const

  bool operator!=(const t12&) const

  # FIELDS:

  const T1& e1() const

  const T2& e2() const

  const T3& e3() const

  const T4& e4() const

  const T5& e5() const

  const T6& e6() const

  const T7& e7() const

  const T8& e8() const

  const T9& e9() const

  const T10& e10() const

  const T11& e11() const

  const T12& e12() const

struct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> t13:

  # CONSTRUCTORS:

  t13() = default

  t13(const T1& _e1, const T2& _e2, const T3& _e3, const T4& _e4, const T5& _e5, const T6& _e6, const T7& _e7, const T8& _e8, const T9& _e9, const T10& e_10,
      const T11& _e11, const T12& _e12, const T13& _e13)

  t13(const t13&) = default

  # OPERATORS:

  t13& operator=(const t13&) = default

  bool operator==(const t13&) const

  bool operator!=(const t13&) const

  # FIELDS:

  const T1& e1() const

  const T2& e2() const

  const T3& e3() const

  const T4& e4() const

  const T5& e5() const

  const T6& e6() const

  const T7& e7() const

  const T8& e8() const

  const T9& e9() const

  const T10& e10() const

  const T11& e11() const

  const T12& e12() const

  const T13& e13() const

struct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> t14:

  # CONSTRUCTORS:

  t14() = default

  t14(const T1& _e1, const T2& _e2, const T3& _e3, const T4& _e4, const T5& _e5, const T6& _e6, const T7& _e7, const T8& _e8, const T9& _e9, const T10& e_10,
      const T11& _e11, const T12& _e12, const T13& _e13, const T14& _e14)

  t14(const t14&) = default

  # OPERATORS:

  t14& operator=(const t14&) = default

  bool operator==(const t14&) const

  bool operator!=(const t14&) const

  # FIELDS:

  const T1& e1() const

  const T2& e2() const

  const T3& e3() const

  const T4& e4() const

  const T5& e5() const

  const T6& e6() const

  const T7& e7() const

  const T8& e8() const

  const T9& e9() const

  const T10& e10() const

  const T11& e11() const

  const T12& e12() const

  const T13& e13() const

  const T14& e14() const

struct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> t15:

    # CONSTRUCTORS:

    t15() = default

    t15(const T1& _e1, const T2& _e2, const T3& _e3, const T4& _e4, const T5& _e5, const T6& _e6, const T7& _e7, const T8& _e8, const T9& _e9, const T10& e_10,
        const T11& _e11, const T12& _e12, const T13& _e13, const T14& _e14, const T15& _e15)

    t15(const t15&) = default

    # OPERATORS:

    t15& operator=(const t15&) = default

    bool operator==(const t15&) const

    bool operator!=(const t15&) const

    # FIELDS:

    const T1& e1() const

    const T2& e2() const

    const T3& e3() const

    const T4& e4() const

    const T5& e5() const

    const T6& e6() const

    const T7& e7() const

    const T8& e8() const

    const T9& e9() const

    const T10& e10() const

    const T11& e11() const

    const T12& e12() const

    const T13& e13() const

    const T14& e14() const

    const T15& e15() const

struct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> t16:

    # CONSTRUCTORS:

    t16() = default

    t16(const T1& _e1, const T2& _e2, const T3& _e3, const T4& _e4, const T5& _e5, const T6& _e6, const T7& _e7, const T8& _e8, const T9& _e9, const T10& e_10,
        const T11& _e11, const T12& _e12, const T13& _e13, const T14& _e14, const T15& _e15, const T16& _e16)

    t16(const t16&) = default

    # OPERATORS:

    t16& operator=(const t16&) = default

    bool operator==(const t16&) const

    bool operator!=(const t16&) const

    # FIELDS:

    const T1& e1() const

    const T2& e2() const

    const T3& e3() const

    const T4& e4() const

    const T5& e5() const

    const T6& e6() const

    const T7& e7() const

    const T8& e8() const

    const T9& e9() const

    const T10& e10() const

    const T11& e11() const

    const T12& e12() const

    const T13& e13() const

    const T14& e14() const

    const T15& e15() const

    const T16& e16() const

struct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> t16:

    # CONSTRUCTORS:

    t16() = default

    t16(const T1& _e1, const T2& _e2, const T3& _e3, const T4& _e4, const T5& _e5, const T6& _e6, const T7& _e7, const T8& _e8, const T9& _e9, const T10& e_10,
        const T11& _e11, const T12& _e12, const T13& _e13, const T14& _e14, const T15& _e15, const T16& _e16)

    t16(const t16&) = default

    # OPERATORS:

    t16& operator=(const t16&) = default

    bool operator==(const t16&) const

    bool operator!=(const t16&) const

    # FIELDS:

    const T1& e1() const

    const T2& e2() const

    const T3& e3() const

    const T4& e4() const

    const T5& e5() const

    const T6& e6() const

    const T7& e7() const

    const T8& e8() const

    const T9& e9() const

    const T10& e10() const

    const T11& e11() const

    const T12& e12() const

    const T13& e13() const

    const T14& e14() const

    const T15& e15() const

    const T16& e16() const

struct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> t17:

    # CONSTRUCTORS:

    t17() = default

    t17(const T1& _e1, const T2& _e2, const T3& _e3, const T4& _e4, const T5& _e5, const T6& _e6, const T7& _e7, const T8& _e8, const T9& _e9, const T10& e_10,
        const T11& _e11, const T12& _e12, const T13& _e13, const T14& _e14, const T15& _e15, const T16& _e16, const T17& _e17)

    t17(const t17&) = default

    # OPERATORS:

    t17& operator=(const t17&) = default

    bool operator==(const t17&) const

    bool operator!=(const t17&) const

    # FIELDS:

    const T1& e1() const

    const T2& e2() const

    const T3& e3() const

    const T4& e4() const

    const T5& e5() const

    const T6& e6() const

    const T7& e7() const

    const T8& e8() const

    const T9& e9() const

    const T10& e10() const

    const T11& e11() const

    const T12& e12() const

    const T13& e13() const

    const T14& e14() const

    const T15& e15() const

    const T16& e16() const

    const T17& e17() const

struct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> t18:

    # CONSTRUCTORS:

    t18() = default

    t18(const T1& _e1, const T2& _e2, const T3& _e3, const T4& _e4, const T5& _e5, const T6& _e6, const T7& _e7, const T8& _e8, const T9& _e9, const T10& e_10,
        const T11& _e11, const T12& _e12, const T13& _e13, const T14& _e14, const T15& _e15, const T16& _e16, const T17& _e17, const T18& _e18)

    t18(const t18&) = default

    # OPERATORS:

    t18& operator=(const t18&) = default

    bool operator==(const t18&) const

    bool operator!=(const t18&) const

    # FIELDS:

    const T1& e1() const

    const T2& e2() const

    const T3& e3() const

    const T4& e4() const

    const T5& e5() const

    const T6& e6() const

    const T7& e7() const

    const T8& e8() const

    const T9& e9() const

    const T10& e10() const

    const T11& e11() const

    const T12& e12() const

    const T13& e13() const

    const T14& e14() const

    const T15& e15() const

    const T16& e16() const

    const T17& e17() const

    const T18& e18() const

struct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> t19:

    # CONSTRUCTORS:

    t19() = default

    t19(const T1& _e1, const T2& _e2, const T3& _e3, const T4& _e4, const T5& _e5, const T6& _e6, const T7& _e7, const T8& _e8, const T9& _e9, const T10& e_10,
        const T11& _e11, const T12& _e12, const T13& _e13, const T14& _e14, const T15& _e15, const T16& _e16, const T17& _e17, const T18& _e18, const T19& _e19)

    t19(const t19&) = default

    # OPERATORS:

    t19& operator=(const t19&) = default

    bool operator==(const t19&) const

    bool operator!=(const t19&) const

    # FIELDS:

    const T1& e1() const

    const T2& e2() const

    const T3& e3() const

    const T4& e4() const

    const T5& e5() const

    const T6& e6() const

    const T7& e7() const

    const T8& e8() const

    const T9& e9() const

    const T10& e10() const

    const T11& e11() const

    const T12& e12() const

    const T13& e13() const

    const T14& e14() const

    const T15& e15() const

    const T16& e16() const

    const T17& e17() const

    const T18& e18() const

    const T19& e19() const

struct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> t20:

    # CONSTRUCTORS:

    t20() = default

    t20(const T1& _e1, const T2& _e2, const T3& _e3, const T4& _e4, const T5& _e5, const T6& _e6, const T7& _e7, const T8& _e8, const T9& _e9, const T10& e_10,
        const T11& _e11, const T12& _e12, const T13& _e13, const T14& _e14, const T15& _e15, const T16& _e16, const T17& _e17, const T18& _e18, const T19& _e19, const T20& _e20)

    t20(const t20&) = default

    # OPERATORS:

    t20& operator=(const t20&) = default

    bool operator==(const t20&) const

    bool operator!=(const t20&) const

    # FIELDS:

    const T1& e1() const

    const T2& e2() const

    const T3& e3() const

    const T4& e4() const

    const T5& e5() const

    const T6& e6() const

    const T7& e7() const

    const T8& e8() const

    const T9& e9() const

    const T10& e10() const

    const T11& e11() const

    const T12& e12() const

    const T13& e13() const

    const T14& e14() const

    const T15& e15() const

    const T16& e16() const

    const T17& e17() const

    const T18& e18() const

    const T19& e19() const

    const T20& e20() const

-----------------------------------------------------------------------------------------

range.cpp:

# <T> is built-in integral type
struct Range<T>:

    # CONSTRUCTORS:

    Range()

    # _end >= _begin ->
    Range(T _begin, T _end)

    Range(const Range&)

    # OPERATORS:

    Range& operator=(const Range&)

    bool operator==(const Range&)

    bool operator!=(const Range&)

    # determines if the beginning of &this is before the beginning of _range
    # Range(29, 38) < Range(27, 35) => false
    # Range(29, 38) < Range(29, 35) => false
    # Range(29, 38) < Range(30, 35) => true
    bool operator<(const Range&)

    # determines if the beginning of &this is after the beginning of _range
    # Range(29, 38) > Range(29, 35) => false
    # Range(29, 38) > Range(30, 35) => false
    # Range(29, 38) > Range(27, 35) => true
    bool operator>(const Range&)

    # generates new range with beginning (the beginning of &this) and end (the end of _range)
    # the two ranges must be neighboring
    # if the two ranges are not neighboring the function returns {}
    # Range(22, 40) & Range(41, 53) => (22, 53)
    # Range(41, 53) & Range(22, 40) => (22, 53)
    Range operator&(Range&)

    # FIELDS:

    int begin()

    int end()

    int length()

    Functions:

    bool IsSet()

    # Range(21, 30).IsAdjacentTo(Range(32, 37)) => false
    # Range(21, 30).IsAdjacentTo(Range(31, 37)) => true
    # Range(31, 37).IsAdjacentTo(Range(21, 30)) => true
    bool IsAdjacentTo(const Range&)

    # Range(21, 30).IsBefore(Range(30, 35)) => false
    # Range(21, 30).IsBefore(Range(31, 37)) => true
    # Range(21, 30).IsBefore(Range(35, 37)) => true
    bool IsBefore(const Range&)

    # Range(30, 35).IsAfter(Range(21, 30)) => false
    # Range(33, 37).IsAfter(Range(21, 30)) => true
    bool IsAfter(const Range)

    # Range(21, 30).IsRightBefore(Range(32, 35)) => false
    # Range(21, 30).IsRightBefore(Range(31, 35)) => true
    bool IsRightBefore(const Range&)

    # Range(32, 35).IsRightAfter(Range(21, 30)) => false
    # Range(31, 35).IsRightAfter(Range(21, 30)) => true
    bool IsRightAfter(const Range&)

    # Range(21, 30).AlignWith(Range(21, 50)) => true
    # Range(21, 30).AlignWith(Range(22, 50)) => false
    bool AlignWith(const Range&)

    # Range(76, 81).Contains(82) => false
    # Range(76, 81).Contains(81) => true
    bool Contains(const T&)

    # Range(73, 90).Contains(Range(78, 91)) => false
    # Range(73, 90).Contains(Range(78, 90)) => true
    bool Contains(const Range&)

    # Range(73, 90).Intersects(Range(78, 90)) => false
    # Range(73, 90).Intersects(Range(78, 92)) => true
    bool Intersects(const Range&)

# DisplacementOf(Range(23, 30), Range(35, 40)) => 12
# DisplacementOf(Range(23, 30), Range(14, 40)) => 9
# DisplacementOf(Range(-5, 8), Range(20, 23)) => 25
# DisplacementOf(Range(-119, -108), Range(-105, 92)) => 14
template<typename T> int DisplacementOf(const Range<T>&, const Range<T>&)

# IntervalOf(Range(23, 30), Range(35, 40)) => 4
# IntervalOf(Range(35, 40), Range(23, 30)) => 4
# IntervalOf(Range(-5, 8), Range(20, 23)) => 11
# IntervalOf(Range(-119, -108), Range(-105, 92)) => 2
template<typename T> int IntervalOf(const Range<T>&, const Range<T>&)

-----------------------------------------------------------------------------------------

stack.cpp:

struct stack<T>:

    # CONSTRUCTORS:

    stack() = default;

    stack(int _size)

    stack(const stack<T>& _value)

    # OPERATORS:

    bool operator==(const stack<T>& _value) const

    bool operator!=(const stack<T>& _value) const

    stack<T>& operator=(const stack<T>& _value)

    stack<T>& operator+=(const T& _value)

    stack<T>& operator+=(const stack<T>& _value)

    # FIELDS:

    int count() const

    int size() const

    T* elements()

    T* elements() const

    # FUNCTIONS

    stack<T>& push(const T& _value)

    # &Count >= 0 ->
    T pop()

    # &Count >= 0 ->
    T peek()

    void resize(int _size)

-----------------------------------------------------------------------------------------

queue.cpp:

struct queue<T>:

    # CONSTRUCTORS:

    queue() = default

    queue(int _size)

    queue(const queue<T>& _value)

    # OPERATORS:

    bool operator==(const queue<T>& _value) const

    bool operator!=(const queue<T>& _value) const

    queue<T>& operator=(const queue<T>& _value)

    queue<T>& operator+=(const T& _value)

    queue<T>& operator+=(const queue<T>& _value)

    # FIELDS:

    int count() const

    int size() const

    T* elements()

    T* elements() const

    # FUNCTIONS:

    queue<T>& enqueue(const T& _value)

    # &Count >= 0 ->
    T dequeue()

    # &Count >= 0 ->
    T peekRear()

    # &Count >= 0 ->
    T peekFront()

    void resize(int _size)

-----------------------------------------------------------------------------------------

list.cpp:

# this type determines what happens (when an instance of a sequence type is traversed) and these four scenarios happen:
  - the current traversal position is 0 and either previous() or back() is used; if the traversal mdoe is set to BOUNDED then (previous() returns the first element)
    and (back() does nothing)
  - the current traversal position is 0 and either previous() or back() is used; if the traversal mode is set to CIRCULAR then (previous() returns the last element) and
    (back() sets the current traversal position to a value that points to the last element)
  - the current traversal position is the position of the last element and either next() or advance() is used;
	if the traversal mode is set to BOUNDED then (next() returns the last element) and (advance() does nothing)
  - the current traversal position is the position of the last element and either next() or advance() is used;
    if the traversal mode is set to CIRCULAR then (next() returns the first element) and (advance() sets the current traversal position to a value
	that points to the first element) #
enum class TraversalMode = BOUNDED | CIRCULAR

# when an instance of (a sequence type that uses ReleaseMode) is about to be destructed the elements (are freed automatically and immediately
	 (when IMMEDIATE is used)) or (are stored for future use and are freed manually in a specific future moment (when FUTURE is used)) #
enum class ReleaseMode = IMMEDIATE | FUTURE

# (!) the size(accessed by size()) of a segment is equal to the size of the list that the segment refers to
struct list<T>:

    # VARIABLES:

    TraversalMode TraversalMode = TraversalMode::BOUNDED;

    # when an instance of this type is about to be destructed the elements (are freed automatically and immediately
      (when IMMEDIATE is used)) or (are stored for future use and are freed manually in a specific future moment (when FUTURE is used)) #
    ReleaseMode ReleaseMode

    # CONSTRUCTORS:

    list() = default

    # _extendCount is needed in cases where the allocated slots must be treated as existing elements (without being added first through another operation);
      if that parameter is true then &Count equals &Size #
    explicit list(int _size, bool _extendCount)

    list(const list<T>&, bool _isMutable = true)

    list(const std::initializer_list<T>& _list, bool _isMutable = true)

    # it generates a segment
    list(const list<T>& _source, int _begin, int _end, bool _isMutable = true)

    # it generates a segment
    list(const list<T>& _source, const Range<int>& _range, bool _isMutable = true)

    # it generates a segment
    list(const T* _source, int _elementsCount, int _begin, int _end, bool _isMutable = true)

    # it generates a segment
    list(const T* _source, int _elementsCount, const Range<int>& _range, bool _isMutable = true)

    # OPERATORS:

    bool operator==(const list<T>&) const

    bool operator!=(const list<T>&) const

    # [5, 0, 9] == [[5, 1, 3], [5, 1, 9], [5, 0, 0]] => false
    # [5, 0, 9] == [[5, 1, 0], [5, 0, 9], [4, 3, 1]] => true
    bool operator==(const list<list<T>>& _values) const

    # [5, 0, 9] == [[5, 1, 0], [5, 0, 9], [4, 3, 1]] => false
    # [5, 0, 9] == [[5, 1, 3], [5, 1, 9], [5, 0, 0]] => true
    bool operator!=(const list<list<T>>& _values) const

    list<T>& operator=(const list<T>&)

    list<T> operator+(const T&) const

    list<T> operator+(const list<T>&) const

    list<T>& operator+=(const T&)

    list<T>& operator+=(const list<T>&)

    # _index is in the range of list ->
    T& operator[](int)

    # _index is in the range of list ->
    T& operator[](int) const

    # FIELDS:

    int count() const

    int size() const

    int position() const

    T* elements()

    const T* elements() const

    # TRAVERSAL FUNCTIONS

    bool can_reverse() const

    bool can_advance() const

    # traversalMode() == BOUNDED && position() - _value < 0 >> position() = position()
    # traversalMode() == BOUNDED && position() - _value > -1 >> position() = position() - _value
    # traversalMode() == CIRCULAR -> circular addition; (EXAMPLE) count() = 19, position() = 4, back(9) >> position() = 14
    list<T>& back(int _value)

    # traversalMode() == BOUNDED && position() + _value >= count() >> position() = position()
    # traversalMode() == BOUNDED && position() + _value < count() - 1 >> position() = position() + _value
    # traversalMode() == CIRCULAR -> circular addition; (EXAMPLE) size() = 21, position() = 16, advance(10) >> position() = 5
    list<T>& advance(int _value)

    # position() > 0 => [position() - 1]
    # traversalMode() == BOUNDED && position() == 0 => [0]
    # traversalMode() == CIRCULAR && position() == 0 => [count() - 1]
    T& previous() const

    # count() > 0 ->
    T& current() const

    # position() < count() - 1 => [position() + 1]
    # traversalMode() == BOUNDED && position() == count() - 1 => [position()]
    # traversalMode() == CIRCULAR && position() == count() - 1 => [0]
    T& next() const

    # _position < -1 || _position > count() - 1 => -1
    int set_position(int _position)

    # MUTATION FUNCTIONS:

    # acquire ownership of _array
    void Acquire(T* _array, int _arrayLength)

    # acquire ownership of _list; after the operation is completed _list becomes invalid
    void Acquire(list<T>& _list)

    list<T>& Append(const T& _value)

    list<T>& Append(const T& _value, int _times)

    list<T>& Append(const list<T>& _value)

    # <T> implements operator '<' or it is a primitive numerical type ->
    list<T>& BubbleSort(bool _ascending = true)

    # <T> implements operator '<' or it is a primitive numerical type ->
    list<T>& BubbleSort(const std::function<bool(const T&, const T&)>& _predicate, bool _ascending = true)

    # the contents of _data are copied inside the list
    list<T>& BuiltFromArray(const T* _data, int _dataLength)

    # _size < 0 -> state of the list doesn't change
    list<T>& Clear(int _size = 0)

    # - this function marks certain memory block as 'excluded', which means that the data in the excluded block wouldn't
         be used anymore; the reason for using this function is performance (in some cases, not all) - the alternative is deleting
         the specific element(s) which would cause deletion of &Elements, assigning new array to &Elements and copying the old data
         into the new array which would slow down the program, so using exclusion instead of real deletion can increase the performance
         in some cases
       - a memory block is excluded by using the following 4 markers:
         - an exclusion marker for the beginning of the block (at position 0 in the block)
         - integer value (following the beginning marker) that specifies the length of the block (in number of elements, not bytes)
         - an exclusion marker at the end of the block (at position (length - sizeof(int)))
         - integer value (before the end marker) that specifies the length of the block (in number of elements, not bytes)
         (EXAMPLE) begin marker, length...length, end marker
       - the programmer can determine the beginning and the end of an excluded block by detecting the two exclusion markers; by default
         the function uses the constants EXCLUDED_BLOCK_BEGIN as a begin marker, and EXCLUDED_BLOCK_END as an end marker, but other values
         can be used if desired #
    # <T> must be compound type and must have (two <int> fields at the beginning of the declaration) and (two <int> fields at the end of the declaration)
           (EXAMPLE) struct S { int a; int b; ...other fields... int c; int d; } #
    # (_end > _begin) & (sizeof(T) > (sizeof(int) * 4)) ->
    list<T>& Exclude(int _begin, int _end, int _excludedBlockBeginMarker = EXCLUDED_BLOCK_BEGIN, int _excludedBlockEndMarker = EXCLUDED_BLOCK_END)

  # - this function marks certain memory block as 'excluded', which means that the data in the excluded block wouldn't
             be used anymore; the reason for using this function is performance (in some cases, not all) - the alternative is deleting
             the specific element(s) which would cause deletion of &Elements, assigning new array to &Elements and copying the old data
             into the new array which would slow down the program, so using exclusion instead of real deletion can increase the performance
             in some cases
           - a memory block is excluded by using the following 4 markers:
             - an exclusion marker for the beginning of the block (at position 0 in the block)
             - integer value (following the beginning marker) that specifies the length of the block (in number of elements, not bytes)
             - an exclusion marker at the end of the block (at position (length - sizeof(int)))
             - integer value (before the end marker) that specifies the length of the block (in number of elements, not bytes)
             (EXAMPLE) begin marker, length...length, end marker
           - the programmer can determine the beginning and the end of an excluded block by detecting the two exclusion markers; by default
             the function uses the constants EXCLUDED_BLOCK_BEGIN as a begin marker, and EXCLUDED_BLOCK_END as an end marker, but other values
             can be used if desired #
    # <T> must be compound type and must have (two <int> fields at the beginning of the declaration) and (two <int> fields at the end of the declaration)
           (EXAMPLE) struct S { int a; int b; ...other fields... int c; int d; } #
    # (_end > _begin) & (sizeof(T) > (sizeof(int) * 4)) ->
    list<T>& Exclude(const Range<int>& _range, int _excludedBlockBeginMarker = EXCLUDED_BLOCK_BEGIN, int _excludedBlockEndMarker = EXCLUDED_BLOCK_END)

    # [1, 2, 10].FillLeft(5, 7) => [5, 5, 5, 5, 1, 2, 10]
    list<T>& FillLeft(const T& _value, int _length)

    # [1, 2, 10].FillRight(5, 7) => [1, 2, 10, 5, 5, 5, 5]
    list<T>& FillRight(const T& _value, int _length)

    # (count() > 0 && _index > 0 && _index < count()) ->
    list<T>& Insert(const T& _value, int _index)

    # (count() > 0 && _index > 0 && _index < count()) ->
    list<T>& Insert(const list<T>& _value, int _index)

    # [1, 2, 3, 4, 5].Move(2, 4) => [1, 2, 4, 5, 3]
    list<T>& Move(int _sourceIndex, int _destinationIndex)

    # [11, 2, 10, 5, 4, 18, 9, 5, 0, 3].Reduce(2) => [10, 5, 4, 18, 9, 5]
    # [11, 2, 10, 5, 4, 18, 9, 5, 0, 3].Reduce(11) => [11, 2, 10, 5, 4, 18, 9, 5, 0, 3]
    list<T>& Reduce(int _reducer)

    # [11, 2, 10, 5, 4, 18, 9, 5, 0, 3].ReduceLeft(4) => [4, 18, 9, 5, 0, 3]
    # [11, 2, 10, 5, 4, 18, 9, 5, 0, 3].ReduceLeft(11) => [11, 2, 10, 5, 4, 18, 9, 5, 0, 3]
    list<T>& ReduceLeft(int _reducer)

    # [11, 2, 10, 5, 4, 18, 9, 5, 0, 3].ReduceRight(4) => [11, 2, 10, 5, 4, 18]
    # [11, 2, 10, 5, 4, 18, 9, 5, 0, 3].ReduceRight(11) => [11, 2, 10, 5, 4, 18, 9, 5, 0, 3]
    list<T>& ReduceRight(int _reducer)

    list<T>& Remove(int _begin, int _end)

    list<T>& Remove(const Range<int>& _range)

    list<T>& RemoveAt(int _index, int _length = 1)

    # removes the elements that match _value
    # [1, 25, 4, 3, 4, 6, 5, 2, 41, 4, 52, 7, 8, 9].RemoveAll(4) => [1, 25, 3, 6, 5, 2, 41, 52, 7, 8, 9]
    list<T>& RemoveAll(const T& _value)

    # removes the elements that match an element in _set
    # [1, 2, 3, 4, 5, 6, 5, 2, 7, 8, 9].RemoveAll(2, 4, 5, 8) => [1, 3, 6, 7, 8, 9]
    list<T>& RemoveAll(const list<T>& _set)

    list<T>& RemoveIf(const std::function<bool(const T&)>& _predicate)

    # [9, 2, 7].Repeat(2) => [9, 2, 7, 9, 2, 7, 9, 2, 7]
    list<T>& Repeat(int _times)

    # [5, 9, 0, 3, 7, 18, 4, 2, 6].Replace(4, 7, [2, 6, 1]) => [5, 9, 0, 3, 2, 6, 1, 6]
    list<T>& Replace(int _begin, int _end, const list<T>& _replacement)

    # [5, 9, 0, 3, 7, 18, 4, 2, 6].Replace((4, 7), [2, 6, 1]) => [5, 9, 0, 3, 2, 6, 1, 6]
    list<T>& Replace(const Range<int>& _range, const list<T>& _replacement)

    # replace every occurrence of _replaced with _replacement
    list<T>& Replace(const T& _replaced, const T& _replacement)

    # replace every occurrence of _replaced with _replacement
    list<T>& Replace(const list<T>& _replaced, const list<T>& _replacement)

    # [9, 7, 2, 5, 9, 0, 6, 2, 8, 4].Reverse() => [4, 8, 2, 6, 0, 9, 5, 2, 7, 9]
    list<T>& Reverse()

    # [1, 2, 3, 4, 5].RotateLeft(3) => [4, 5, 1, 2, 3]
    list<T>& RotateLeft(int _positions = 1)

    # [1, 2, 3, 4, 5].RotateRight(3) => [3, 4, 5, 1, 2]
    list<T>& RotateRight(int _positions = 1)

    # performs an unstable sorting
    # <T> implements operator '<' or it is a primitive numerical type ->
    list<T>& SelectionSort(bool _ascending = true)

    # performs an unstable sorting
    # <T> implements operator '<' or it is a primitive numerical type ->
    list<T>& SelectionSort(const std::function<bool(const T&, const T&)>& _predicate, bool _ascending = true)

    # [9, 1, 5, 3, 0, 4, 7, 0, 6, 5, 1].Set(3, 5, 192) => [9, 1, 5, 192, 192, 192, 7, 0, 6, 5, 1]
    list<T>& Set(int _begin, int _end, const T& _value)

    # [9, 1, 5, 3, 0, 4, 7, 0, 6, 5, 1].Set((3, 5), 192) => [9, 1, 5, 192, 192, 192, 7, 0, 6, 5, 1]
    list<T>& Set(const Range<int>& _range, const T& _value)

    # [9, 1, 5, 3, 0, 4, 7, 0, 6, 5, 1].Set(3, [8, 2, 0, 1]) => [9, 1, 5, 8, 2, 0, 1, 0, 6, 5, 1]
    list<T>& Set(int _begin, const list<bool>& _value)

    list<T>& Swap(int _index1, int _index2)

    # _element1 and _element2 are pointers to elements of the list ->
    list<T>& Swap(T* _element1, T* _element2)

    # [2, 2, 2, 5, 9, 0, 6, 2, 2, 2, 2, 2].Trim(2) => [5, 9, 0, 6]
    list<T>& Trim(const T& _value)

    # [2, 2, 2, 5, 9, 0, 6, 2, 2, 2, 2, 2].TrimBegin(2) => [5, 9, 0, 6, 2, 2, 2, 2, 2]
    list<T>& TrimBegin(const T& _value)

    # [2, 2, 2, 5, 9, 0, 6, 2, 2, 2, 2, 2].TrimEnd(2) => [2, 2, 2, 5, 9, 0, 6]
    list<T>& TrimEnd(const T& _value)

    # NON-MUTATING FUNCTIONS:

    bool BeginsWith(const list<T>& _value) const

    # returns 'true' if &this begins with atleast one of the sequences in _value
    # [8, 2, 5, 10, 7, 15, 12, 9, 1].BeginsWith([[5, 9, 1], [8, 1, 5], [9, 12, 0]]) => false
    # [8, 2, 5, 10, 7, 15, 12, 9, 1].BeginsWith([[5, 9, 1], [8, 2, 5], [9, 12, 0]]) => true
    bool BeginsWith(const list<list<T>>& _values) const

    # returns copy of &this
    list<T> Clone() const

    bool Contains(const T& _value) const

    # [1, 2, 3, 4, 5, 6, 7, 8, 9].Contains([2, 3, 4]) => true
    bool Contains(const list<T>& _value) const

    bool Contains(const std::function<bool(const T&)>& _predicate) const

    bool ContainsAll(const list<T>& _set) const

    # [9, 7, 3, 20, 15, 18, 4, 7].ContainsAny([21, 8, 5, 1]) => false
    # [9, 7, 3, 20, 15, 18, 4, 7].ContainsAny([6, 30, 3, 1]) => true
    bool ContainsAny(const list<T>& _set) const

    bool ContainsOnly(const T& _value) const

    # [9, 1, 0, 3, 1, 5, 9, 1, 15, 3, 7, 5, 9, 1, 1].ContainsOnly([1, 9, 10]) => false
    # [9, 1, 0, 3, 1, 5, 9, 1, 15, 3, 7, 5, 9, 1, 1].ContainsOnly([5, 9, 1, 0, 7, 3, 15]) => true
    bool ContainsOnly(const list<T>& _set) const

    bool ContainsOnly(const std::function<bool(const T&)>& _predicate) const

    int CountOf(const T& _value) const

    # [5, 9, 1, 0, 3, 5, 9, 1, 4, 5, 9, 1, 10, 15, 3, 7, 5, 9, 1, 1].CountOf([5, 9, 1]) => 4
    # [5, 9, 1, 0, 3, 5, 9, 1, 4, 5, 9, 1, 10, 15, 3, 7, 5, 9, 1, 1].CountOf([5, 9, 1, 7]) => 0
    int CountOf(const list<T>& _value) const

    int CountOf(const std::function<bool(const T&)>& _predicate) const

    # [7, 8, 3, 19, 20, 71, 15, 71, 3, 31, 108, 3]).Duplicates() => [3, 71]
    list<T> Duplicates() const

    bool EndsWith(const list<T>& _value) const

    bool EndsWith(const list<list<T>>& _values) const

    # [2, 9, 0, 1, 4, 9, 7, 3].Except(9) => [2, 0, 1, 4, 7, 3]
    list<T> Except(const T& _value) const

    # [2, 9, 0, 1, 4, 9, 7, 3].Except([9, 7, 0]) => [2, 1, 4, 3]
    list<T> Except(const list<T>& _set) const

    list<T> Except(const std::function<bool(const T&)>& _predicate) const

    # (if the element specified by the predicate is present in the list) the function returns a pointer to it
    # (if the element specified by the predicate is not present in the list) the functions returns a null pointer
    T* First(const std::function<bool(const T&)>& _predicate) const

    # there is an implicit conversion from <T> to <A> ->
    template<typename A> list<A> Generate() const

    # struct Item { int Price; Item() = default; Item(int _price): Price(_price) {} };
      Item a(5);
      Item b(2);
      Item c(35);
      list<Item> items { a, b, c };
      list<int> l = items.Generate<int>([](const Item& _item) { return _item.Price * 2; }); => [10, 4, 70] #
    template<typename A> list<A> Generate(const std::function<A(const T&)>& _generator) const

    # it checks whether the list contains an element with the specified index
    bool Has(int _index) const

    bool HasDuplicates() const

    # the specified element does not exist or _begin is outside the range of list => -1
    int IndexOf(const T& _value, int _begin = 0) const

    # the specified element does not exist or _begin is outside the range of list => -1
    int IndexOf(const list<T>& _value, int _begin = 0) const

    # the specified element does not exist or _begin is outside the range of list => -1
    int IndexOf(const std::function<bool(const T&)>& _predicate, int _begin = 0) const

    # the specified element does not exist or _begin is outside the range of list => -1
    int IndexOfAny(const list<T>& _set, int _begin = 0) const

    # _begin is outside the range of list => -2
    # [].IndexOf(4) => -1
    # [9, 9, 9, 5, 8, 10, 2, 7].IndexOfNot(9) => 3
    # [9, 9, 9, 5, 8, 10, 2, 7].IndexOfNot(4) => 0
    int IndexOfNot(const T& _value, int _begin = 0) const

    # _begin is outside the range of list => -2
    # [].IndexOf(4) => -1
    # [9, 9, 9, 5, 8, 10, 2, 7].IndexOfNot(9) => 3
    # [9, 9, 9, 5, 8, 10, 2, 7].IndexOfNot(4) => 0
    int IndexOfNot(const std::function<bool(const T&)>& _predicate, int _begin = 0) const

    # A = [5, 0, 3, 6]
      B = [3, 2, 4, 5, 9]
      IntersectionOf(A, B) => [3, 5] #
    static list<T> IntersectionOf(const list<T>& _list1, const list<T>& _list2)

    # count() > 1 ->
    bool IsHeterogeneous() const

    # count() > 1 ->
    bool IsHomogeneous() const

    # the specified value does not exist => -1
    int LastIndexOf(const T& _value) const

    # the specified value does not exist => -1
    int LastIndexOf(const list<T>& _value) const

    # the specified value does not exist => -1
    int LastIndexOf(const std::function<bool(const T&)>& _predicate) const

    # return the maximum element in the range (_begin, Count - 1)
    # count() == 0 => nullptr
    # _begin is outside the range of list => nullptr
  	# <T> implements operator '>' or it is a primitive numerical type ->
    T* Max(int _begin = 0) const

    # return the minimum element in the range (_begin, Count - 1)
    # count() == 0 => nullptr
    # _begin is outside the range of list => nullptr
    # <T> implements operator '>' or it is a primitive numerical type ->
    T* Min(int _begin = 0) const

    # returns only values that are (between the beginning and a separator), (between separator and the end) or (between two separators)
    # empty sequences are generated (and eventually are appended to the result) only if they are between two separators
    # _ignoreEmptyValues = true -> empty sequences (if there are any) are not appended to the result
    # [41, 56, 3, 7, 18, 5, 19, 76, 15].Multisplit([353, 12]) => []
    # [41, 56, 3, 7, 18, 5, 19, 76, 15, 9, 20, 5].Multisplit([56, 9]) => [[41], [3, 7, 18, 5, 19, 76, 15], [20, 5]]
    # [9, 41, 56, 3, 7, 18, 5, 19, 76, 15, 9, 9, 20, 7].Multisplit([7, 9]) => [[41, 56, 3], [18, 5, 19, 76, 15], [], [20]]
    # [9, 41, 56, 3, 7, 18, 5, 19, 76, 15, 9, 9, 20, 7].Multisplit([7, 9], true) => [[41, 56, 3], [18, 5, 19, 76, 15], [20]]
    list<list<T>> Multisplit(const list<T>& _set, bool _ignoreEmptyValues = false) const

    # returns the range of a sequence consisting of certain set of values (it is not mandatory for the sequence to contain each value in the set)
    # [3, 10, 15, 12, 8, 5, 7, 5, 5, 7, 7, 3, 9].RangeOf([2, 5, 7]) => (5, 10)
    # [3, 10, 15, 12, 8, 5, 7, 2, 2, 7, 7, 3, 9].RangeOf([2, 5, 7]) => (5, 10)
    # [3, 10, 15, 12, 0, 5, 7, 2, 2, 7, 7, 3, 9].RangeOf([4, 0, 1]) => (4, 4)
    # [3, 10, 15, 12, 8, 5, 7, 2, 2, 7, 7, 3, 9].RangeOf([4, 0, 1]) => (-1, -1)
    Range<int> RangeOf(const list<T>& _set, int _sindex = 0) const

    # returns the range of a sequence not consisting of certain set of values (it is mandatory for the sequence to not contain any of the values in the set)
    # [5, 7, 5, 5, 7, 7, 3, 10, 15, 12, 8, 2, 9].RangeOfNot([2, 5, 7]) => (6, 10)
    # [3, 10, 15, 12, 8, 5, 7, 2, 2, 7, 7, 3, 9].RangeOfNot([2, 5, 7]) => (0, 4)
    # [5, 7, 2, 2, 7, 7, 5, 4, 2, 7, 5].RangeOfNot([2, 5, 7]) => (7, 7)
    # [4, 0, 0, 1, 1, 4, 0, 1, 4, 4, 1].RangeOfNot([4, 0, 1]) => (-1, -1)
    Range<int> RangeOfNot(const list<T>& _set, int _sindex = 0) const

    # returns only values that are (between the beginning and a separator), (between separator and the end) or (between two separators)
    # empty sequences are generated (and eventually are appended to the result) only if they are between two separators
    # _ignoreEmptyValues = true -> empty sequences (if there are any) are not appended to the result
    # [3, 7, 18, 5, 19, 76, 15].Split(353) => []
    # [18, 5, 19, 76, 15, 9, 20, 5].Split(9) => [[18, 5, 19, 76, 15], [20, 5]]
    # [56, 3, 7, 18, 5, 19, 76, 7].Split(7) => [[56, 3], [18, 5, 19, 76]]
    # [56, 7, 7, 18, 5, 19, 76, 15, 9].Split(7) => [[56], [], [18, 5, 19, 76, 15, 9]]
    # [56, 7, 7, 18, 5, 19, 76, 15, 9].Split(7, true) => [[56], [18, 5, 19, 76, 15, 9]]
    # [7, 41, 56, 7, 18, 76, 15, 9, 7].Split(7) => [[41, 56], [18, 76, 15, 9]]
    # [7, 41, 56, 7, 7, 7, 18, 5, 15].Split(7) => [[41, 56], [], [], [18, 5, 15]]
    # [7, 41, 56, 7, 7, 7, 18, 5, 15].Split(7, true) => [[41, 56], [18, 5, 15]]
    list<list<T>> Split(const T& _separator, bool _ignoreEmptyValues = false) const

    # returns only values that are (between the beginning and a separator), (between separator and the end) or (between two separators)
    # empty sequences are generated (and eventually are appended to the result) only if they are between two separators
    # _ignoreEmptyValues = true -> empty sequences (if there are any) are not appended to the result
    # [41, 56, 3, 5, 7, 18, 5, 19, 76, 15].Split([3, 8]) => []
    # [41, 56, 3, 5, 7, 18, 5, 19, 9, 7, 76, 15, 9].Split([9, 7]) => [[41, 56, 3, 5, 7, 18, 5, 19], [76, 15, 9]]
    # [41, 56, 3, 9, 7, 18, 5, 19, 76, 15, 9, 20, 9, 7].Split([9, 7]) => [[41, 56, 3], [18, 5, 19, 76, 15, 9, 20]]
    # [41, 56, 9, 7, 9, 7, 18, 5, 19, 76, 15, 9, 20, 3].Split([9, 7]) => [[41, 56], [], [18, 5, 19, 76, 15, 9, 20, 3]]
    # [41, 56, 9, 7, 9, 7, 18, 5, 19, 76, 15, 9, 20, 3].Split([9, 7], true) => [[41, 56], [18, 5, 19, 76, 15, 9, 20, 3]]
    # [9, 7, 41, 56, 9, 9, 7, 18, 76, 15, 9, 20, 3, 9, 7].Split([9, 7]) => [[41, 56, 9], [18, 76, 15, 9, 20, 3]]
    # [9, 7, 41, 56, 9, 7, 9, 7, 9, 7, 18].Split([9, 7]) => [[41, 56], [], [], [18]]
    # [9, 7, 41, 56, 9, 7, 9, 7, 9, 7, 18].Split([9, 7], true) => [[41, 56], [18]]
    list<list<T>> Split(const list<T>& _separator, bool _ignoreEmptyValues = false) const

    # returns only values that are (between the beginning and a separator), (between separator and the end) or (between two separators)
    # empty sequences are generated (and eventually are appended to the result) only if they are between two separators
    # _ignoreEmptyValues = true -> empty sequences (if there are any) are not appended to the result
    # [3, 7, 18, 5, 19, 76, 15].Split([](int x) { return x == 353; }) => []
    # [18, 5, 19, 76, 15, 9, 20, 5].Split([](int x) { return x == 9; }) => [[18, 5, 19, 76, 15], [20, 5]]
    # [56, 3, 7, 18, 5, 19, 76, 7].Split([](int x) { return x == 7; }) => [[56, 3], [18, 5, 19, 76]]
    # [56, 7, 7, 18, 5, 19, 76, 15, 9].Split([](int x) { return x == 7; }) => [[56], [], [18, 5, 19, 76, 15, 9]]
    # [56, 7, 7, 18, 5, 19, 76, 15, 9].Split([](int x) { return x == 7; }, true) => [[56], [18, 5, 19, 76, 15, 9]]
    # [7, 41, 56, 7, 18, 76, 15, 9, 7].Split([](int x) { return x == 7; }) => [[41, 56], [18, 76, 15, 9]]
    # [7, 41, 56, 7, 7, 7, 18, 5, 15].Split([](int x) { return x == 7; }) => [[41, 56], [], [], [18, 5, 15]]
    # [7, 41, 56, 7, 7, 7, 18, 5, 15].Split([](int x) { return x == 7; }, true) => [[41, 56], [18, 5, 15]]
    list<list<T>> Split(const std::function<bool(const T&)>& _predicate, bool _ignoreEmptyValues = false) const

    # _length = 0 => [_begin..]
    # (_begin + _length) > count() => {}
    list<T> Sublist(int _begin, int _length = 0) const

    # [5, 8, 4, 1, 9, 6, 2, 3, 0, 5, 5, 1, 7].Subrange(2, 5) => [4, 1, 9, 6]
    list<T> Subrange(int _begin, int _end) const

    # [5, 8, 4, 1, 9, 6, 2, 3, 0, 5, 5, 1, 7].Subrange((2, 5)) => [4, 1, 9, 6]
    list<T> Subrange(const Range<int>& _range) const

    list<T> Where(const std::function<bool(const T&)>& _predicate) const

    # A = [8, 19, 2, 5, 5, 0, 2, 7, 10, 4]
      B = [23, 21, 4, 7, 5, 19, 17, 26]
      UnionOf(A, B) => [8, 19, 2, 5, 0, 7, 10, 4, 23, 21, 17, 26] #
    static list<T> UnionOf(const string& _string1, const string& _string2)

    static list<T> UnionOf(const list<T>& _list1, const list<T>& _list2)

    # [21, 35, 2, 9, 40, 31, 52, 9, 24, 52, 35, 18].Unique() => [21, 35, 2, 9, 40, 31, 24, 18]

    # [21, 35, 2, 9, 40, 31, 52, 9, 24, 52, 35, 18].Until(52) => [21, 35, 2, 9, 40, 31, 52, 9, 24]
    list<T> Until(const T& _value) const

    #

    void resize(int _size = -1)

-----------------------------------------------------------------------------------------

string.cpp:

# constructor activation atoms
enum size = SIZE_A
enum ASCII = ascii
enum U8 = u8
enum U16 = u16
enum U32 = u32

# activation atoms for string::ToInteger()
enum DECIMAL_ = DECIMAL_A
enum BINARY_ = BINARY_A
enum HEX_ = HEX_A

# encoding format for (input and output string data)
enum Encoding = ASCII_ | UTF8 | UTF16LE | UTF16BE | UTF32LE | UTF32BE

const int INVALID_INTEGER = INT_MIN

# maximum length in (bytes/code units/characters)
const int MAX_LENGTH = 1073741823

# marker specifying (the length of a string in bytes)
const unsigned int b = 0 # [31] = 0, [30] = 0
const unsigned int bytes = b # pseudonym of &b

# marker specifying (the length of a string in code units)
const unsigned int u = 1073741824 # [31] = 0, [30] = 1
const unsigned int units = u # pseudonym of &u

# marker specifying (the length of a string in characters)
const unsigned int c = 2147483648 # [31] = 1, [30] = 0
const unsigned int characters = c # pseudonym of &c

# the default endianity value of the arguments in constructors of t:string; it is not possible to be a static field of t:string
Endianity DefaultEndianity = LE

# the default encoding format of (the values passed to the constructors of t:string that are not marked with BOM)
Encoding DefaultInputEncoding = ASCII_

# the default encoding format of the stored value of a string
Encoding DefaultStorageEncoding = UTF8

# the input string (passed to the constructors) is in ASCII, UTF-8, UTF-16LE, UTF-16BE, UTF-32LE or UTF-32BE format
# the input string (may contain a terminating character) or (it's length may be explicitly specified)
# the output string (the string value after the construction process has ended) is stored as (byte sequence) representing (a sequence of UTF-8, UTF-16LE or UTF-32LE code units)
# (ASCII|UTF-8|UTF-16LE|UTF-16BE|UTF-32LE|UTF-32BE:input-string) -> (UTF-8|UTF-16LE|UTF-32LE:output-string)
# <T> is the type of the output string
# (!) if certain input string is character-terminated, then the terminating character must be U+0000
# (!) the public functions of this type operate on characters(code points), not on bytes or code units
# (!) elements() returns a pointer to byte array containing (the characters represented as a sequence of (UTF-8, UTF-16LE, UTF-16BE, UTF-32LE or UTF-32BE) code units)
# (!) the constructors accept (byte arrays) or (arrays of UTF-16/UTF-32 code units)
# (!) (the constructors accepting byte arrays) may accept the array length (in bytes), (in code units) or (in characters); in order to pass
      the length in bytes one have to use <N> or <N>|b, to pass the length in code units <N>|u, and to pass the length in characters <N>|c;
      the maximum value of <N> is 1073741823 (constant MAX_LENGTH)
      (1) 162 (162 bytes)
      (2) 495|b (495 bytes)
      (E3) 829|u (829 code units)
      (3) 327|c (327 characters)
      (5) [utf16]:array -> string(array, 94|c) (construction of a string accepting an array of UTF-16 code units with length 94 characters) #
# (!) (MAY-NEED-BETTER-EXPLANATION)
	  when an incorrect length value is passed to a (constructor accepting UTF-16 or UTF-32 arrays) it is possible for a discrepancy to occur between
      the number of the specified number of bytes/code-units/characters and the number of the processed bytes/code-units/characters
      (E) string(const utf16*...) receive a length of 4 bytes; the first code unit is BMP character, and the second and third
          code units are respectively high and low surrogate of a non-BMP character; in this case 6 bytes (not 4) will be processed, because in
	      constructors there is an iteration over characters (the first character is represented by the first two bytes, and the second
	      by the next four bytes) #
# (!) the constructors must not receive an empty string or a string without terminating character(for ASCII and UTF-8) or terminating sequence
	  (for UTF-16 and UTF-32); accessing of (an element outside the range of string) is 'undefined behavior' #
# (!) the size(accessed by size()) of a segment is equal to the size of the list that the segment refers to
struct String:

    VARIABLES:

    # this variable plays a role for the speed of string generation; the larger the final size of the string is (i.e. the size after
	  ending of the generation process), the larger the value of this variable must be; it needs to be increased by 1 every 2kb;
	  if the string is very large and it's final size is known before the construction, then it is better to set the binary size before
	  the start of the generation process - in such a way there wouldn't be need for (potentialy multiple) resize operations #
    int Extensor = 50 # in bytes

    TraversalMode TraversalMode = TraversalMode::BOUNDED

    # when an instance of this type is about to be destructed the elements (are freed automatically and immediately
      (when IMMEDIATE is used)) or (are stored for future use and are freed manually in a specific future
       moment (when FUTURE is used)) #
    ReleaseMode ReleaseMode = ReleaseMode::IMMEDIATE

    # CONSTRUCTORS:

    string() = default

    explicit string(int _size, size)

    # _array is an ASCII string with an available terminating character ->
    string(const char* _array)

    # _array is an ASCII|UTF-8|UTF-16|UTF-32 string with an available terminating character ->
    string(const unsigned char* _array)

    # _array is an ASCII string with an available terminating character ->
    string(const char* _array, ASCII, Encoding _storageEncoding)

    # _array is an ASCII string with an available terminating character ->
    string(const char* _array, ASCII) -> string(_array, ascii, DefaultStorageEncoding)

    # _length specifies the length of _array
    # _array is an ASCII string ->
    string(const char* _array, ASCII, unsigned int _length, Encoding _storageEncoding)

    # _length specifies the length of _array
    # _array is an ASCII string ->
    string(const char* _array, ASCII, unsigned int _length) -> string(_array, ascii, _length, DefaultStorageEncoding)

    # _array is a UTF-8 string with an available terminating character ->
    string(const unsigned char* _array, U8, Encoding _storageEncoding)

    # _array is a UTF-8 string with an available terminating character ->
    string(const unsigned char*_array, U8) -> string(_array, u8, DefaultStorageEncoding)

    # _length specifies the length of _array
    # _array is a UTF-8 string ->
    string(const unsigned char* _array, U8, unsigned int _length, Encoding _storageEncoding)

    # _length specifies the length of _array
    # _array is a UTF-8 string ->
    string(const unsigned char* _array, U8, unsigned int _length) -> string(_array, u8, _length, DefaultStorageEncoding)

    # _array is a UTF-16 string with an available terminating character ->
    string(const unsigned char* _array, U16, Endianity _endianity, Encoding _storageEncoding)

    # _array is a UTF-16 string with an available terminating character ->
    string(const unsigned char* _array, U16, Endianity _endianity) -> string(_array, u16, _endianity, DefaultStorageEncoding)

    # _array is a UTF-16 string with an available terminating character ->
    string(const unsigned char* _array, U16, Encoding _storageEncoding) -> string(_array, u16, DefaultEndianity, _storageEncoding)

    # _array is a UTF-16 string with an available terminating character ->
    string(const unsigned char*_array, U16) -> string(_array, u16, DefaultEndianity, DefaultStorageEncoding)

    # _length specifies the length of _array
    # _array is a UTF-16 string ->
    string(const unsigned char* _array, U16, Endianity _endianity, unsigned int _length, Encoding _storageEncoding)

    # _length specifies the length of _array
    # _array is a UTF-16 string ->
    string(const unsigned char* _array, U16, Endianity _endianity, unsigned int _length) -> string(_array, u16, _endianity, _length, DefaultStorageEncoding)

    # _length specifies the length of _array
    # _array is a UTF-16 string ->
    string(const unsigned char* _array, U16, unsigned int _length, Encoding _storageEncoding) -> string(_array, u16, DefaultEndianity, _length, _storageEncoding)

    # _length specifies the length of _array
    # _array is a UTF-16 string ->
    string(const unsigned char* _array, U16, unsigned int _length) -> string(_array, u16, DefaultEndianity, _length, DefaultStorageEncoding)

    # _array is a UTF-32 string with an available terminating character ->
    string(const unsigned char* _array, U32, Endianity _endianity, Encoding _storageEncoding)

    # _array is a UTF-32 string with an available terminating character ->
    string(const unsigned char*_array, U32, Endianity _endianity) -> string(_array, u32, _endianity, DefaultStorageEncoding)

    # _array is a UTF-32 string with an available terminating character ->
    string(const unsigned char* _array, U32, Encoding _storageEncoding) -> string(_array, u32, DefaultEndianity, _storageEncoding)

    # _array is a UTF-32 string with an available terminating character ->
    string(const unsigned char* _array, U32) -> string(_array, u32, DefaultEndianity, DefaultStorageEncoding)

    # _length specifies the length of _array
    # _array is a UTF-32 string ->
    string(const unsigned char* _array, U32, Endianity _endianity, unsigned int _length, Encoding _storageEncoding)

    # _length specifies the length of _array
    # _array is a UTF-32 string ->
    string(const unsigned char* _array, U32, Endianity _endianity, unsigned int _length) -> string(_array, u32, _endianity, _length, DefaultStorageEncoding)

    # _length specifies the length of _array
    # _array is a UTF-32 string ->
    string(const unsigned char* _array, U32, unsigned int _length, Encoding _storageEncoding) -> string(_array, u32, DefaultEndianity, _length, _storageEncoding)

    # _length specifies the length of _array
    # _array is a UTF-32 string ->
    string(const unsigned char* _array, U32, unsigned int _length) -> string(_array, u32, DefaultEndianity, _length, DefaultStorageEncoding)

    # _array is a UTF-16 string with an available terminating character ->
    string(const utf16* _array, Endianity _endianity, Encoding _storageEncoding)

    # _array is a UTF-16 string with an available terminating character ->
    string(const utf16* _array, Endianity _endianity) -> string(_array, _endianity, DefaultStorageEncoding)

    # _array is a UTF-16 string ->
    string(const utf16* _array, Encoding _storageEncoding) -> string(_array, DefaultEndianity, _storageEncoding)

    # _array is a UTF-16 string ->
    string(const utf16* _array) -> string(_array, DefaultEndianity, DefaultStorageEncoding)

    # _length specifies the length of _array
    # _array is a UTF-16 string ->
    string(const utf16* _array, Endianity _endianity, unsigned int _length, Encoding _storageEncoding)

    # _length specifies the length of _array
    # _array is a UTF-16 string ->
    string(const utf16*_array, Endianity _endianity, unsigned int _length) -> string(_array, _length, DefaultStorageEncoding)

    # _length specifies the length of _array
    # _array is a UTF-16 string ->
    string(const utf16*_array, unsigned int _length, Encoding _storageEncoding) -> string(_array, DefaultEndianity, _length, _storageEncoding)

    # _length specifies the length of _array
    # _array is a UTF-16 string ->
    string(const utf16*_array, unsigned int _length) -> string(_array, DefaultEndianity, _length, DefaultStorageEncoding)

    # _array is a UTF-32 string with an available terminating character ->
    string(const utf32*_array, Endianity _endianity, Encoding _storageEncoding)

    # _array is a UTF-32 string with an available terminating character ->
    string(const utf32* _array, Endianity _endianity) -> string(_array, _endianity, DefaultStorageEncoding)

    # _array is a UTF-32 string ->
    string(const utf32*_array, Encoding _storageEncoding) -> string(_array, DefaultEndianity, _storageEncoding)

    # _array is a UTF-32 string ->
    string(const utf32*_array) -> string(_array, DefaultEndianity, DefaultStorageEncoding)

    # _length specifies the length of _array
    # _array is a UTF-32 string ->
    string(const utf32*_array, Endianity _endianity, unsigned int _length, Encoding _storageEncoding)

    # _length specifies the length of _array
    # _array is a UTF-32 string ->
    string(const utf32*_array, Endianity _endianity, unsigned int _length) -> string(_array, _endianity, _length, DefaultStorageEncoding)

    # _length specifies the length of _array
    # _array is a UTF-32 string ->
    string(const utf32*_array, unsigned int _length, Encoding _storageEncoding) -> string(_array, DefaultEndianity, _length, _storageEncoding)

    # _length specifies the length of _array
    # _array is a UTF-32 string ->
    string(const utf32*_array, unsigned int _length) -> string(_array, DefaultEndianity, _length, DefaultStorageEncoding)

    string(const wchar_t* _string, Encoding _storageEncoding) -> string(reinterpret_cast<const utf16*>(_string), LE, _storageEncoding)

    string(const wchar_t* _string) -> string(reinterpret_cast<const utf16*>(_string), LE, DefaultStorageEncoding) {}

    string(const string& _string)

    # it generates a segment
    string(const string& _source, int _begin, int _end)

    # it generates a segment
    string(const string& _source, const Range<int>& _range)

    string(char _character)

    string(wchar_t _character)

    string(CodePoint _codePoint)

    # OPERATORS:

    # this operator does not compare the fields of the two objects; it compares only the character content
    bool operator==(const string&) const

    # this operator does not compare the fields of the two objects; it compares only the character content
    bool operator!=(const string&) const

    # "East" == ["North", "South", "Left", "Right"] => false
    # "East" == ["North", "South", "East", "West"] => true
    bool operator==(const list<string>& _values) const

    # "East" == ["North", "South", "East", "West"] => false
    # "East" == ["North", "South", "Left", "Right"] => true
    bool operator!=(const list<string>& _values) const

    string& operator=(const string&)

    string operator+(CodePoint) const

    string operator+(const string&) const

    string& operator+=(CodePoint)

    string& operator+=(const string&)

    # _index is in the range of list ->
    CodePoint operator[](int _index)

    # _index is in the range of list ->
    CodePoint operator[](int _index) const

    # FIELDS:

    int byteCount() const

    int characterCount() const

    int codeUnitCount() const

    int size() const

    int position() const

    Encoding storageEncoding() const

    const unsigned char* elements() const

    #

    # "" => false
    # "-026" => true
    # "-26" => true
    # "26" => true
    bool IsInteger() const

    # "" => false
    # "205" => false
    # "205."(false) => false
    # "205."(true) => true
    # ".51"(false) => false
    # ".51"(true) => true
    # "205.0" => true
    # "205.12" => true
    bool IsFractional(bool _allowMissingComponent = true) const

    # _index is outside the range of list => -1
    # <T> is utf8, utf16 or utf32 ->
    template<typename T> T codeUnitAt(int _index) const

    TRAVERSAL FUNCTIONS:

    bool can_reverse() const

    bool can_advance() const

    # traversalMode() == BOUNDED && position() - _value < 0 >> position() = position()
    # traversalMode() == BOUNDED && position() - _value > -1 >> position() = position() - _value
    # traversalMode() == CIRCULAR -> circular addition; (EXAMPLE) characterCount() = 19, position() = 4, back(9) >> position() = 14
    string& back(int _value)

    # traversalMode() == BOUNDED && position() + _value >= characterCount() >> position() = position()
    # traversalMode() == BOUNDED && position() + _value < characterCount() - 1 >> position() = position() + _value
    # traversalMode() == CIRCULAR -> circular addition; (EXAMPLE) characterCount() = 21, position() = 16, advance(10) >> position() = 5
    string& advance(int _value)

    CodePoint& previous() const

    # characterCount() > 0 ->
    CodePoint current() const

    CodePoint& next() const

    # the string has atleast one value ->
    CodePoint& last() const

    int set_position(int _position)

    # MUTATION FUNCTIONS:

    # acquire ownership of _string; after the operation is completed _string becomes invalid
    void Acquire(string& _string)

    # the bytes in _value represent a single character (in a specific encoding) and (are appended to &elements() in the same order as they are in _value)
    string& Append(const list<unsigned char>& _value)

    string& Append(CodePoint _value)

    string& Append(CodePoint _value, int _times)

    string& Append(const list<CodePoint>& _value)

    string& Append(const string& _value)

    # _size < 0 -> state of the list doesn't change
    string& Clear(int _size = 0)

    # [1, 2, 10].FillLeft(5, 7) => [5, 5, 5, 5, 1, 2, 10]
    string& FillLeft(CodePoint _value, int _length)

    # [1, 2, 10].FillRight(5, 7) => [1, 2, 10, 5, 5, 5, 5]
    string& FillRight(CodePoint _value, int _length)

    # (count() > 0 && _index > 0 && _index < characterCount()) ->
    string& Insert(CodePoint _value, int _index)

    # (count() > 0 && _index > 0 && (_index <= characterCount())) ->
    string& Insert(const string& _value, int _index)

    # [1, 2, 3, 4, 5].Move(2, 4) => [1, 2, 4, 5, 3]
    string& Move(int _sourceIndex, int _destinationIndex)

    # [11, 2, 10, 5, 4, 18, 9, 5, 0, 3].Reduce(2) => [10, 5, 4, 18, 9, 5]
    # [11, 2, 10, 5, 4, 18, 9, 5, 0, 3].Reduce(11) => [11, 2, 10, 5, 4, 18, 9, 5, 0, 3]
    string Reduce(int _reducer)

    # [11, 2, 10, 5, 4, 18, 9, 5, 0, 3].ReduceLeft(4) => [4, 18, 9, 5, 0, 3]
    # [11, 2, 10, 5, 4, 18, 9, 5, 0, 3].ReduceLeft(11) => [11, 2, 10, 5, 4, 18, 9, 5, 0, 3]
    string ReduceLeft(int _reducer)

    # [11, 2, 10, 5, 4, 18, 9, 5, 0, 3].ReduceRight(4) => [11, 2, 10, 5, 4, 18]
    # [11, 2, 10, 5, 4, 18, 9, 5, 0, 3].ReduceRight(11) => [11, 2, 10, 5, 4, 18, 9, 5, 0, 3]
    string ReduceRight(int _reducer)

    string& Remove(int _begin, int _end)

    string& Remove(const Range<int>& _range)

    string& RemoveAt(int _index, int _length = 1)

    # removes the elements that match _value
    # [1, 25, 4, 3, 4, 6, 5, 2, 41, 4, 52, 7, 8, 9].RemoveAll(4) => [1, 25, 3, 6, 5, 2, 41, 52, 7, 8, 9]
    string RemoveAll(CodePoint _value)

    # removes the elements that match an element elements of _set
    # [1, 2, 3, 4, 5, 6, 5, 2, 7, 8, 9].RemoveAll(2, 4, 5, 8) => [1, 3, 6, 7, 8, 9]
    string RemoveAll(const string& _set)

    string RemoveIf(const std::function<bool(CodePoint)>& _predicate)

    # [9, 2, 7].Repeat(2) => [9, 2, 7, 9, 2, 7, 9, 2, 7]
    string Repeat(int _times)

    # [5, 9, 0, 3, 7, 18, 4, 2, 6].Replace(4, 7, [2, 6, 1]) => [5, 9, 0, 3, 2, 6, 1, 6]
    string Replace(int _begin, int _end, const string& _replacement)

    # [5, 9, 0, 3, 7, 18, 4, 2, 6].Replace((4, 7), [2, 6, 1]) => [5, 9, 0, 3, 2, 6, 1, 6]
    string Replace(const Range<int>& _range, const string& _replacement)

    # replace every occurrence of _replaced with _replacement
    string& Replace(CodePoint _replaced, CodePoint _replacement)

    # replace every occurrence of _replaced with _replacement
    string& Replace(const string& _replaced, const string& _replacement)

    # [9, 7, 2, 5, 9, 0, 6, 2, 8, 4].Reverse() => [4, 8, 2, 6, 0, 9, 5, 2, 7, 9]
    string& Reverse()

    # [1, 2, 3, 4, 5].RotateLeft(3) => [4, 5, 1, 2, 3]
    string& RotateLeft(int _positions = 1)

    # [1, 2, 3, 4, 5].RotateRight(3) => [3, 4, 5, 1, 2]
    string& RotateRight(int _positions = 1)

    string& Set(int _index, CodePoint _value)

    # [9, 1, 5, 3, 0, 4, 7, 0, 6, 5, 1].Set(3, 5, 192) => [9, 1, 5, 192, 192, 192, 7, 0, 6, 5, 1]
    string& Set(int _begin, int _end, CodePoint _value)

    # [9, 1, 5, 3, 0, 4, 7, 0, 6, 5, 1].Set((3, 5), 192) => [9, 1, 5, 192, 192, 192, 7, 0, 6, 5, 1]
    string& Set(const Range<int>& _range, CodePoint _value)

    # [9, 1, 5, 3, 0, 4, 7, 0, 6, 5, 1].Set(3, [8, 2, 0, 1]) => [9, 1, 5, 8, 2, 0, 1, 0, 6, 5, 1]
    string& Set(int _begin, const list<bool>& _value)

    string& Swap(int _index1, int _index2)

    # [2, 2, 2, 5, 9, 0, 6, 2, 2, 2, 2, 2].Trim(2) => [5, 9, 0, 6]
    string& Trim(CodePoint _value)

    # [2, 2, 2, 5, 9, 0, 6, 2, 2, 2, 2, 2].TrimBegin(2) => [5, 9, 0, 6, 2, 2, 2, 2, 2]
    string& TrimBegin(CodePoint _value)

    # [2, 2, 2, 5, 9, 0, 6, 2, 2, 2, 2, 2].TrimEnd(2) => [2, 2, 2, 5, 9, 0, 6]
    string& TrimEnd(CodePoint _value)

    # NON-MUTATING FUNCTIONS:

    # [2, 9, 1].As()<float>() => [2.0, 9.0, 1.0]
    # T is a pointer type ->
    template<typename T> list<T*> As() const

    bool BeginsWith(const string& _value) const

    # returns 'true' if &this begins with atleast one of the sequences in _value
    # [8, 2, 5, 10, 7, 15, 12, 9, 1].BeginsWith([[5, 9, 1], [8, 1, 5], [9, 12, 0]]) => false
    # [8, 2, 5, 10, 7, 15, 12, 9, 1].BeginsWith([[5, 9, 1], [8, 2, 5], [9, 12, 0]]) => true
    bool BeginsWith(const list<string>& _values) const

    # returns the index of the specified element (if the elements exists)
    # the specified value does not exist => -1
    # the list is sorted in ascending order ->
    int BinarySearch(const T& _value) const

    # returns copy of &this
    string Clone() const

    bool Contains(CodePoint _value) const

    # [1, 2, 3, 4, 5, 6, 7, 8, 9].Contains([2, 3, 4]) => true
    bool Contains(const string& _value) const

    bool Contains(const std::function<bool(CodePoint)>& _predicate) const

    bool ContainsAll(const string& _set) const

    # [9, 7, 3, 20, 15, 18, 4, 7].ContainsAny([21, 8, 5, 1]) => false
    # [9, 7, 3, 20, 15, 18, 4, 7].ContainsAny([6, 30, 3, 1]) => true
    bool ContainsAny(const list<CodePoint>& _set) const

    bool ContainsOnly(CodePoint _value) const

    # [9, 1, 0, 3, 1, 5, 9, 1, 15, 3, 7, 5, 9, 1, 1].ContainsOnly([1, 9, 10]) => false
    # [9, 1, 0, 3, 1, 5, 9, 1, 15, 3, 7, 5, 9, 1, 1].ContainsOnly([5, 9, 1, 0, 7, 3, 15]) => true
    bool ContainsOnly(const list<CodePoint>& _set) const

    bool ContainsOnly(const std::function<bool(CodePoint)>& _predicate) const

    int CountOf(CodePoint _value) const

    # [5, 9, 1, 0, 3, 5, 9, 1, 4, 5, 9, 1, 10, 15, 3, 7, 5, 9, 1, 1].CountOf([5, 9, 1]) => 4
    # [5, 9, 1, 0, 3, 5, 9, 1, 4, 5, 9, 1, 10, 15, 3, 7, 5, 9, 1, 1].CountOf([5, 9, 1, 7]) => 0
    int CountOf(const string& _value) const

    int CountOf(const std::function<bool(CodePoint)>& _predicate) const

    # [7, 8, 3, 19, 20, 71, 15, 71, 3, 31, 108, 3]).Duplicates() => [3, 71]
    string Duplicates() const

    bool EndsWith(const string& _value) const

    bool EndsWithWith(const list<string>& _values) const

    # [2, 9, 0, 1, 4, 9, 7, 3].Except(9) => [2, 0, 1, 4, 7, 3]
    string Except(CodePoint _value) const

    # [2, 9, 0, 1, 4, 9, 7, 3].Except([9, 7, 0]) => [2, 1, 4, 3]
    string Except(const list<CodePoint>& _set) const

    string Except(const std::function<bool(CodePoint)>& _predicate) const

    bool HasDuplicates() const

    # the specified element does not exist or _begin is outside the range of string => -1
    int IndexOf(CodePoint _value, int _begin = 0) const

    # the specified element does not exist or _begin is outside the range of string => -1
    int IndexOf(const string& _value, int _begin = 0) const

    # the specified element does not exist or _begin is outside the range of string => -1
    int IndexOf(const std::function<bool(CodePoint)>& _predicate, int _begin = 0) const

    # the specified value does not exist or _begin is outside the range of string => -1
    int IndexOfAny(const list<CodePoint>& _set, int _begin = 0) const

    # _begin is outside the range of list => -2
    # [].IndexOf(4) => -1
    # [9, 9, 9, 5, 8, 10, 2, 7].IndexOfNot(9) => 3
    # [9, 9, 9, 5, 8, 10, 2, 7].IndexOfNot(4) => 0
    int IndexOfNot(const std::function<bool(CodePoint)>& _predicate, int _begin = 0) const

    # _begin is outside the range of list => -2
    # [].IndexOf(4) => -1
    # [9, 9, 9, 5, 8, 10, 2, 7].IndexOfNot(9) => 3
    # [9, 9, 9, 5, 8, 10, 2, 7].IndexOfNot(4) => 0
    int IndexOfNot(CodePoint _value, int _begin = 0) const

    # A = [5, 0, 3, 6]
      B = [3, 2, 4, 5, 9]
      IntersectionOf(A, B) => [3, 5] #
    static list<CodePoint> IntersectionOf(const string& _string1, const string& _string2)

    # the specified value does not exist => -1
    int LastIndexOf(CodePoint _value) const

    # the specified value does not exist => -1
    int LastIndexOf(const string& _value) const

    # the specified value does not exist => -1
    int LastIndexOf(const std::function<bool(CodePoint)>& _predicate) const

    # returns only values that are (between the beginning and a separator), (between separator and the end) or (between two separators)
    # empty sequences are generated (and eventually are appended to the result) only if they are between two separators
    # _ignoreEmptyValues = true -> empty sequences (if there are any) are not appended to the result
    # [41, 56, 3, 7, 18, 5, 19, 76, 15].Multisplit([353, 12]) => []
    # [41, 56, 3, 7, 18, 5, 19, 76, 15, 9, 20, 5].Multisplit([56, 9]) => [[41], [3, 7, 18, 5, 19, 76, 15], [20, 5]]
    # [9, 41, 56, 3, 7, 18, 5, 19, 76, 15, 9, 9, 20, 7].Multisplit([7, 9]) => [[41, 56, 3], [18, 5, 19, 76, 15], [], [20]]
    # [9, 41, 56, 3, 7, 18, 5, 19, 76, 15, 9, 9, 20, 7].Multisplit([7, 9], true) => [[41, 56, 3], [18, 5, 19, 76, 15], [20]]
    list<string> Multisplit(const list<CodePoint>& _set, bool _ignoreEmptyValues = false) const

    # returns the range of a sequence consisting of certain set of values (it is not mandatory for the sequence to contain each value in the set)
    # [3, 10, 15, 12, 8, 5, 7, 5, 5, 7, 7, 3, 9].RangeOf([2, 5, 7]) => (5, 10)
    # [3, 10, 15, 12, 8, 5, 7, 2, 2, 7, 7, 3, 9].RangeOf([2, 5, 7]) => (5, 10)
    # [3, 10, 15, 12, 0, 5, 7, 2, 2, 7, 7, 3, 9].RangeOf([4, 0, 1]) => (4, 4)
    # [3, 10, 15, 12, 8, 5, 7, 2, 2, 7, 7, 3, 9].RangeOf([4, 0, 1]) => (-1, -1)
    Range<int> RangeOf(const list<CodePoint>& _set, int _sindex = 0) const

    # returns the range of a sequence not consisting of certain set of values (it is mandatory for the sequence to not contain any of the values in the set)
    # [5, 7, 5, 5, 7, 7, 3, 10, 15, 12, 8, 2, 9].RangeOfNot([2, 5, 7]) => (6, 10)
    # [3, 10, 15, 12, 8, 5, 7, 2, 2, 7, 7, 3, 9].RangeOfNot([2, 5, 7]) => (0, 4)
    # [5, 7, 2, 2, 7, 7, 5, 4, 2, 7, 5].RangeOfNot([2, 5, 7]) => (7, 7)
    # [4, 0, 0, 1, 1, 4, 0, 1, 4, 4, 1].RangeOfNot([4, 0, 1]) => (-1, -1)
    Range<int> RangeOfNot(const list<CodePoint>& _set, int _sindex = 0) const

    # returns only values that are (between the beginning and a separator), (between separator and the end) or (between two separators)
    # empty sequences are generated (and eventually are appended to the result) only if they are between two separators
    # _ignoreEmptyValues = true -> empty sequences (if there are any) are not appended to the result
    # [3, 7, 18, 5, 19, 76, 15].Split(353) => []
    # [18, 5, 19, 76, 15, 9, 20, 5].Split(9) => [[18, 5, 19, 76, 15], [20, 5]]
    # [56, 3, 7, 18, 5, 19, 76, 7].Split(7) => [[56, 3], [18, 5, 19, 76]]
    # [56, 7, 7, 18, 5, 19, 76, 15, 9].Split(7) => [[56], [], [18, 5, 19, 76, 15, 9]]
    # [56, 7, 7, 18, 5, 19, 76, 15, 9].Split(7, true) => [[56], [18, 5, 19, 76, 15, 9]]
    # [7, 41, 56, 7, 18, 76, 15, 9, 7].Split(7) => [[41, 56], [18, 76, 15, 9]]
    # [7, 41, 56, 7, 7, 7, 18, 5, 15].Split(7) => [[41, 56], [], [], [18, 5, 15]]
    # [7, 41, 56, 7, 7, 7, 18, 5, 15].Split(7, true) => [[41, 56], [18, 5, 15]]
    list<string> Split(CodePoint _separator, bool _ignoreEmptyValues = false) const

    # returns only values that are (between the beginning and a separator), (between separator and the end) or (between two separators)
    # empty sequences are generated (and eventually are appended to the result) only if they are between two separators
    # _ignoreEmptyValues = true -> empty sequences (if there are any) are not appended to the result
    # [41, 56, 3, 5, 7, 18, 5, 19, 76, 15].Split([3, 8]) => []
    # [41, 56, 3, 5, 7, 18, 5, 19, 9, 7, 76, 15, 9].Split([9, 7]) => [[41, 56, 3, 5, 7, 18, 5, 19], [76, 15, 9]]
    # [41, 56, 3, 9, 7, 18, 5, 19, 76, 15, 9, 20, 9, 7].Split([9, 7]) => [[41, 56, 3], [18, 5, 19, 76, 15, 9, 20]]
    # [41, 56, 9, 7, 9, 7, 18, 5, 19, 76, 15, 9, 20, 3].Split([9, 7]) => [[41, 56], [], [18, 5, 19, 76, 15, 9, 20, 3]]
    # [41, 56, 9, 7, 9, 7, 18, 5, 19, 76, 15, 9, 20, 3].Split([9, 7], true) => [[41, 56], [18, 5, 19, 76, 15, 9, 20, 3]]
    # [9, 7, 41, 56, 9, 9, 7, 18, 76, 15, 9, 20, 3, 9, 7].Split([9, 7]) => [[41, 56, 9], [18, 76, 15, 9, 20, 3]]
    # [9, 7, 41, 56, 9, 7, 9, 7, 9, 7, 18].Split([9, 7]) => [[41, 56], [], [], [18]]
    # [9, 7, 41, 56, 9, 7, 9, 7, 9, 7, 18].Split([9, 7], true) => [[41, 56], [18]]
    list<string> Split(const string& _separator, bool _ignoreEmptyValues = false) const

    # returns only values that are (between the beginning and a separator), (between separator and the end) or (between two separators)
    # empty sequences are generated (and eventually are appended to the result) only if they are between two separators
    # _ignoreEmptyValues = true -> empty sequences (if there are any) are not appended to the result
    # [3, 7, 18, 5, 19, 76, 15].Split([](int x) { return x == 353; }) => []
    # [18, 5, 19, 76, 15, 9, 20, 5].Split([](int x) { return x == 9; }) => [[18, 5, 19, 76, 15], [20, 5]]
    # [56, 3, 7, 18, 5, 19, 76, 7].Split([](int x) { return x == 7; }) => [[56, 3], [18, 5, 19, 76]]
    # [56, 7, 7, 18, 5, 19, 76, 15, 9].Split([](int x) { return x == 7; }) => [[56], [], [18, 5, 19, 76, 15, 9]]
    # [56, 7, 7, 18, 5, 19, 76, 15, 9].Split([](int x) { return x == 7; }, true) => [[56], [18, 5, 19, 76, 15, 9]]
    # [7, 41, 56, 7, 18, 76, 15, 9, 7].Split([](int x) { return x == 7; }) => [[41, 56], [18, 76, 15, 9]]
    # [7, 41, 56, 7, 7, 7, 18, 5, 15].Split([](int x) { return x == 7; }) => [[41, 56], [], [], [18, 5, 15]]
    # [7, 41, 56, 7, 7, 7, 18, 5, 15].Split([](int x) { return x == 7; }, true) => [[41, 56], [18, 5, 15]]
    list<string> Split(const std::function<bool(CodePoint)>& _predicate, bool _ignoreEmptyValues = false) const

    # _length = 0 => [_begin..]
    # (_begin + _length) > characterCount() => {}
    string Sublist(int _begin, int _length = 0) const

    # [5, 8, 4, 1, 9, 6, 2, 3, 0, 5, 5, 1, 7].Subrange(2, 5) => [4, 1, 9, 6]
    string Subrange(int _begin, int _end) const

    # [5, 8, 4, 1, 9, 6, 2, 3, 0, 5, 5, 1, 7].Subrange((2, 5)) => [4, 1, 9, 6]
    string Subrange(const Range<int>& _range) const

    string Where(const std::function<bool(CodePoint)>& _predicate) const

    # A = [8, 19, 2, 5, 5, 0, 2, 7, 10, 4]
      B = [23, 21, 4, 7, 5, 19, 17, 26]
      UnionOf(A, B) => [8, 19, 2, 5, 0, 7, 10, 4, 23, 21, 17, 26] #
    static list<CodePoint> UnionOf(const string& _string1, const string& _string2)

    # [21, 35, 2, 9, 40, 31, 52, 9, 24, 52, 35, 18].Until(52) => [21, 35, 2, 9, 40, 31, 52, 9, 24]
    string Until(CodePoint _value) const

    # OTHER FUNCTIONS:

    # *this == "true" | "false" ->
    bool ToBool() const

    static string FromBool(bool _value)

    # the value of the number is outside the valid range for (long long) => incorrect value
    # the string is valid decimal value in the valid range for (long long) ->
    long long ToInteger(BINARY_, BitOrder _bitOrder) const

    # the value of the number is outside the valid range for (long long) => incorrect value
    # the string is valid decimal value in the valid range for (long long) ->
    long long ToInteger(DECIMAL_) const

    # the value of the number is outside the valid range for (unsigned long long) => incorrect value
    # the string is valid decimal value in the valid range for (unsigned long long) ->
    unsigned long long ToIntegerU(DECIMAL_) const

    # the value of the number is outside the valid range for (unsigned long long) => incorrect value
    # the string is valid hexadecimal value in the valid range for (unsigned long long) ->
    long long ToInteger(HEX_) const

    # _number < 1 quadrillion ->
    static string FromInteger(long long _number)

    # ".6" => 0.6
    # "23." => 23
    # "5" => 5.0
    # "5.1" => 5.1
    float ToFloat() const

    # ".6" => 0.6
    # "23." => 23
    # "5" => 5.0
    # "5.1" => 5.1
    double ToDouble() const

    # the current value of the string contains only ASCII characters ->
    const char* ToASCII() const

    # returns a list of UTF-32 characters
    # the string does not contain composite characters ->
    const char32_t* ToChar32() const

    # the string does not contain composite characters ->
    const wchar_t* ToWide() const

    list<char> ToBytes() const

    #

    void resize(int _size = -1)

# the value of _string contains only ASCII characters ->
void print(const string& _string)

-----------------------------------------------------------------------------------------

numeric.cpp:

(!) the functionality in this file is located in namespace 'numeric'

# TYPES:

enum class TraversalDirection = LEFT | RIGHT

enum class MagnitudeDirection = SMALLER | LARGER

# CONSTANTS:

[char] HEX_DIGITS = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F']

# FUNCTIONS:

template<typename T> T Abs(T _number)

# (8) => -8
# (-6) => 6
template<typename T> T Inverse(T _number)

bool IsEven(int N)

bool IsOdd(int N)

# (6.02645) => 0.02645
# (-18.823569) => 0.823569
# (0) => 0.0
double FractionOf(double N)

# (52, 5) => 2
# (7, 20) => 7
# (20, 7) => 6
# (0, 3) => 0
# N1 > 0, N2 > 0 ->
int Mod(int N1, int N2)

# (52.6, 5.0) => 2.6
# (5.0, 52.6) => 5.0
# (218.0749, 39.4) => 21.0749
# (0.0, 3.0) => 0.0
# N1 > 0.0, N2 > 0.0 ->
double Mod(double N1, double N2)

# _exponent < 0 => 0
# _exponent == 0 => 1
# _exponent > 0 ->
long long Pow(int _base, int _exponent)

# N1 == N2 => N2
int LargerOf(int N1, int N2)

# N1 == N2 => N2
double LargerOf(double N1, double N2)

# N1 == N2 => N2
int SmallerOf(int N1, int N2)

# N1 == N2 => N2
double SmallerOf(double N1, double N2)

# (89.4, 9106.7) => 4598.05
double AverageOf(double N1, double N2)

# (54, 182) => 98
# (182, 28) => 50
# _percent >= 0.0, _value >= 0.0 ->
double FromPercent(double _percent, double _value)

# (15, 782) => 1.9181585677749362
# (782, 15) => 5213.3333333333330
# N1 >= 0.0, N2 >= 0.0 ->
double ToPercent(double N1, double N2)

# (385.91) => 385.0
# (-2.36) => -3.0
int RoundDown(float _value)

# (385.91) => 385.0
# (-2.36) => -3.0
int RoundDown(double _value)

# (385.91) => 385.0
# (-2.36) => -3.0
long long RoundDown_L(float _value)

# (385.91) => 385.0
# (-2.36) => -3.0
long long RoundDown_L(double _value)

# (385.91) => 386.0
# (-2.36) => -2.0
int RoundUp(float _value)

# (385.91) => 386.0
# (-2.36) => -2.0
int RoundUp(double _value)

# (385.91) => 386.0
# (-2.36) => -2.0
long long RoundUp_L(float _value)

# (385.91) => 386.0
# (-2.36) => -2.0
long long RoundUp_L(double _value)

# (385.45 => 385.0
# (385.91) => 386.0
# (385.50) => 385.0
# (-2.36) => -2.0
# (-2.79) -> -3.0
# (-2.50) -> -3.0
float RoundToNearest(float _value)

# (385.45 => 385.0
# (385.91) => 386.0
# (385.50) => 385.0
# (-2.36) => -2.0
# (-2.79) -> -3.0
# (-2.50) -> -3.0
double RoundToNearest(double _value)

# (3, 5) => 2
# (5, 3) => 2
# (511, 96) => 415
# (96, 511) => 415
# (-4, 5) => 9
# (5, -4) => 9
# N == N => 0
int DistanceOf(int N1, int N2)

# _rangeBegin >= _rangeEnd => -1
# _currentValue < _rangeBegin || _value > _rangeEnd => -2
# _addition < 1 => -3
# (20, 35, 28, 9) => 21
# (20, 35, 28, 61) => 25
# (-8, 5, -3, 19) => 2
int CircularAddition(int _rangeBegin, int _rangeEnd, int _currentValue, int _addition)

# _rangeBegin >= _rangeEnd => -1
# _currentValue < _rangeBegin || _value > _rangeEnd => -2
# _subtraction < 1 => -3
# (20, 35, 28, 9) => 35
# (20, 35, 28, 61) => 31
# (-8, 5, -3, 19) => -8
int CircularSubtraction(int _rangeBegin, int _rangeEnd, int _currentValue, int _subtraction)

# _size is the size of _hex
unsigned long long ToDecimal(const char* _hex, int _size)

-----------------------------------------------------------------------------------------

bit_operations.cpp:

(!) the functionality in this file is located in namespace 'bit_operations'

# (!) bit index '0' specifies the least significant bit

# LSB :: Least Significant Bit, MSB :: Most Significant Bit

struct BitSet:

     BitSet() = default

     BitSet(unsigned short _bitCount) -> the value of each bit is 0

     BitSet(unsigned long long _value)

     BitSet(const BitSet&)

     BitSet& operator=(const BitSet&)

     int bitCount() const

     int byteCount() const

     unsigned char* byteSequence() const

     void SetBit(int _index, bool _value)

     bool GetBit(int _index) const

     # (0000000000).SetBits((111001), 3) => 0111001000
     void SetBits(const list<bool>& _bits, int _begin)

     # (0000000000).SetBits((111001), 3) => 0100111000
     void SetBitsReversed(const list<bool>& _bits, int _begin)

# Reverse<unsigned char>(01001010) => 01010010
# Reverse<unsigned short>(0000000001001010) => 0101001000000000
# Reverse<unsigned int>(00000100111001011110000000101010) => 01010100000001111010011100100000
# <T> = uchar | ushort | uint ->
template<typename T> T Reverse(T _sequence)

# _index >= 0 || _index <= 7 ->
bool GetBit(unsigned char _number, int _index)

# _index >= 0 || _index <= 15 ->
bool GetBit(unsigned short _number, int _index)

# _index >= 0 || _index <= 31 ->
bool GetBit(unsigned int _number, int _index)

# _index >= 0 || _index <= 63 ->
bool GetBit(unsigned long long _number, int _index)

# GetBits(53, 1, 3) => [0, 1, 0] = Dx2
# _begin >= 0 || _end <= 7, _begin < _end ->
unsigned char GetBits(unsigned char _number, int _begin, int _end)

# _begin >= 0 || _end <= 15, _begin < _end ->
unsigned short GetBits(unsigned short _number, int _begin, int _end)

# _begin >= 0 || _end <= 31, _begin < _end ->
unsigned int GetBits(unsigned int _number, int _begin, int _end)

# _index >= 0 || _index <= 7 ->
void SetBit(unsigned char& _number, int _index, bool _value)

# _index >= 0 || _index <= 15 ->
void SetBit(unsigned short& _number, int _index, bool _value)

# _index >= 0 || _index <= 31 ->
void SetBit(unsigned int& _number, int _index, bool _value)

# _index >= 0 || _index <= 63 ->
void SetBit(unsigned long long& _number, int _index, bool _value)

# SetBits(x = 236, 4, 7, 0b1011) -> x = 188
# _begin >= 0 || _end <= 7, _begin < _end ->
void SetBits(unsigned char& _number, int _begin, int _end, unsigned char _value)

# SetBits(x = 236, 4, 7, 0b1011) -> x = 188
# _begin >= 0 || _end <= 15, _begin < _end ->
void SetBits(unsigned short& _number, int _begin, int _end, unsigned short _value)

# SetBits(x = 236, 4, 7, 0b1011) -> x = 188
# _begin >= 0 || _end <= 31, _begin < _end ->
void SetBits(unsigned int& _number, int _begin, int _end, unsigned int _value)

# SetBits(x = 236, 4, 7, 0b1011) -> x = 188
# _begin >= 0 || _end <= 63, _begin < _end ->
void SetBits(unsigned long long& _number, int _begin, int _end, unsigned long long _value)

# SetBits(x = 0, 3, { 1, 1, 0, 0, 1 }) -> x = 11001000
# _bits.count() + _begin < 9 ->
void SetBits(unsigned char& _number, int _begin, const list<bool>& _bits)

# SetBits(x = 0, 3, { 1, 1, 0, 0, 1 }) -> x = 00...11001000
# _bits.count() + _begin < 17 ->
void SetBits(unsigned short& _number, int _begin, const list<bool>& _bits)

# SetBits(x = 0, 3, { 1, 1, 0, 0, 1 }) -> x = 00..11001000
# _bits.count() + _begin < 33 ->
void SetBits(unsigned int& _number, int _begin, const list<bool>& _bits)

# SetBits(x = 0, 3, { 1, 1, 0, 0, 1 }) -> x = 00..11001000
# _bits.count() + _begin < 65 ->
void SetBits(unsigned long long& _number, int _begin, const list<bool>& _bits)

# returns all bits of _value; the first bit in the list is LSB
# BitsOf(194) => [01000011]
list<bool> BitsOf(unsigned char _value)

# returns all bits of _value; the first bit in the list is LSB
# BitsOf(41092) => [0010000100000101]
list<bool> BitsOf(unsigned short _value)

# returns all bits of _value; the first bit in the list is LSB
# BitsOf(41092) => [00100001000001010000000000000000]
list<bool> BitsOf(unsigned int _value)

# returns all bits of _value; the first bit in the list is LSB
# BitsOf(41092) => [0010000100000101000000000000000000000000000000000000000000000000]
list<bool> BitsOf(unsigned long long _value)

# returns all bits of _value; the first bit in the list is LSB
# BitsOfR(194) => [11000010]
list<bool> BitsOfR(unsigned char _value)

# return all bits of _value; the first bit in the list is MSB
# BitsOfR(41092) => [1010000010000100]
list<bool> BitsOfR(unsigned short _value)

# return all bits of _value; the first bit in the list is SB
# BitsOfR(41092) => [00000000000000001010000010000100]
list<bool> BitsOfR(unsigned int _value)

# return all bits of _value; the first bit in the list is MSB
# BitsOfR(41092) => [0000000000000000000000000000000000000000000000001010000010000100]
list<bool> BitsOfR(unsigned long long _value)

# returns the number of bits needed for the binary representation of (the absolute value of _number)
int BitLengthOf(unsigned int _number)

# the first bit in the list is LSB
list<bool> SignificantBitsOf(unsigned char _value)

# the first bit in the list is LSB
list<bool> SignificantBitsOf(unsigned short _value)

# the first bit in the list is LSB
list<bool> SignificantBitsOf(unsigned int _value)

# the first bit in the list is LSB
list<bool> SignificantBitsOf(unsigned long long _value)

# the first bit in the list is MSB
list<bool> SignificantBitsOfR(unsigned char _value)

# the first bit in the list is MSB
list<bool> SignificantBitsOfR(unsigned short _value)

# the first bit in the list is MSB
list<bool> SignificantBitsOfR(unsigned int _value)

# the first bit in the list is MSB
list<bool> SignificantBitsOfR(unsigned long long _value)

-----------------------------------------------------------------------------------------

byte_operations.cpp:

(!) the functionality in this file is located in namespace 'byte_operations'

# (!) byte index '0' specifies the least significant byte

enum Endianity = LE | BE

# _index = 0..1 ->
unsigned char ByteOf(unsigned short _value, int _index)

# _index = 0..3 ->
unsigned char ByteOf(unsigned int _value, int _index)

# _index = 0..7 ->
unsigned char ByteOf(unsigned long long _value, int _index)

# (!) always returns 2 bytes (not just the significant byte)
# (!) the first byte in the list is LSB
list<unsigned char> BytesOf(unsigned short _value)

# (!) always returns 4 bytes (not just the significant bytes)
# (!) the first byte in the list is LSB
list<unsigned char> BytesOf(unsigned int _value)

# (!) always returns 8 bytes (not just the significant bytes)
# (!) the first byte in the list is LSB
list<unsigned char> BytesOf(unsigned long long _value)

# if _endianity has value 'LE' then 'a' is the least significant byte,
  respectively if _endianity has value 'BE' then 'a' is the most significant byte #
unsigned short _16(unsigned char a, unsigned char b, Endianity _endianity)

# if _endianity has value 'LE' then 'a' is the least significant byte and 'd' is the most significant byte,
  respectively if _endianity has value 'BE' then 'a' is the most significant byte and 'd' is the least significant byte #
unsigned int _32(unsigned char a, unsigned char b, unsigned char c, unsigned char d, Endianity _endianity)

# => unsigned int { _a[0], _a[1], _b[0], _b1 } where the first byte in the list is the least significant byte
unsigned int _32(unsigned short _a, unsigned short _b)

# if _endianity has value 'LE' then 'a' is the least significant byte and 'h' is the most significant byte,
  respectively if _endianity has value 'BE' then 'a' is the most significant byte and 'h' is the least significant byte #
unsigned long long _64(unsigned char a, unsigned char b, unsigned char c, unsigned char d, unsigned char e, unsigned char f, unsigned char g, unsigned char h, Endianity _endianity)

# => unsigned long long { _a[0], _a[1], _b[0], _b[1], _c[0], _c[1], _d[0], _d[1] } where the first byte in the list is the least significant byte
unsigned long long _64(unsigned short _a, unsigned short _b, unsigned short _c, unsigned short _d)

# => unsigned long long { _a[0], _a[1], _a[2], _a[3], _b[0], _b[1], _b[2], _b[3] } where the first byte in the list is the least significant byte
unsigned long long _64(unsigned int _a, unsigned int _b)

-----------------------------------------------------------------------------------------

unicode.cpp:

(!) the functionality in this file is located in namespace 'unicode'

# PSEUDONYMS:

# code unit of UTF-8
utf8 = unsigned char

# code unit of UTF-16
utf16 = unsigned short

# code unit of UTF-32
utf32 = unsigned int

# Unicode code point
CodePoint = unsigned int

# CONSTANTS:

list<unsigned char> UTF8_BOM = [0b11101111, 0b10111011, 0b10111111]

list<unsigned char> UTF16LE_BOM = [0b11111111, 0b11111110]

list<unsigned char> UTF16BE_BOM = [0b11111110, 0b11111111]

list<unsigned char> UTF32LE_BOM = [0b11111111, 0b11111110, 0b00000000, 0b00000000]

list<unsigned char> UTF32BE_BOM = [0b00000000, 0b00000000, 0b11111110, 0b11111111]

int UTF8_CODE_UNIT_LENGTH = 1 # in bytes

int UTF16_CODE_UNIT_LENGTH = 2 # in bytes

int UTF32_CODE_UNIT_LENGTH = 4 # in bytes

const int BASIC_MULTILINGUAL_PLANE_BEGIN = 0;
const int BASIC_MULTILINGUAL_PLANE_END = 65535;

const int SUPPLEMENTARY_MULTILINGUAL_PLANE_BEGIN = 65536;
const int SUPPLEMENTARY_MULTILINGUAL_PLANE_END = 131071;

const int SUPPLEMENTARY_IDEOGRAPHIC_PLANE_BEGIN = 131072;
const int SUPPLEMENTARY_IDEOGRAPHIC_PLANE_END = 196607;

const int SUPPLEMENTARY_SPECIAL_PURPOSE_PLANE_BEGIN = 917504;
const int SUPPLEMENTARY_SPECIAL_PURPOSE_PLANE_END = 983039;

const int PRIVATE_USE_AREA1_BEGIN = 57344;
const int PRIVATE_USE_AREA1_END = 63743;

const int PRIVATE_USE_AREA2_BEGIN = 983040;
const int PRIVATE_USE_AREA2_END = 1048573;

const int PRIVATE_USE_AREA3_BEGIN = 1048576;
const int PRIVATE_USE_AREA3_END = 1114109;

const int BASIC_LATIN_BEGIN = 0;
const int BASIC_LATIN_END = 127;

const int ARABIC_DIGITS_BEGIN = 48;
const int ARABIC_DIGITS_END = 57;

const int LATIN1_SUPPLEMENT_BEGIN = 128;
const int LATIN1_SUPPLEMENT_END = 255;

const int LATIN_EXTENDED_A_BEGIN = 256;
const int LATIN_EXTENDED_A_END = 383;

const int LATIN_EXTENDED_B_BEGIN = 384;
const int LATIN_EXTENDED_B_END = 591;

const int IPA_EXTENSIONS_BEGIN = 592;
const int IPA_EXTENSIONS_END = 687;

const int SPACING_MODIFIER_LETTERS_BEGIN = 688;
const int SPACING_MODIFIER_LETTERS_END = 767;

const int COMBINING_DIACRITICAL_MARKS_BEGIN = 768;
const int COMBINING_DIACRITICAL_MARKS_END = 879;

const int GREEK_AND_COPTIC_BEGIN = 880;
const int GREEK_AND_COPTIC_END = 1023;

const int CYRILLIC_BEGIN = 1024;
const int CYRILLIC_END = 1279;

const int CYRILLIC_SUPPLEMENT_BEGIN = 1280;
const int CYRILLIC_SUPPLEMENT_END = 1327;

const int ARMENIAN_BEGIN = 1328;
const int ARMENIAN_END = 1423;

const int HEBREW_BEGIN = 1424;
const int HEBREW_END = 1535;

const int ARABIC_BEGIN = 1536;
const int ARABIC_END = 1791;

const int SYRIAC_BEGIN = 1792;
const int SYRIAC_END = 1871;

const int ARABIC_SUPPLEMENT_BEGIN = 1872;
const int ARABIC_SUPPLEMENT_END = 1919;

const int THAANA_BEGIN = 1920;
const int THAANA_END = 1983;

const int NKO_BEGIN = 1984;
const int NKO_END = 2047;

const int SAMARITAN_BEGIN = 2048;
const int SAMARITAN_END = 2111;

const int MANDAIC_BEGIN = 2112;
const int MANDAIC_END = 2143;

const int SYRIAC_SUPPLEMENT_BEGIN = 2144;
const int SYRIAC_SUPPLEMENT_END = 2159;

const int ARABIC_EXTENED_B_BEGIN = 2160;
const int ARABIC_EXTENDED_B_END = 2207;

const int ARABIC_EXTENDED_A_BEGIN = 2208;
const int ARABIC_EXTENDED_A_END = 2303;

const int DEVANAGARI_BEGIN = 2304;
const int DEVANAGARI_END = 2431;

const int BENGALI_BEGIN = 2432;
const int BENGALI_END = 2599;

const int GURMUKHI_BEGIN = 2560;
const int GURMUKHI_END = 2687;

const int GUJARATI_BEGIN = 2688;
const int GUJARATI_END = 2815;

const int ORIYA_BEGIN = 2816;
const int ORIYA_END = 2943;

const int TAMIL_BEGIN = 2944;
const int TAMIL_END = 3071;

const int TELUGU_BEGIN = 3072;
const int TELUGU_END = 3199;

const int KANNADA_BEGIN = 3200;
const int KANNADA_END = 3327;

const int MALAYALAM_BEGIN = 3328;
const int MALAYALAM_END = 3455;

const int SINHALA_BEGIN = 3456;
const int SINHALA_END = 3583;

const int THAI_BEGIN = 3584;
const int THAI_END = 3711;

const int LAO_BEGIN = 3712;
const int LAO_END = 3839;

const int TIBETAN_BEGIN = 3840;
const int TIBETAN_END = 4095;

const int MYANMAR_BEGIN = 4096;
const int MYANMAR_END = 4255;

const int GEORGIAN_BEGIN = 4256;
const int GEORGIAN_END = 4351;

const int HANGUL_JAMO_BEGIN = 4352;
const int HANGUL_JAMO_END = 4607;

const int ETHIOPIC_BEGIN = 4608;
const int ETHIOPIC_END = 4991;

const int ETHIOPIC_SUPPLEMENT_BEGIN = 4992;
const int ETHIOPIC_SUPPLEMENT_END = 5023;

const int CHEROKEE_BEGIN = 5024;
const int CHEROKEE_END = 5119;

const int UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS_BEGIN = 5120;
const int UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS_END = 5759;

const int OGHAM_BEGIN = 5760;
const int OGHAM_END = 5791;

const int RUNIC_BEGIN = 5792;
const int RUNIC_END = 5887;

const int TAGALOG_BEGIN = 5888;
const int TAGALOG_END = 5919;

const int HANUOO_BEGIN = 5920;
const int HANUOO_END = 5951;

const int BUHID_BEGIN = 5952;
const int BUHID_END = 5983;

const int TAGBANWA_BEGIN = 5984;
const int TAGBANWA_END = 6015;

const int KHMER_BEGIN = 6016;
const int KHMER_END = 6143;

const int MONGOLIAN_BEGIN = 6144;
const int MONGOLIAN_END = 6319;

const int UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS_EXTENDED_BEGIN = 6320;
const int UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS_EXTENDED_END = 6399;

const int LIMBU_BEGIN = 6400;
const int LIMBU_END = 6479;

const int TAI_LE_BEGIN = 6480;
const int TAI_LE_END = 6527;

const int NEW_TAI_LUE_BEGIN = 6528;
const int NEW_TAI_LUE_END = 6623;

const int KHMER_SYMBOLS_BEGIN = 6624;
const int KHMER_SYMBOLS_END = 6655;

const int BUGINESE_BEGIN = 6656;
const int BUGINESE_END = 6687;

const int TAI_THAM_BEGIN = 6688;
const int TAI_THAM_END = 6831;

const int COMBINING_DIACRITICAL_MARKS_EXTENDED_BEGIN = 6832;
const int COMBINING_DIACRITICAL_MARKS_EXTENDED_END = 6911;

const int BALINESE_BEGIN = 6912;
const int BALINESE_END = 7039;

const int SUNDANESE_BEGIN = 7040;
const int SUNDANESE_END = 7103;

const int BATAK_BEGIN = 7104;
const int BATAK_END = 7167;

const int LEPCHA_BEGIN = 7168;
const int LEPCHA_END = 7247;

const int OL_CHIKI_BEGIN = 7248;
const int OL_CHIKI_END = 7295;

const int CYRILLIC_EXTENDED_C_BEGIN = 7296;
const int CYRILLIC_EXTENDED_C_END = 7311;

const int GEORGIAN_EXTENDED_BEGIN = 7312;
const int GEORGIAN_EXTENDED_END = 7359;

const int SUNDANESE_SUPPLEMENT_BEGIN = 7360;
const int SUNDANESE_SUPPLEMENT_END = 7375;

const int VEDIC_EXTENSIONS_BEGIN = 7376;
const int VEDIC_EXTENSIONS_END = 7423;

const int PHONETIC_EXTENSIONS_BEGIN = 7424;
const int PHONETIC_EXTENSIONS_END = 7551;

const int PHONETIC_EXTENSIONS_SUPPLEMENT_BEGIN = 7552;
const int PHONETIC_EXTENSIONS_SUPPLEMENT_END = 7615;

const int COMBINING_DIACRITICAL_MARKS_SUPPLEMENT_BEGIN = 7616;
const int COMBINING_DIACRITICAL_MARKS_SUPPLEMENT_END = 7679;

const int LATIN_EXTENDED_ADDITIONAL_BEGIN = 7680;
const int LATIN_EXTENDED_ADDITIONAL_END = 7935;

const int GREEK_EXTENDED_BEGIN = 7936;
const int GREEK_EXTENDED_END = 8191;

const int GENERAL_PUNCTUATION_BEGIN = 8192;
const int GENERAL_PUNCTUATION_END = 8303;

const int SUPERSCRIPTS_AND_SUBSCRIPTS_BEGIN = 8304;
const int SUPERSCRIPTS_AND_SUBSCRIPTS_END = 8351;

const int CURRENCY_SYMBOLS_BEGIN = 8352;
const int CURRENCY_SYMBOLS_END = 8399;

const int COMBINING_DIACRITICAL_MARKS_FOR_SYMBOLS_BEGIN = 8400;
const int COMBINING_DIACRITICAL_MARKS_FOR_SYMBOLS_END = 8447;

const int LETTERLIKE_SYMBOLS_BEGIN = 8448;
const int LETTERLIKE_SYMBOLS_END = 8527;

const int NUMBER_FORMS_BEGIN = 8528;
const int NUMBER_FORMS_END = 8591;

const int ARROWS_BEGIN = 8592;
const int ARROWS_END = 8703;

const int MATHEMATICAL_OPERATORS_BEGIN = 8704;
const int MATHEMATICAL_OPERATORS_END = 8959;

const int MISCELLANEOUS_TECHNICAL_BEGIN = 8960;
const int MISCELLANEOUS_TECHNICAL_END = 9215;

const int CONTROL_PICTURES_BEGIN = 9216;
const int CONTROL_PICTURES_END = 9279;

const int OPTICAL_CHARACTER_RECOGNITION_BEGIN = 9280;
const int OPTICAL_CHARACTER_RECOGNITION_END = 9311;

const int ENCLOSED_ALPHANUMERICS_BEIGN = 9312;
const int ENCLOSED_ALPHANUMERICS_END = 9471;

const int BOX_DRAWING_BEGIN = 9472;
const int BOX_DRAWING_END = 9599;

const int BLOCK_ELEMENTS_BEGIN = 9600;
const int BLOCK_ELEMENTS_END = 9631;

const int GEOMETRIC_SHAPES_BEGIN = 9632;
const int GEOMETRIC_SHAPES_END = 9727;

const int MISCELLANEOUS_SYMBOLS_BEGIN = 9728;
const int MISCELLANEOUS_SYMBOLS_END = 9983;

const int DINGBATS_BEGIN = 9984;
const int DINGBATS_END = 10175;

const int MISCELLANEOUS_MATHEMATICAL_SYMBOLS_A_BEGIN = 10176;
const int MISCELLANEOUS_MATHEMATICAL_SYMBOLS_A_END = 10223;

const int SUPPLEMENTAL_ARROWS_A_BEGIN = 10224;
const int SUPPLEMENTAL_ARROWS_A_END = 10239;

const int BRAILLE_PATTERNS_BEGIN = 10240;
const int BRAILLE_PATTERNS_END = 10495;

const int SUPPLEMENTAL_ARROWS_B_BEGIN = 10496;
const int SUPPLEMENTAL_ARROWS_B_END = 10623;

const int MISCELLANEOUS_MATHEMATICAL_SYMBOLS_B_BEGIN = 10624;
const int MISCELLANEOUS_MATHEMATICAL_SYMBOLS_B_END = 10751;

const int SUPPLEMENTAL_MATHEMATICAL_OPERATORS_BEGIN = 10752;
const int SUPPLEMENTAL_MATHEMATICAL_OPERATORS_END = 11007;

const int MISCELLANEOUS_SYMBOLS_AND_ARROWS_BEIGN = 11008;
const int MISCELLANEOUS_SYMBOLS_AND_ARROWS_END = 11263;

const int GLATOLITIC_BEGIN = 11264;
const int GLATOLITIC_END = 11359;

const int LATIN_EXTENDED_C_BEGIN = 11360;
const int LATIN_EXTENDED_C_END = 11391;

const int COPTIC_BEIGN = 11392;
const int COPTIC_END = 11519;

const int GEORGIAN_SUPPLEMENT_BEGIN = 11520;
const int GEORGIAN_SUPPLEMENT_END = 11567;

const int TIFINAGH_BEGIN = 11568;
const int TIFINAGH_END = 11647;

const int ETHIOPIC_EXTENDED_BEGIN = 11648;
const int ETHIOPIC_EXTENDED_END = 11743;

const int CYRILLIC_EXTENDED_A_BEGIN = 11744;
const int CYRILLIC_EXTENDED_A_END = 11775;

const int SUPPLEMENTAL_PUNCTUATION_BEGIN = 11776;
const int SUPPLEMENTAL_PUNCTUATION_END = 11903;

const int CJK_RADICALS_SUPPLEMENT_BEGIN = 11904;
const int CJK_RADICALS_SUPPLEMENT_END = 12031;

const int KANGXI_RADICALS_BEGIN = 12032;
const int KANGXI_RADICALS_END = 12255;

const int IDEOGRAPHIC_DESCRIPTION_CHARACTERS_BEGIN = 12272;
const int IDEOGRAPHIC_DESCRIPTIONS_CHARACTERS_END = 12287;

const int CJK_SYMBOLS_AND_PUNCTUATION_BEGIN = 12288;
const int CJK_SYMBOLS_AND_PUNCTUATION_END = 12351;

const int HIRAGANA_BEGIN = 12352;
const int HIRAGANA_END = 12447;

const int KATAKANA_BEGIN = 12448;
const int KATAKANA_END = 12543;

const int BOPOMOFO_BEGIN = 12544;
const int BOPOMOFO_END = 12591;

const int HANGUL_COMPATIBILITY_JAMO_BEGIN = 12592;
const int HANGUL_COMPATIBILITY_JAMO_END = 12687;

const int KANBUN_BEGIN = 12688;
const int KANBUN_END = 12703;

const int BOPOMOFO_EXTENDED_BEGIN = 12704;
const int BOPOMOFO_EXTENDED_END = 12735;

const int CJK_STROKES_BEGIN = 12736;
const int CJK_STROKES_END = 12783;

const int KATAKANA_PHONETIC_EXTENSIONS_BEGIN = 12784;
const int KATAKANA_PHONETIC_EXTENSIONS_END = 12799;

const int ENCLOSED_CJK_LETTERS_AND_MONTHS_BEGIN = 12800;
const int ENCLOSED_CJK_LETTERS_AND_MONTHS_END = 13055;

const int CJK_COMPATIBILITY_BEGIN = 13056;
const int CJK_COMPATIBILITY_END = 13311;

const int CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A_BEGIN = 13312;
const int CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A_END = 19903;

const int YIJING_HEXAGRAM_SYMBOLS_BEGIN = 19904;
const int YIJING_HEXAGRAM_SYMBOLS_END = 19967;

const int CJK_UNIFIED_IDEOGRAPHS_BEGIN = 19968;
const int CJK_UNIIFED_IDEOGRAPHS_END = 40959;

const int YI_SYLLABLES_BEGIN = 40960;
const int YI_SYLLABLES_END = 42127;

const int YI_RADICALS_BEGIN = 42128;
const int YI_RADICALS_END = 42191;

const int LISU_BEGIN = 42192;
const int LISU_END = 42239;

const int VAI_BEGIN = 42240;
const int VAI_END = 42559;

const int CYRILLIC_EXTENDED_B_BEGIN = 42560;
const int CYRILLIC_EXTENDED_B_END = 42655;

const int BAMUM_BEGIN = 42656;
const int BAMUM_END = 42751;

const int MODIFIER_TONE_LETTERS_BEGIN = 42752;
const int MODIFIER_TONE_LETTERS_END = 42783;

const int LATIN_EXTENDED_D_BEGIN = 42784;
const int LATIN_EXTENDED_D_END = 43007;

const int SYLOTI_NAGRI_BEGIN = 43008;
const int SYLOTI_NAGRI_END = 43055;

const int COMMON_INDIC_NUMBER_FORMS_BEGIN = 43056;
const int COMMON_INDIC_NUMBER_FOMRS_END = 43071;

const int PHAGS_PA_BEGIN = 43072;
const int PHAGS_PA_END = 43135;

const int SAURASHTRA_BEGIN = 43136;
const int SAURASHTRA_END = 43231;

const int DEVANAGARI_EXTENDED_BEGIN = 43232;
const int DEVANAGARI_EXTENDED_END = 43263;

const int KAYAH_LI_BEGIN = 43264;
const int KAYAH_LI_END = 43311;

const int REJANG_BEGIN = 43312;
const int REJANG_END = 43359;

const int HANGUL_JAMO_EXTENDED_A_BEGIN = 43360;
const int HANGUL_JAMO_EXTENDED_A_END = 43391;

const int JAVANESE_BEGIN = 43392;
const int JAVANESE_END = 43487;

const int MYANMAR_EXTENDED_B_BEGIN = 43488;
const int MYANMAR_EXTENDED_B_END = 43519;

const int CHAM_BEGIN = 43520;
const int CHAM_END = 43615;

const int MYANMAR_EXTENDED_A_BEGIN = 43616;
const int MYANMAR_EXTENDED_A_END = 43647;

const int TAI_VIET_BEGIN = 43648;
const int TAI_VIET_END = 43743;

const int MEETEI_MAYEK_EXTENSIONS_BEGIN = 43744;
const int MEETEI_MAYEK_EXTENSIONS_END = 43775;

const int ETHIOPIC_EXTENDED_A_BEGIN = 43776;
const int ETHIOPIC_EXTENDED_A_END = 43823;

const int LATIN_EXTENDED_E_BEGIN = 43824;
const int LATIN_EXTENDED_E_END = 43887;

const int CHEROKEE_SUPPLEMENT_BEGIN = 43888;
const int CHEROKEE_SUPPLEMENT_END = 43967;

const int MEETEI_MAYEK_BEGIN = 43968;
const int MEETEI_MAYEK_END = 44031;

const int HANGUL_SYLLABLES_BEGIN = 44032;
const int HANGUL_SYLLABLES_END = 55215;

const int HANGUL_JAMO_EXTENDED_B_BEGIN = 55216;
const int HANGUL_JAMO_EXTENDED_B_END = 55295;

const int HIGH_SURROGATES_BEGIN = 55296;
const int HIGH_SURROGATES_END = 56319;

const int HIGH_SURROGATES_NON_PRIVATE_BEGIN = 55296;
const int HIGH_SURROGATES_NON_PRIVATE_END = 56191;

const int HIGH_PRIVATE_USE_SURROGATES_BEGIN = 56192;
const int HIGH_PRIVATE_USE_SURROGATES_END = 56319;

const int LOW_SURROGATES_BEGIN = 56320;
const int LOW_SURROGATES_END = 57343;

const int PRIVATE_USE_AREA_BEGIN = 57344;
const int PRIVATE_USE_AREA_END = 63743;

const int CJK_COMPATIBILITY_IDEOGRAPHS_BEGIN = 63744;
const int CJK_COMPATIBILITY_IDEOGRAPHS_END = 64255;

const int ALPHABETIC_PRESENTATION_FORMS_BEGIN = 64256;
const int ALPHABETIC_PRESENTATION_FORMS_END = 64335;

const int ARABIC_PRESENTATION_FORMS_A_BEGIN = 64336;
const int ARABIC_PRESENTATION_FORMS_A_END = 65023;

const int VARIATION_SELECTORS_BEGIN = 65024;
const int VARIATION_SELECTORS_END = 65039;

const int VERTICAL_FORMS_BEGIN = 65040;
const int VERTICAL_FORMS_END = 65055;

const int COMBINING_HALF_MARKS_BEGIN = 65056;
const int COMBINING_HALF_MARKS_END = 65071;

const int CJK_COMPATIBILITY_FORMS_BEGIN = 65072;
const int CJK_COMPATIBILITY_FORMS_END = 65103;

const int SMALL_FORM_VARIANTS_BEGIN = 65104;
const int SMALL_FORM_VARIANTS_END = 65135;

const int ARABIC_PRESENTATION_FORMS_B_BEGIN = 65136;
const int ARABIC_PRESENTATION_FORMS_B_END = 65279;

const int HALFWIDTH_AND_FULLWIDTH_FORMS_BEGIN = 65280;
const int HALFWIDTH_AND_FULLWIDTH_FORMS_END = 65519;

const int SPECIALS_BEGIN = 65520;
const int SPECIALS_END = 65535;

const int LINEAR_B_SYLLABARY_BEGIN = 65536;
const int LINEAR_B_SYLLABARY_END = 65663;

const int LINEAR_B_IDEOGRAMS_BEGIN = 65664;
const int LINEAR_B_IDEOGRAMS_END = 65791;

const int AEGEAN_NUMBERS_BEGIN = 65792;
const int AEGEAN_NUMBERS_END = 65855;

const int ANCIENT_GREEK_NUMBERS_BEGIN = 65856;
const int ANCIENT_GREEK_NUMBERS_END = 65935;

const int ANCIENT_SYMBOLS_BEGIN = 65936;
const int ANCIENT_SYMBOLS_END = 65999;

const int PHAISTOS_DISC_BEGIN = 66000;
const int PHAISTOS_DISC_END = 66047;

const int LYCIAN_BEGIN = 66176;
const int LYCIAN_END = 66207;

const int CARIAN_BEGIN = 66208;
const int CARIAN_END = 66271;

const int COPTIC_EPACT_NUMEBRS_BEGIN = 66272;
const int COPTIC_EPACT_NUMBERS_END = 66303;

const int OLD_ITALIC_BEGIN = 66304;
const int OLD_ITALIC_END = 66351;

const int GOTHIC_BEGIN = 66352;
const int GOTHIC_END = 66383;

const int OLD_PERMIC_BEGIN = 66384;
const int OLD_PERMIC_END = 66431;

const int UGARITIC_BEGIN = 66432;
const int UGARITIC_END = 66463;

const int OLD_PERSIAN_BEGIN = 66464;
const int OLD_PERSIAN_END = 66527;

const int DESERET_BEGIN = 66560;
const int DESERET_END = 66639;

const int SHAVIAN_BEGIN = 66640;
const int SHAVIAN_END = 66687;

const int OSMANYA_BEGIN = 66688;
const int OSMANYA_END = 66735;

const int OSAGE_BEGIN = 66736;
const int OSAGE_END = 66815;

const int ELBASAN_BEGIN = 66816;
const int ELBASAN_END = 66863;

const int CAUCASIAN_ALBANIAN_BEGIN = 66864;
const int CAUCASIAN_ALBANIAN_END = 66927;

const int VITHKUQI_BEGIN = 66928;
const int VITHKUQI_END = 67007;

const int LINEAR_A_BEGIN = 67072;
const int LINEAR_A_END = 67455;

const int LATIN_EXTENDED_F_BEGIN = 67456;
const int LATIN_EXTENDED_F_END = 67519;

const int CYPRIOT_SYLLABARY_BEGIN = 67584;
const int CYPRIOT_SYLLABARY_END = 67647;

const int IMPERIAL_ARAMAIC_BEGIN = 67648;
const int IMPERIAL_ARAMAIC_END = 67679;

const int PALMYRENE_BEGIN = 67680;
const int PALMYRENE_END = 67711;

const int NABATAEAN_BEGIN = 67712;
const int NABATAEAN_END = 67759;

const int HATRAN_BEGIN = 67808;
const int HATRAN_END = 67839;

const int PHOENICIAN_BEGIN = 67840;
const int PHOENICIAN_END = 67871;

const int LYDIAN_BEIGN = 67872;
const int LYDIAN_END = 67903;

const int MEROITIC_HIEROGLYPHS_BEGIN = 67968;
const int MEROITIC_HIEROGLYPHS_END = 67999;

const int MEROITIC_CURSIVE_BEGIN = 68000;
const int MEROITIC_CURSIVE_END = 68095;

const int KHAROSHTHI_BEGIN = 68096;
const int KHAROSHTHI_END = 68191;

const int OLD_SOUTH_ARABIAN_BEGIN = 68192;
const int OLD_SOUTH_ARABIAN_END = 68223;

const int OLD_NORTH_ARABIAN_BEGIN = 68224;
const int OLD_NORTH_ARABIAN_END = 68255;

const int MANICHAEAN_BEGIN = 68288;
const int MANICHAEAN_END = 68351;

const int AVESTAN_BEGIN = 68352;
const int AVESTAN_END = 68415;

const int INSCRIPTIONAL_PARTHIAN_BEGIN = 68416;
const int INSCRIPTIONAL_PARTHIAN_END = 68447;

const int INSCRIPTIONAL_PAHLAVI_BEGIN = 68448;
const int INSCRIPTIONAL_PAHLAVI_END = 68479;

const int PSALTER_PAHLAVI_BEGIN = 68480;
const int PSALTER_PAHLAVI_END = 68527;

const int OLD_TURKIC_BEGIN = 68608;
const int OLD_TURKIC_END = 68687;

const int OLD_HUNGARIAN_BEGIN = 68736;
const int OLD_HUNGARIAN_END = 68863;

const int HANIFI_ROHINGYA_BEGIN = 68864;
const int HANIFI_ROHINGYA_END = 68927;

const int RUMI_NUMERAL_SYMBOLS_BEGIN = 69216;
const int RUMI_NUMERAL_SYMBOLS_END = 69247;

const int YEZIDI_BEGIN = 69248;
const int YEZIDI_END = 69311;

const int ARABIC_EXTENDED_C_BEGIN = 69312;
const int ARABIC_EXTENDED_C_END = 69375;

const int OLD_SOGDIAN_BEGIN = 69376;
const int OLD_SOGDIAN_END = 69423;

const int SOGDIAN_BEGIN = 69424;
const int SOGDIAN_END = 69487;

const int OLD_UYGHUR_BEGIN = 69488;
const int OLD_UYGHUR_END = 69551;

const int CHORASMIAN_BEGIN = 69552;
const int CHORASMIAN_END = 69599;

const int ELYMAIC_BEGIN = 69600;
const int ELYMAIC_END = 69631;

const int BRAHMI_BEGIN = 69632;
const int BRAHMI_END = 69759;

const int KAITHI_BEGIN = 69760;
const int KAITHI_END = 69839;

const int SORA_SOMPENG_BEGIN = 69840;
const int SORA_SOMPENG_END = 69887;

const int CHAKMA_BEGIN = 69888;
const int CHAKMA_END = 69967;

const int MAHAJANI_BEGIN = 69968;
const int MAHAJANI_END = 70015;

const int SHARADA_BEGIN = 70016;
const int SHARADA_END = 70111;

const int SINHALA_ARCHAIC_NUMBERS_BEGIN = 70112;
const int SINHALA_ARCHAIC_NUMBERS_END = 70143;

const int KHOJKI_BEGIN = 70144;
const int KHOJKI_END = 70223;

const int MULTANI_BEGIN = 70272;
const int MULTANI_END = 70319;

const int KHUDAWADI_BEGIN = 70320;
const int KHUDAWADI_END = 70399;

const int GRANTHA_BEGIN = 70400;
const int GRANTHA_END = 70527;

const int NEWA_BEGIN = 70656;
const int NEWA_END = 70783;

const int TIRHUTA_BEGIN = 70784;
const int TIRHUTA_END = 70879;

const int SIDDHAM_BEGIN = 71040;
const int SIDDHAM_END = 71167;

const int MODI_BEGIN = 71168;
const int MODI_END = 71263;

const int MONGOLIAN_SUPPLEMENT_BEGIN = 71264;
const int MONGOLIAN_SUPPLEMENT_END = 71295;

const int TAKRI_BEGIN = 71296;
const int TAKRI_END = 71375;

const int AHOM_BEGIN = 71424;
const int AHOM_END = 71503;

const int DOGRA_BEGIN = 71680;
const int DOGRA_END = 71759;

const int WARANG_CITI_BEGIN = 71840;
const int WARANG_CITI_END = 71935;

const int DIVES_AKURU_BEGIN = 71936;
const int DIVES_AKURU_END = 72031;

const int NANDINAGARI_BEGIN = 72096;
const int NANDINAGARI_END = 72191;

const int ZANABAZAR_SQUARE_BEGIN = 72192;
const int ZANABAZAR_SQUARE_END = 72271;

const int SOYOMBO_BEGIN = 72272;
const int SOYOMBO_END = 72367;

const int PAU_CIN_HAU_BEGIN = 72384;
const int PAU_CIN_HAU_END = 72447;

const int DEVANAGARI_EXTENDED_A_BEGIN = 72448;
const int DEVANAGARI_EXTENDED_A_END = 72543;

const int BHAIKSUKI_BEGIN = 72704;
const int BHAIKSUKI_END = 72815;

const int MARCHEN_BEGIN = 72816;
const int MARCHEN_END = 72895;

const int MASARAM_GONDI_BEGIN = 72960;
const int MASARAM_GONDI_END = 73055;

const int GUNJALA_GONDI_BEGIN = 73056;
const int GUNJALA_GONDI_END = 73135;

const int MAKASAR_BEGIN = 73440;
const int MAKASAR_END = 73471;

const int KAWI_BEGIN = 73472;
const int KAWI_END = 73567;

const int LISU_SUPPLEMENT_BEGIN = 73648;
const int LISU_SUPPLEMENT_END = 73663;

const int TAMIL_SUPPLEMENT_BEGIN = 73664;
const int TAMIL_SUPPLEMENT_END = 73727;

const int CUNEIFORM_BEIGN = 73728;
const int CUNEIFORM_END = 74751;

const int CUNEIFORM_NUMBERS_AND_PUNCTUATION_BEGIN = 74752;
const int CUNEIFORM_NUMBERS_AND_PUNCTUATION_END = 74879;

const int EARLY_DYNASTIC_CUNEIFORM_BEGIN = 74880;
const int EARLY_DYNASTIC_CUNEIFORM_END = 75087;

const int CYPRO_MINOAN_BEGIN = 77712;
const int CYPRO_MINOAN_END = 77823;

const int EGYPTIAN_HIEROGLYPHS_BEGIN = 77824;
const int EGYPTIAN_HIEROGLYPHS_END = 78895;

const int EGYPTIAN_HIEROGLYPH_FORMAT_CONTROLS_BEGIN = 78896;
const int EGYPTIAN_HIEROGLYPH_FORMAT_CONTROLS_END = 78943;

const int ANATOLIAN_HIEROGLYPHS_BEGIN = 82944;
const int ANATOLIAN_HIEROGLYPHS_END = 83583;

const int BAMUM_SUPPLEMENT_BEGIN = 92160;
const int BAMUM_SUPPLEMENT_END = 92735;

const int MRO_BEGIN = 92736;
const int MRO_END = 92783;

const int TANGSA_BEGIN = 92784;
const int TANGSA_END = 92789;

const int BASSA_VAH_BEGIN = 92880;
const int BASSA_VAN_END = 92927;

const int PAHAWH_HMONG_BEGIN = 92928;
const int PAHAWH_HMONG_END = 93071;

const int MEDEFAIDRIN_BEGIN = 93760;
const int MEDEFAIDRIN_END = 93855;

const int MIAO_BEGIN = 93952;
const int MIAO_END = 94111;

const int IDEOGRAPHIC_SYMBOLS_AND_PUNCTUATION_BEGIN = 94176;
const int IDEOGRAPHIC_SYMBOLS_AND_PUNCTUATION_END = 94207;

const int TANGUT_BEGIN = 94208;
const int TANGUT_END = 100351;

const int TANGUT_COMPONENTS_BEGIN = 100352;
const int TANGUT_COMPONENTS_END = 101119;

const int KHITAN_SMALL_SCRIPT_BEGIN = 101120;
const int KHITAN_SMALL_SCRIPT_END = 101631;

const int TANGUT_SUPPLEMENT_BEGIN = 101632;
const int TANGUT_SUPPLEMENT_END = 101759;

const int KANA_EXTENDED_B_BEGIN = 110576;
const int KANA_EXTENDED_B_END = 110591;

const int KANA_SUPPLEMENT_BEGIN = 110592;
const int KANA_SUPPLEMENT_END = 110847;

const int KANA_EXTENDED_A_BEGIN = 110848;
const int KANA_EXTENDED_A_END = 110895;

const int SMALL_KANA_EXTENSION_BEGIN = 110896;
const int SMALL_KANA_EXTENSION_END = 110959;

const int NUSHU_BEGIN = 110960;
const int NUSHU_END = 111359;

const int DUPLOYAN_BEGIN = 113664;
const int DUPLOYAN_END = 113823;

const int SHORTHAND_FORMAT_CONTROLS_BEGIN = 113824;
const int SHORTHAND_FORMAT_CONTROLS_END = 113839;

const int ZNAMENNY_MUSICAL_NOTATION_BEGIN = 118528;
const int ZNAMENNY_MUSICAL_NOTATION_END = 118735;

const int BYZANTINE_MUSICAL_SYMBOLS_BEGIN = 118784;
const int BYZANTINE_MUSICAL_SYMBOLS_END = 119039;

const int MUSICAL_SYMBOLS_BEGIN = 119040;
const int MUSICAL_SYMBOLS_END = 119295;

const int ANCIENT_GREEK_MUSICAL_NOTATION_BEGIN = 119296;
const int ANCIENT_GREEK_MUSICAL_NOTATION_END = 119375;

const int KAKTOVIK_NUMERALS_BEGIN = 119488;
const int KAKTOVIK_NUMERALAS_END = 119519;

const int MAYAN_NUMERALS_BEGIN = 119520;
const int MAYAN_NUMERALS_END = 119551;

const int TAI_XUAN_JING_SYMBOLS_BEGIN = 119552;
const int TAI_XUAN_JING_SYMBOLS_END = 119647;

const int COUNTING_ROD_NUMERALS_BEGIN = 119648;
const int COUNTING_ROD_NUMERALS_END = 119679;

const int MATHEMATICAL_ALPHANUMERIC_SYMBOLS_BEGIN = 119808;
const int MATHEMATICAL_ALPHANUMERIC_SYMBOLS_END = 120831;

const int SUTTON_SIGNWRITING_BEGIN = 120832;
const int SUTTON_SIGNWRITING_END = 121519;

const int LATIN_EXTENDED_G_BEGIN = 122624;
const int LATIN_EXTENDED_G_END = 122879;

const int GLAGOLITIC_SUPPLEMENT_BEGIN = 122880;
const int GLAGOLITIC_SUPPLEMENT_END = 122927;

const int CYRILLIC_EXTENDED_D_BEGIN = 122928;
const int CYRILLIC_EXTENDED_D_END = 123023;

const int NYIAKENG_PUACHUE_HMONG_BEGIN = 123136;
const int NYIAKENG_PUACHUE_HMONG_END = 123215;

const int TOTO_BEGIN = 123536;
const int TOTO_END = 123583;

const int WANCHO_BEGIN = 123584;
const int WANCHO_END = 123647;

const int NAG_MUNDARI_BEGIN = 124112;
const int NAG_MUNDARI_END = 124159;

const int ETHIOPIC_EXTENDED_B_BEGIN = 124896;
const int ETHIOPIC_EXTENDED_B_END = 124927;

const int MENDE_KIKAKUI_BEGIN = 124928;
const int MENDE_KIKAKUI_END = 125151;

const int ADLAM_BEGIN = 125184;
const int ADLAM_END = 125279;

const int INDIC_SIYAQ_NUMBERS_BEGIN = 126064;
const int INDIC_SIYAQ_NUMBERS_END = 126143;

const int OTTOMAN_SIYAQ_NUMBERS_BEGIN = 126208;
const int OTTOMAN_SIYAQ_NUMBERS_END = 126287;

const int ARABIC_MATHEMATICAL_ALPHABETIC_SYMBOLS_BEGIN = 126464;
const int ARABIC_MATHEMATICAL_ALPHABETIC_SYMBOLS_END = 126719;

const int MAHJONG_TILES_BEGIN = 126976;
const int MAHJONG_TILES_END = 127023;

const int DOMINO_TILES_BEIGN = 127024;
const int DOMINO_TILES_END = 127135;

const int PLAYING_CARDS_BEGIN = 127136;
const int PLAYING_CARDS_END = 127231;

const int ENCLOSED_ALPHANUMERIC_SUPPLEMENT_BEGIN = 127232;
const int ENCLOSED_ALPHANUMERIC_SUPPLEMENT_END = 127487;

const int ENCLOSED_IDEOGRAPHIC_SUPPLEMENT_BEGIN = 127488;
const int ENCLOSED_IDEOGRAPHIC_SUPPLEMENT_END = 127743;

const int MISCELLANEOUS_SYMBOLS_AND_PICTOGRAPHS_BEGIN = 127744;
const int MISCELLANEOUS_SYMBOLS_AND_PICTOGRAPHS_END = 128511;

const int EMOTICONS_BEGIN = 128512;
const int EMOTICONS_END = 128591;

const int ORNAMENTAL_DINGBATS_BEGIN = 128592;
const int ORNAMENTAL_DINGBATS_END = 128639;

const int TRANSPORT_AND_MAP_SYMBOLS_BEGIN = 128640;
const int TRANSPORT_AND_MAP_SYMBOLS_END = 128767;

const int ALCHEMICAL_SYMBOLS_BEGIN = 128768;
const int ALCHEMICAL_SYMBOLS_END = 128895;

const int GEOMETRIC_SHAPES_EXTENDED_BEGIN = 128896;
const int GEOMETRIC_SHAPES_EXTENDED_END = 129023;

const int SUPPLEMENTAL_ARROWS_C_BEGIN = 129024;
const int SUPPLEMENTAL_ARROWS_C_END = 129279;

const int SUPPLEMENTAL_SYMBOLS_AND_PICTOGRAPHS_BEGIN = 129280;
const int SUPPLEMENTAL_SYMBOLS_AND_PICTOGRAPHS_END = 129535;

const int CHESS_SYMBOLS_BEGIN = 129536;
const int CHESS_SYMBOLS_END = 129647;

const int SYMBOLS_AND_PICTOGRAPHS_EXTENDED_A_BEGIN = 129648;
const int SYMBOLS_AND_PICTOGRAPHS_EXTENDED_A_END = 129791;

const int SYMBOLS_FOR_LEGACY_COMPUTING_BEGIN = 129792;
const int SYMBOLS_FOR_LEGACY_COMPUTING_END = 130047;

# FUNCTIONS:

# determines if the code point is whitespace character (characters with property WS/WSpace/White_Space = Yes)
bool IsWhitespace(CodePoint _character)

# determines if the code point is an arabic digit
bool IsDigit(CodePoint _character)

bool IsHighSurrogate(utf16 _codeUnit)

bool IsLowSurrogate(utf16 _codeUnit)

# determines if the code point is part of Basic Multilingual Plane (it doesn't include the surrogate range)
bool IsBMP(CodePoint _codePoint)

# determines if the code point is part of Supplementary Multilingual Plane
bool IsSMP(CodePoint _codePoint)

# determines if the code point is part of Supplementary Ideographic Plane
bool IsSIP(CodePoint _codePoint)

# determines if the code point is part of Supplementary Special-purpose Plane
bool IsSSP(CodePoint _codePoint)

# determines if the code point is part of Private Use Area
bool IsPUA(CodePoint _codePoint)

# determines if the code point is part of (Supplementary Private Use Area-A)
bool IsPUA2(CodePoint _codePoint)

# determines if the code point is part of (Supplementary Private Use Area-B)
bool IsPUA3(CodePoint _codePoint)

# returns (high surrogate, low surrogate)
# _codePoint is not a code point from BMP ->
t2<utf16, utf16> GetSurrogatePair(CodePoint _codePoint)

# the parameters rerpesents UTF-8 character that is part of BMP ->
utf16 ToUTF16(unsigned char _high, unsigned char _low)

# the parameters represent UTF-8 character that is part of BMP ->
utf16 ToUTF16(unsigned char _high, unsigned char _lowa, unsigned char _lowb)

# returns a single UTF-8 character
# _codeUnit represent a BMP code point ->
list<utf8> ToUTF8(utf16 _codeUnit)

# returns a single UTF-8 character
# the parameters represent a valid surrogate pair ->
list<utf8> ToUTF8(utf16 _highSurrogate, utf16 _lowSurrogate)

# returns a single UTF-8 character
# _codePoint represent a valid Unicode code point ->
list<utf8> ToUTF8(CodePoint _codePoint)

# the parameters represent UTF-8 character that is part of BMP ->
utf32 ToUTF32(unsigned char _high, unsigned char _lowa)

# the parameters represent UTF-8 character that is part of BMP ->
utf32 ToUTF32(unsigned char _high, unsigned char _lowa, unsigned char _lowb)

# the parameters represent UTF-8 character that is not part of BMP ->
utf32 ToUTF32(unsigned char _high, unsigned char _lowa, unsigned char _lowb, unsigned char _lowc)

# the parameters represent a valid surrogate pair ->
utf32 ToUTF32(utf16 _highSurrogate, utf16 _lowSurrogate)

# (SYNONYM:ToUTF32)
# the parameters represent UTF-8 character that is part of BMP ->
CodePoint ToCodePoint(unsigned char _high, unsigned char _lowa)

# (SYNONYM:ToUTF32)
# the parameters represent UTF-8 character that is not part of BMP ->
CodePoint ToCodePoint(unsigned char _high, unsigned char _lowa, unsigned char _lowb)

# (SYNONYM:ToUTF32)
# the parameters represent UTF-8 character that is not part of BMP ->
utf32 ToCodePoint(unsigned char _high, unsigned char _lowa, unsigned char _lowb, unsigned char _lowc)

# (SYNONYM:ToUTF32)
# the parameters represent a valid UTF-8 sequence ->
utf32 ToCodePoint(utf16 _highSurrogate, utf16 _lowSurrogate)

-----------------------------------------------------------------------------------------

time.cpp:

(!) the functionality in this file is located in namespace 'time_'

TimeUnit = MILLISECONDS | SECOND

struct DateTime:

    # CONSTRUCTORS:

    DateTime() = default

    DateTime(int _year, int _month, int _day, int _hour, int _minute, int _second, int _timezone_ = 0)

    DateTime(const DateTime&) = default

    # OPERATORS:

    DateTime& operator=(const DateTime&) = default

    bool operator==(const DateTime& _datetime) const

    bool operator!=(const DateTime& _datetime) const

    # FIELDS:

    int year() const

    int month() const

    int day() const

    int hour() const

    int minute() const

    int second() const

    int timezone() const

    # FUNCTIONS:

    # { 23-5-2009 09:51:07 +3 }.ToTimezone(7) => { 23-5-2009 13:51:07 7 }
    # { 23-5-2009 09:51:07 +3 }.ToTimezone(-8) => { 22-5-2009 22:51:07 -8 }
    # _timezone_ >= -11 & _timezone_ <= 14 ->
   	void ToTimezone(int _timezone_)

    bool IsAfter(const DateTime& _datetime) const

    bool IsBefore(const DateTime& _datetime) const

# CONSTANTS:

long SECONDS_IN_AN_HOUR = 3600

long SECONDS_IN_A_DAY = 86400

long MINUTES_IN_A_DAY = 1440

# FUNCTIONS:

# ToTimezone(2009, 5, 23, 9, 51, 07, +3, 7) -> 2009, 5, 23, 13, 51, 07, 7
# ToTimezone(2009, 5, 23, 9, 51, 07, +3, -8) -> 2009, 5, 22, 22, 51, 07, -8
# _newTimeZone >= -11 & _newTimeZone <= 14 ->
void ToTimezone(int& _year, int& _month, int& _day, int& _hour, int& _minute, int& _second, int& _timezone_, int _newTimeZone)

# DayOfYear(2024, 2, 5) => 36
int DayOfYear(int _year, int _month, int _day)

# DayOfYear({ 2024, 2, 5, 0, 0, 0, 0 }) => 36
int DayOfYear(const DateTime& _datetime)

# _datetime.Year >= 1600 ->
int DayOfWeek(int _year, int _month, int _day)

# _datetime1 and/or _datetime2 is not valid => -1
# _datetime.Year >= 1600 ->
int DayOfWeek(const DateTime& _datetime)

# number of seconds since 01.01.1970 00:00:00 UTC
long long Elapsed()

# returns the number of seconds between the two intervals
# _year1 >= 1600 && _year2 >= 1600 ->
unsigned long long IntervalOf(
     int _year1, int _month1, int _day1, int _hour1, int _minute1, int _second1, int _timezone1,
     int _year2, int _month2, int _day2, int _hour2, int _minute2, int _second2, int _timezone2)

# returns the number of seconds between _datetime and _datetime_
# _datetime1 and/or _datetime2 is not valid => -1
# __datetime1.year() >= 1600 && _datetime2.year() >= 1600 ->
unsigned long long IntervalOf(const DateTime& _datetime1, const DateTime& _datetime2)

# _year >= 1 ->
bool IsLeap(int _year)

bool IsValidDateTime(const DateTime& _datetime)

# => UTC
DateTime Now()

-----------------------------------------------------------------------------------------

filesystem.cpp:

(!) the functionality in this file is located in namespace 'filesystem'

# Errors:
const char E_UNSUCCESSFUL_OPERATION = -1
const char E_UNKNOWN_ERROR = -2
const char E_FILE_DOES_NOT_EXIST = -3
const char E_DIRECTORY_DOES_NOT_EXIST = -4
const char E_SOURCE_DIRECTORY_DOES_NOT_EXIST = -5
const char E_DESTINATION_DIRECTORY_DOES_NOT_EXIST = -6
const char E_FILE_ALREADY_EXISTS = -7
const char E_DIRECTORY_ALREADY_EXISTS = -8
const char E_INVALID_PATH = -9
const char E_INVALID_SOURCE_PATH = -10
const char E_INVALID_DESTINATION_PATH = -11
const char E_NAME_CONTAINS_INVALID_CHARACTERS = -12
const char E_NAME_HAS_INVALID_VALUE = -13
const char E_NAME_ENDS_WITH_EMPTY_SPACE = -14
const char E_EMPTY_NAME = -15
const char E_FILENAME_CONTAINS_INVALID_CHARACTERS = -16
const char E_FILENAME_ENDS_WITH_EMPTY_SPACE = -17
const char E_EMPTY_FILENAME = -18
const char E_FILE_EXTENSION_CONTAINS_INVALID_CHARACTERS = -19
const char E_FILE_NOT_BOUND = -20
const char E_READONLY_FILE = -21
const char E_ACCESS_DENIED = -22
const char E_SYSTEM_FILE_MANIPULATION_ATTEMPT = -23
const char E_SYSTEM_DIRECTORY_MANIPULATION_ATTEMPT = -24
const char E_INDEX_OUT_OF_RANGE = -25
const char E_FIRST_INDEX_LARGER_THAN_SECOND_INDEX = -26

const list<CodePoint> INVALID_NAME_CHARACTERS = [0, '.', ':', '/', '\\', '*', '?', '"', '<', '>', '|']

const list<string> INVALID_NAME_VALUES = ["CON", "PRN", "AUX", "NUL", "COM1", "COM2", "COM3", "COM4", "COM5",
            "COM6", "COM7", "COM8", "COM9", "LPT1", "LPT2", "LPT3", "LPT4", "LPT5", "LPT6", "LPT7", "LPT8", "LPT9"]

# "" => E_EMPTY_NAME
# "ocea:n" => E_NAME_CONTAINS_INVALID_CHARACTERS
# "LPT3" => E_NAME_HAS_FORBIDDEN_VALUE
# "   " => E_NAME_ENDS_WITH_EMPTY_SPACE;
# "ocean " => E_NAME_ENDS_WITH_EMPTY_SPACE;
# _name is a valid name => 0
int IsValidName(const string& _name)

# ".jpeg" => E_EMPTY_NAME
# " .jpeg" => E_NAME_ENDS_WITH_EMPTY_SPACE
# "ocean" => E_MISSING_EXTENSION
# "ocea:n.jpeg" => E_FILENAME_CONTAINS_INVALID_CHARACTERS
# "ocean.jpeg " => E_FILENAME_ENDS_WITH_EMPTY_SPACE
# "ocean.jpeg" => 0
# "ocean." => 0
# _filename is a valid filename => 0
int IsValidFilename(const string& _filename)

# "" => E_EMPTY_PATH
# "Es\pictures\travels" => E_INVALID_ROOT_ELEMENT
# "E:\pictures\travels \" => E_MISSING_FINAL_ELEMENT
# "E:\pictures\travels \desert" => E_PATH_ELEMENT_ENDS_WITH_EMPTY_SPACE
# "E:\pictures\fo:rest" => E_PATH_CONTAINS_INVALID_CHARACTERS
# "E:\pictures\travels\desert" => 0
# _path is a valid directory path => 0
int IsValidDirectoryPath(const string& _path)

# "" => E_EMPTY_PATH
# "Es\pictures\travels \291.jpg" => E_INVALID_ROOT_ELEMENT
# "E:\pictures\travels \" => E_MISSING_FINAL_ELEMENT
# "E:\pictures\travels \291.jpg" => E_PATH_ELEMENT_ENDS_WITH_EMPTY_SPACE
# "E:\pictures\travels\291.jpg" => 0
# _path is a valid file path => 0
int IsValidFilePath(const string& _path)

# _path is syntactically valid path ->
bool IsFilePath(const string& _path)

# _path is syntactically valid path ->
bool IsDirectoryPath(const string& _path)

# "D:\images\forest.bmp" => "forest.bmp"
# _path is syntactically valid path ->
string FilenameOf(const string& _path)

# "D:\images\forest.bmp" => "forest"
# _path is syntactically valid path ->
string NameOf(const string& _path)

# "a.jpg" => "jpg"
# _filepath is syntactically valid file path ->
string ExtensionOf(const string& _filepath)

# "C:\contents\images" => "C:\contents"
# _path is syntactically valid path ->
string ParentDirectoryOf(const string& _path)

# (!) this type is used to (conveniently read or mutate) files without making a copy of the file in RAM, ofcourse at the expense of
	performance (due to writing/reading to/from the permanent storage)
  (!) an instance of this type is always associated with the same physical file, i.e. with the same 'path'
  (!) member function Close() dissociate the object from the physical file; it is automatically invoked on destruction of the object (i.e.
	  when the t:File object goes out of scope); if we want to release the physical file before the destruction of the object we need to
      call Close() explicitly; when calling Close() explicitly no other operations should be performed on the object afterwards #
struct File:

    # VARIABLES:

    TraversalMode TraversalMode = TraversalMode::BOUNDED

    # CONSTRUCTORS:

    File() = default

    # if the file is successfully opened then &Path and &Name will have a set value
    # _path is ASCII value ->
    explicit File(const string& _path)

    File(const File&) = delete

    # OPERATORS:

    # if the function returns UNSUCCESSFUL_OPERATION then it is recommended to check field &os_
    # _index is in the range of file ->
    unsigned char operator[](int _index)

    # if the function returns UNSUCCESSFUL_OPERATION then it is recommended to check field &os_
    # _index is in the range of file ->
    unsigned char operator[](int _index) const

    # assignment is performed only on uncostructed object, i.e. if *this is not associated with a physical file
    # after the operation is completed the old object becomes invalid
    # field &os is not copied
    File& operator=(const File& _file)

    # FIELDS:

    int size() const

    int position() const

    const string& path() const

    const string& name() const

    const string& extension() const

    char os_() const

    # OTHER FUNCTIONS:

    bool IsBound() const

    void Close()

    # TRAVERSAL FUNCTIONS:

    bool can_reverse() const

    bool can_advance() const

    # traversalMode() == BOUNDED && position() - _value < 0 >> position() = position()
    # traversalMode() == BOUNDED && position() - _value > -1 >> position() = position() - _value
    # traversalMode() == CIRCULAR -> circular addition; (EXAMPLE) size() = 19, position() = 4, back(9) >> position() = 14
    File& back()

    # traversalMode() == BOUNDED && position() + _value >= size() >> position() = position()
    # traversalMode() == BOUNDED && position() + _value < size() - 1 >> position() = position() + _value
    # traversalMode() == CIRCULAR -> circular addition; (EXAMPLE) size() = 21, position() = 16, advance(10) >> position() = 5
    File& advance()

    # position() > 0 => [position() - 1]
    # traversalMode() == BOUNDED && position() == 0 => [0]
    # traversalMode() == CIRCULAR && position() == 0 => [size() - 1]
    unsigned char previous() const

    # size() > 0 ->
    unsigned char current() const

    # position() < size() - 1 => [position() + 1]
    # traversalMode() == BOUNDED && position() == size() - 1 => [position()]
    # traversalMode() == CIRCULAR && position() == size() - 1 => [0]
    unsigned char next() const

    # the list has atleast one value ->
    T& last() const

    # _position < -1 || _possition > size() - 1 => -1
    int set_position(int _position)

    # NON-MUTATING FUNCTIONS:

    bool BeginsWith(const list<unsigned char>& _value) const

    bool Contains(unsigned char _value) const

    # [1, 2, 3, 4, 5, 6, 7, 8, 9].Contains([2, 3, 4]) => true
    bool Contains(const list<unsigned char>& _value) const

    bool Contains(std::function<bool(unsigned char)> _predicate) const

    bool EndsWith(const list<unsigned char>& _value) const

    # the specified value does not exist => -1
    int IndexOf(unsigned char _value, int _begin = 0) const

    # the specified value does not exist => -1
    int IndexOf(const list<unsigned char>& _value, int _begin = 0) const

    # the specified value does not exist or _begin is outside the range of list => -1
    int IndexOf(std::function<bool(unsigned char)> _predicate, int _begin = 0) const

    # the specified value does not exist => -1
    int LastIndexOf(unsigned char _value) const

    # the specified value does not exist => -1
    int LastIndexOf(const list<unsigned char>& _value) const

    # the specified value does not exist => -1
    int LastIndexOf(std::function<bool(unsigned char)> _predicate) const

    # buffered read-operation; reads a block at the current position
    # _size + position() < (size() + 1) ->
    void ReadBlock(unsigned char* _array, int _size, bool _advancePosition) const

    # position() + 1 < (size() + 1) ->
    unsigned char ReadI8(bool _advancePosition) const

    # (!) _endianity is the endianity of the source-integral
    # reads a 16-bit unsigned integral value at the current position
    # position() + 2 < (size() + 1) ->
    unsigned short ReadI16(Endianity _endianity, bool _advancePosition) const

    # (!) _endianity is the endianity of the source-integral
    # reads a 32-bit unsigned integral value at the current position
    # position() + 4 < (size() + 1) ->
    unsigned int ReadI32(Endianity _endianity, bool _advancePosition) const

    # (!) _endianity is the endianity of the source-integral
    # reads a 64-bit unsigned integral value at the current position
    # position() + 8 < (size() + 1) ->
    unsigned long long ReadI64(Endianity _endianity, bool _advancePosition) const

    # _length = 0 => [_begin..]
    # (_begin + _length) >= size() => []
    list<unsigned char> Sublist(int _begin, int _length = 0) const

    # [5, 8, 4, 1, 9, 6, 2, 3, 0, 5, 5, 1, 7].Subrange(2, 5) => [4, 1, 9, 6]
    list<unsigned char> Subrange(int _begin, int _end) const

    # MUTATION FUNCTIONS:

    File& Append(unsigned char _value)

    File& Append(const list<unsigned char>& _value)

    File& Append(const unsigned char* _value, int _length)

    File& Clear()

    # (size() > 0 && _index > 0 && (_index <= size())) =>
    File& Insert(unsigned char _value, int _index)

    # (size() > 0 && _index > 0 && (_index <= size())) =>
    File& Insert(const list<unsigned char>& _list, int _index)

    File& RemoveAt(int _index, int _length = 1)

    File& Remove(int _begin, int _end)

    File& SetAt(int _index, unsigned char _value)

    # _index1 <= _index2 ->
    File& Swap(int _index1, int _index2)

    # buffered write-operation; overwrites the block at the current position; if the current position is at the end of the file then it appends data
    # (!) it cannot insert data
    # _size + position() < (size() + 1) ->
    File& WriteBlock(const unsigned char* _array, int _size, bool _advancePosition)

    # writes a 8-bit unsigned integral value ath the current position
    # position() + 1 < (size() + 1) ->
    File& WriteI18(unsigned short _value, bool _advancePosition)

    # (!) _endianity is the endianity of the source-integral
    # writes a 16-bit unsigned integral value ath the current position
    # position() + 2 < (size() + 1) ->
    File& WriteI16(unsigned short _value, Endianity _endianity, bool _advancePosition)

    # (!) _endianity is the endianity of the source-integral
    # writes a 32-bit unsigned integral value at the current position
    # position() + 4 < (size() + 1) ->
    File& WriteI32(unsigned int _value, Endianity _endianity, bool _advancePosition)

# if the directory exists then &Path and &Name will have a set value
struct Directory:

    # CONSTRUCTORS:

    Directory() = default

    explicit Directory(const string& _path)

    Directory(const Directory&) = delete

    Directory& operator=(const Directory&) = default

    # OPERATORS:

    bool operator==(const Directory& _directory) const

    bool operator!=(const Directory& _directory) const

    # FIELDS:

    const string &path() const

    const string &name() const

# returns the paths of all subdirectories in the specified directory
# (!) shows the hidden directories as well
# the specified directory exists and can be accessed ->
list<string> DirectoriesOf(const string& _directoryPath)

# returns the filepaths of all files in the specified directory
# (!) shows the hidden files as well
# the specified directory exists and can be accessed ->
list<string> FilesOf(const string& _directoryPath)

# (!) returns false if _path specifies a system file
bool FileExists(const string& _path)

bool DirectoryExists(const string& _path)

# the specified file exists ->
int SizeOf(const string& _path)

# the specified file/directory exists ->
bool IsEncrypted(const string& _path)

# the specified file/directory exists ->
bool IsHidden(const string& _path)

# the specified file/directory exists ->
bool IsReadOnly(const string& _path)

# the specified file/directory exists ->
bool IsSystem(const string& _path)

# the specified file/directory exists ->
time_::DateTime GetCreationTime(const string& _path)

# the specified file/directory exists ->
time_::DateTime GetLastAccessTime(const string& _path)

# the specified file/directory exists ->
time_::DateTime GetLastMutationTime(const string& _path)

# returns 0 on successful execution
int CreateFile(const string& _path)

# returns 0 on successful execution
int CreateDirectory(const string& _path)

# returns 0 on successful execution
int RenameFile(const string& _filepath, const string& _newFilename)

# returns 0 on successful execution
int RenameDirectory(const string& _path, const string& _newName)

# returns 0 on successful execution
# _sourcePath specifies the copied file
# _destinationPath specifies the directory in which the file should be copied
int CopyFile(const string& _sourcePath, const string& _destinationPath)

# returns 0 on successful execution
# _sourcePath specifies the copied directory
# _destinationPath specifies the directory in which the directory should be copied
int CopyDirectory(const string& _sourcePath, const string& _destinationPath)

# returns 0 on successful execution
int DeleteFile(const string& _path)

# returns 0 on successful execution
# it is possible that the specified directory is not fully deleted;
  such scenario can happen if some files/directories within the directory cannot be deleted #
int DeleteDirectory(const string& _path)

# returns 0 on successful execution
int SetFileAttribute(const string& _path, FileAttribute _attribute)

# returns 0 on successful execution
void SetDirectoryAttribute(const string& _path, DirectoryAttribute _attribute)

# error => ""
string GetApplicationDirectory()

-----------------------------------------------------------------------------------------

event.cpp:

template<typename... args> struct event:

    # CONSTRUCTORS:

    event() = default

    # OPERATORS:

    event& operator=(const event&) = default

    # adds a subscriber to the list of subscribers
    void operator+= (void(*_subscriber)(args...))

    # notifies each subscriber when the event occurs
    void operator()(args... _parameters) const

    # FIELDS:

    const list<void(*)(args...)>& subscribers() const

-----------------------------------------------------------------------------------------

timer.cpp:

struct Timer:

    # CONSTRUCTORS:

    Timer() = default

    # the interval is set in microseconds
    # _repeat specifies whether the period is repeated after the previous one ends
    # _data is an optional data
    Timer(int _interval, bool _repeat, void* _data = nullptr)

    Timer(const Timer&) = delete

    # OPERATORS:

    Timer& operator=(const Timer&) = delete

    # FIELDS:

    bool Repeat = false

    event<Timer*, void*> OnTick

    int interval()

    # FUNCTIONS:

    bool IsRunning()

    void Restart()

    void Start()

    void Stop()

-----------------------------------------------------------------------------------------

chronometer.cpp:

# Chronometer c -> [computations -> c.Elapsed() | c.Reset()]
# c.Running -> Elapsed() => > -1
# !c.Running -> Elapsed() => -1
struct Chronometer:

    # CONSTRUCTORS:

    Chronometer() = default

    Chronometer(const Chronometer&) = delete

    # OPERATORS:

    Chronometer& operator=(const Chronometer&) = delete

    # FUNCTIONS:

    # in microseconds
    int Elapsed() const

    bool IsRunning() const

    void Start()

    void Reset()

-----------------------------------------------------------------------------------------

geometry.cpp:

# (!!!) the result of some functions may depend on the variable 'FloatingPointPrecision'

# TERMINOLOGY:

# (bitex) :: 2D point
# (termex) :: end point of a vector
# (centex) :: center point of a line
# (common vertex / common endpoint) :: a point that belongs to two different lines
# (aligned lines) the meaning is described in the section LINES
# (unified lines) the meaning is described in the section LINES
# (line touching) one of the endpoints of a line-1 belongs to the set of points of line-2
# (formator) a line between two adjacent vertices of a polygon
# (radial) the meaning is described in the section ORIENTATIONS

# COORDINATE SYSTEMS:

# three types of coordinate systems:
  - Top-Left - with origin the top-left point/corner of a 2D plane; coordinates are always positive
  - Bottom-Left - with origin the bottom-left point/corner of a 2D plane; coordinates are always positive
  - Cartesian - (OBVIOUS-MEANING); coordinates can be negative or positive #

# ORIENTATIONS:

# - orientations are specified in degrees
  - every orientation can have a value between 0.0 and infinity
  - every orientation has a 'true value' or so called 'radial' which is between 0.0 and 360.0
     (EXAMPLE) the radial of an orientation 19 is 19
     (EXAMPLE) the radial of an orientation 348 is 348
     (EXAMPLE) the radial of an orientation 523 is 163 (one full turn + 163 degrees)
     (EXAMPLE) the radial of an orientation 745 is 25 (two full turns + 45 degrees)
   - each orientation has 'opposite' orientation; an orientation and it's opposite differ by 180 degrees
     (EXAMPLE) the opposite orientation of 32 is 212
     (EXAMPLE) the opposite orientation of 212 is 32
     (EXAMPLE) the opposite orientation of 95 is 275
     (EXAMPLE) the opposite orientation of 275 is 95
     (EXAMPLE) the opposite orientation of 43.67 is 223.67
   - orientation 0 is upwards
   - orientation 90 is to the right
   - orientation 180 is downwards
   - orientation 270 is to the left
   - orientation between 0.0 and 90.0 is in quadrant 1
   - orientation between 90.0 and 180.0 is in quadrant 2
   - orientation between 180.0 and 270.0 is in quadrant 3
   - orientation between 270.0 and 360.0 is in quadrant 4
   - orientation equal to 90.0 is 'Right-Aligned'
   - orientation equal to 180.0 is 'Bottom-Aligned'
   - orientation equal to 270.0 is 'Left-Aligned'
   - orientation equal to 360.0 is 'Top-Aligned' #

# LINES:

# lines are abstract objects; they are infinitely thin, i.e. they do not have thickness

# - there are 5 possible line relations:
    (1) two lines are parallel to each other
    (2) two lines intersect
    (3) two lines touch; touching is not an intersection; this is mathematical definition only; in reality an endpoint of a line will be
        (or not be) on a line depending on the precision of the calculations, so atleast for now touching MAY BE an intersection
    (4) two lines form a path (they have a common point); in this case there is touching as well
    (5) two lines are aligned - if one of the lines extend to infinity it will contain the other

  - if two lines are aligned then they do not intersect
  - aligned lines have 3 subrelations:
    (1) one of the lines can fully contain the other line
    (2) one of the lines can partially contain the other line
    (3) the lines may not share points
  - two aligned lines that share points are called 'unified' lines, respectively two aligned lines that do not share points are
    called 'non-unified' lines; two lines that form a path are not unified
  - two lines that forms a path also touch each other #

# TYPES:

enum class Quadrant = QUADRANT_1 | QUADRANT_2 | QUADRANT_3 | QUADRANT_4 | LEFT_ALIGNED | RIGHT_ALIGNED | TOP_ALIGNED | BOTTOM_ALIGNED

struct Bitex:

    # FIELDS:

    float X
    float Y

    # CONSTRUCTORS:

    Bitex() = default

    Bitex(float _x, float _y)

    # OPERATORS:

    bool operator==(const Bitex& _bitex) const

    bool operator!=(const Bitex& _bitex) const

struct Tritex:

    # FIELDS:

    double X
    double Y
    double Z

    # CONSTRUCTORS:

    Tritex() = default

    Tritex(double _x, double _y, double _z)

    # OPERATORS:

    bool operator==(const Tritex& _tritex) const

    bool operator!=(const Tritex& _tritex) const

struct Vector2D:

    # FIELDS:

    double X
    double Y
    double Magnitude
    double Orientation

    # CONSTRUCTORS:

    Vector2D() = default

    Vector2D(double _x, double _y, double _magnitude, double _orientation)

    # OPERATORS:

    bool operator==(const Vector2D& _vector) const

    bool operator!=(const Vector2D& _vector) const

struct Vector3D:

    # FIELDS:

    double X
    double Y
    double Z
    double Magnitude

    # CONSTRUCTORS:

    Vector3D() = default

    Vector3D(double _x, double _y, double _z, double _magnitude)

    # OPERATORS:

    bool operator==(const Vector3D& _vector) const

    bool operator!=(const Vector3D& _vector) const

struct Line:

   # FIELDS:

   Bitex P1
   Bitex P2

   # CONSTRUCTORS:

   Line() = default

   Line(double x1, double y1, double x2, double y2)

   Line(const Bitex& _p1, const Bitex& _p2)

   # OPERATORS:

   # (A, B) == (B, C) => false
   # (A, B) == (B, A) => true
   # (A, B) == (A, B) => true
   bool operator==(const Line& _line) const

   # (A, B) != (B, C) => true
   # (A, B) != (B, A) => false
   # (A, B) != (A, B) => false
   bool operator!=(const Line& _line) const

   # FUNCTIONS:

   # &this and _line are valid lines ->
   bool IsParallelTo(const Line& _line) const

   # &this and _line are valid lines ->
   bool AlignWith(const Line& _line) const

   # &this and _line are valid lines ->
   bool IsUnifiedWith(const Line& _line) const

   # returns true if the two lines have a common point
   bool PathWith(const Line& _line) const

   # two (equal) or (unified lines) do not intersect
   # parallel lines do not intersect
   # unified lines do not intersect
   # lines that have common vertex do not intersect
   # line touching without vertex intersection is not an intersection
   # line touching with vertex intersection is an intersection
   bool Intersect(const Line& _line) const

   bool Contains(const Line& _line) const

   # FIELDS

   Bitex Centex() const

   double Length() const

# the vertices must form simple convex or simple concave polygon
struct Polygon
{
    # FIELDS:

    list<Bitex> Vertices

    # CONSTRUCTORS:
    
    Polygon() = default

    Polygon(const list<Bitex>& _vertices) 

    Polygon(const Polygon&) = default

    # OPERATORS:
    
    Polygon& operator=(const Polygon&) = default;

    # [(20, 7) (9, 15) (30, 14) (16, 3)] == [(30, 14) (16, 3) (20, 7) (9, 15)] => true
    # [(20, 7) (9, 15) (30, 14) (16, 3)] == [(30, 14) (20, 7) (9, 15) (16, 3)] => false
    # [(20, 7) (9, 15) (30, 14)] == [(20, 7) (7, 15) (30, 14)] => false
    bool operator==(const Polygon& _polygon) const

    # [(20, 7) (9, 15) (30, 14) (16, 3)] == [(30, 14) (16, 3) (20, 7) (9, 15)] => true
    # [(20, 7) (9, 15) (30, 14) (16, 3)] == [(30, 14) (20, 7) (9, 15) (16, 3)] => false
    # [(20, 7) (9, 15) (30, 14)] == [(20, 7) (7, 15) (30, 14)] => false
    bool operator!=(const Polygon& _polygon) const
    
# CONSTANTS:

double PI = 3.1415926535897932384

# VARIABLES:

double FloatingPointPrecision = 0.00001; /* two floating-point values will be considered equal if the difference between them is
       less or equal than this value */

# FUNCTIONS:

double DegreesToRadians(double _degrees)

double RadiansToDegrees(double _radians)

# RadialOF(7) => 7
# RadialOf(450) => 90
# RadialOf(458) => 98
# RadialOf(723) => 3
# RadialOf(894) => 174
# _orientation < 0 => -1
double RadialOf(double _orientation)

# (215, 92) => 307
# (340, 105) => 85
# (240, 820) => 340
# _orientation < 0 || _value < 0 => -1
# _orientation > 0 & _value > 0 ->
double OrientationPlus(double _orientation, double _value)

# (307, 92) => 215
# (85, 105) => 340
# (340, 820) => 240
# _orientation < 0 || _value < 0 => -1
# _orientation > 0 & _value > 0 ->
double OrientationMinus(double _orientation, double _value)

# the coordinates are specified in Top-Left coordinate system
# originX == pointX && originY == pointY => 0
# originX != pointX || originY != pointY => 0..360
double OrientationOf(double originX, double originY, double pointX, double pointY)

# the coordinates are specified in Top-Left coordinate system
# _origin == _point => 0
# _origin != _point => 0..360
double OrientationOf(const Bitex& _origin, const Bitex& _point)

double DistanceOf(double x1, double y1, double x2, double y2)

double DistanceOf(const Bitex& b1, const Bitex& b2)

double DistanceOf(double x1, double y1, double z1, double x2, double y2, double z2)

double DistanceOf(Tritex t1, Tritex t2)

Bitex CentexOf(double x1, double y1, double x2, double y2)

Bitex CentexOf(const Bitex& p1, const Bitex& p2)

# this function uses Top-Left coordinate system
# _origin == _point => 0
# _origin != _point => 0..360
Bitex TermexOf(double _originX, double _originY, double _orientation, double _magnitude)

# this function uses Top-Left coordinate system
# _origin == _point => 0
# _origin != _point => 0..360
Bitex TermexOf(const Bitex& _bitex, double _orientation, double _magnitude)

# (0.0 | 360.0) => TOP_ALIGNED
# (90.0) => RIGHT_ALIGNED
# (180.0) => BOTTOM_ALIGNED
# (270.0) => LEFT_ALIGNED
# (2.3) => QUADRANT_1
# (92.0) => QUADRANT_2
# (186.42) => QUADRANT_3
# (312.5) => QUADRANT_4
Quadrant QuadrantOf(double _orientation)

# (120, 120) => 0
# (60, 140) => 80
# (140, 60) => 280
# (110, 305) => 195
# (290, 50) => 120
# (290, 307) => 17
# (290, 200) => 270
double ClockwiseOffset(double _orientation1, double _orientation2)

# (10, 105, 53) => true
# (300, 58, 6) => true
# (307, 321, 310) => true
# (321, 307, 310) => false
# _aor1 >= 0, _aor2 >= 0 ->
bool AngleContains(double _aor1, double _aor2, double _orientation)

t2<double, double> OrientationsOf(double _angleOrientation, double _angleMagnitude)

# (MUTATE _coordinates)
# this function uses Top-Left coordinate system
# &_value is specified in degrees
void Rotate(list<double>& _coordinates, double _originX, double _originY, short _value)

# vertex coordinates describes a closed polygon ->
list<Line> FormatorsOf(const list<double>& _coordinates)

# vertices describe a closed polygon ->
list<Line> SidesOf(const list<Bitex>& _vertices)

bool CollinearityOf(const list<Bitex>& _points)

# fewer than 3 points => -1
# there are some equal points => -2
# the points are collinear => -3
char IsPolygon(const list<Bitex>& _points)

# fewer than 3 points => -1
# there are some equal points => -2
# the points are collinear => -3
# the shape contain unified lines => -4
# the polygon is not simple => -5
char IsSimplePolygon(const list<Bitex>& _points)

# fewer than 3 points => -1
# there are some equal points => -2
# the points are collinear => -3
# the shape contain unified lines  => -4
# the polygon is not simple => -5
# the polygon is convex => 0
# the polygon is concave => 1
# the points form a simple polygon ->
char IsConvexPolygon(const list<Bitex>& _points)

# fewer than 3 points => -1
# there are some equal points => -2
# the points are collinear => -3
# the shape contain unified lines  => -4
# the polygon is not simple => -5
# the polygon is convex => 1
# the points form a simple polygon ->
char IsConcavePolygon(const list<Bitex>& _points)

# &a and &b have common point and are not equal ->
Bitex CommonPointOf(const Line& a, const Line& b)

# &a and &b have common point and are not equal ->
t2<Bitex, Bitex> NonCommonPointsOf(const Line& a, const Line& b)
